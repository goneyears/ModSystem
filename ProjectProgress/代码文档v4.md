# Unity模组通信系统 - 完整实现与文档 v4

## 目录
1. [系统概述](#系统概述)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
   - 3.1 [基础接口定义](#基础接口定义)
   - 3.2 [运行时核心组件](#运行时核心组件)
   - 3.3 [通信系统](#通信系统)
   - 3.4 [安全系统](#安全系统)
4. [通信模式详解](#通信模式详解)
5. [模组开发](#模组开发)
6. [完整代码实现](#完整代码实现)
7. [配置系统](#配置系统)
8. [独立开发SDK](#独立开发sdk)
9. [部署和安装](#部署和安装)
10. [调试和优化](#调试和优化)
11. [最佳实践](#最佳实践)
12. [常见问题解答](#常见问题解答)

## 系统概述

本通信系统提供了一个完整的Unity模组化开发框架，具有以下特点：

- **平台无关的核心层**：Core层不依赖Unity，可用于任何.NET项目
- **多种通信模式**：事件系统、请求-响应、服务注册、配置驱动
- **独立开发支持**：无需Unity编辑器即可开发模组
- **类型安全**：通过接口和泛型保证类型安全
- **对象定义系统**：使用JSON替代Unity的Prefab系统
- **安全机制**：防止恶意代码执行
- **完整工具链**：从开发到打包的全流程支持

### 开发环境标识

- 🔵 **Unity编辑器中开发**：需要Unity环境的代码
- 🟢 **Visual Studio独立开发**：纯C#代码，可编译为DLL
- 🟡 **文本编辑器**：JSON配置文件

## 项目结构

### 完整的工作区结构

```
工作区/
├── ModSystemCore/              # 🟢 VS独立项目（平台无关）
│   ├── ModSystem.Core.sln
│   ├── ModSystem.Core/
│   │   ├── Interfaces/         # 接口定义
│   │   ├── EventSystem/        # 事件系统
│   │   ├── Communication/      # 通信系统
│   │   ├── Services/           # 服务系统
│   │   ├── Runtime/            # 运行时核心
│   │   └── Security/           # 安全系统
│   └── bin/Release/
│       └── ModSystem.Core.dll  → 复制到Unity项目
│
├── ModSDK/                     # 🟢 独立开发SDK
│   ├── SDK/
│   │   ├── ModSDK.Core.dll    # 从ModSystemCore构建
│   │   ├── ModSDK.Runtime.dll
│   │   └── Newtonsoft.Json.dll
│   ├── Tools/
│   │   ├── ModBuilder.exe
│   │   └── ModEditor.exe
│   └── Templates/              # 🟡 模板系统
│       ├── ButtonMod/
│       ├── RobotMod/
│       └── template-registry.json
│
├── MyMods/                     # 🟢 模组开发项目
│   ├── ButtonMod/
│   └── RobotMod/
│
└── UnityGameProject/           # 🔵 Unity项目
    └── Assets/
        └── ModSystem/
            ├── Core/
            │   └── Assemblies/  # Core DLL放置位置
            ├── Unity/           # Unity特定代码
            │   ├── ModSystemController.cs
            │   ├── ModManager.cs
            │   ├── UnityImplementations/
            │   └── Editor/
            ├── Examples/        # 示例项目
            └── StreamingAssets/
                ├── ModConfigs/
                ├── Mods/
                └── ModPackages/
```

### 层次架构说明

```
┌─────────────────────────────────────────────┐
│              用户模组 (User Mods)            │
├─────────────────────────────────────────────┤
│               ModSDK (开发SDK)               │
├─────────────────────────────────────────────┤
│           Unity层 (Unity Specific)           │
│  ModSystemController, Unity实现, Editor工具   │
├─────────────────────────────────────────────┤
│          核心层 (ModSystem.Core)             │
│     平台无关的接口、事件系统、通信系统         │
└─────────────────────────────────────────────┘
```

## 核心组件

### 基础接口定义

#### 1. 核心抽象接口（平台无关）🟢

```csharp
// ModSystem.Core/Interfaces/IPlatformAbstractions.cs
namespace ModSystem.Core
{
    /// <summary>
    /// 日志接口，用于替代Unity的Debug类
    /// </summary>
    public interface ILogger
    {
        void Log(string message);
        void LogWarning(string message);
        void LogError(string message);
    }
    
    /// <summary>
    /// 路径提供接口，用于替代Unity的Application类
    /// </summary>
    public interface IPathProvider
    {
        string GetModsPath();
        string GetConfigPath();
        string GetTempPath();
        string GetPersistentDataPath();
    }
    
    /// <summary>
    /// 游戏对象接口，用于抽象Unity的GameObject
    /// </summary>
    public interface IGameObject
    {
        string Name { get; set; }
        bool IsActive { get; set; }
        ITransform Transform { get; }
        T GetComponent<T>() where T : class;
        T AddComponent<T>() where T : class;
    }
    
    /// <summary>
    /// 变换接口，用于抽象Unity的Transform
    /// </summary>
    public interface ITransform
    {
        Vector3 Position { get; set; }
        Quaternion Rotation { get; set; }
        Vector3 Scale { get; set; }
        ITransform Parent { get; set; }
    }
}
```

#### 2. 模组系统核心接口 🟢

```csharp
// ModSystem.Core/Interfaces/IModEvent.cs
namespace ModSystem.Core
{
    /// <summary>
    /// 模组事件基础接口
    /// </summary>
    public interface IModEvent
    {
        string EventId { get; }
        string SenderId { get; set; }
        DateTime Timestamp { get; set; }
    }
    
    /// <summary>
    /// 事件总线接口
    /// </summary>
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler) where T : IModEvent;
        void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent;
        void Publish<T>(T eventData) where T : IModEvent;
        void Unsubscribe<T>(Action<T> handler) where T : IModEvent;
    }
    
    /// <summary>
    /// 模组行为接口
    /// </summary>
    public interface IModBehaviour
    {
        string BehaviourId { get; }
        string Version { get; }
        void OnInitialize(IModContext context);
        void OnUpdate(float deltaTime);
        void OnDestroy();
    }
    
    /// <summary>
    /// 对象附加行为接口（用于ObjectFactory创建的对象）
    /// </summary>
    public interface IObjectBehaviour
    {
        void OnAttach(IGameObject gameObject);
        void OnConfigure(Dictionary<string, object> config);
        void OnDetach();
    }
    
    /// <summary>
    /// 模组上下文接口
    /// </summary>
    public interface IModContext
    {
        string ModId { get; }
        IGameObject GameObject { get; }
        IEventBus EventBus { get; }
        IModAPI API { get; }
        IServiceRegistry Services { get; }
        T GetComponent<T>() where T : class;
        void Log(string message);
        void LogError(string message);
    }
}
```

### 运行时核心组件

#### 1. ModSystemController（Unity集成控制器）🔵

```csharp
// ModSystem.Unity/ModSystemController.cs
using UnityEngine;
using ModSystem.Core;
using System.IO;

namespace ModSystem.Unity
{
    /// <summary>
    /// Unity模组系统主控制器
    /// 负责初始化和管理整个模组系统
    /// </summary>
    public class ModSystemController : MonoBehaviour
    {
        private ModManagerCore modManagerCore;
        private ModEventBus eventBus;
        private ModServiceRegistry serviceRegistry;
        private CommunicationRouter router;
        private UnityLogger logger;
        private UnityPathProvider pathProvider;
        
        public IEventBus EventBus => eventBus;
        public IServiceRegistry ServiceRegistry => serviceRegistry;
        
        void Awake()
        {
            // 创建Unity实现
            logger = new UnityLogger();
            pathProvider = new UnityPathProvider();
            
            // 初始化核心组件
            eventBus = new ModEventBus(new UnityEventLogger());
            serviceRegistry = new ModServiceRegistry(eventBus);
            
            // 创建核心模组管理器
            modManagerCore = new ModManagerCore(logger, pathProvider, eventBus, serviceRegistry);
            
            // 创建Unity包装器
            var modManager = gameObject.AddComponent<ModManager>();
            modManager.Initialize(modManagerCore);
            
            // 加载通信配置
            LoadCommunicationConfig();
        }
        
        void Start()
        {
            // 加载模组
            LoadMods();
        }
        
        private void LoadCommunicationConfig()
        {
            string configPath = Path.Combine(pathProvider.GetConfigPath(), 
                "communication_config.json");
            
            if (File.Exists(configPath))
            {
                string configJson = File.ReadAllText(configPath);
                router = new CommunicationRouter(eventBus, configJson);
                logger.Log("Communication config loaded");
            }
        }
        
        private async void LoadMods()
        {
            // 加载内置模组
            await modManagerCore.LoadModsFromDirectory(pathProvider.GetModsPath());
            
            // 加载外部模组包
            await modManagerCore.LoadModPackagesFromDirectory(
                Path.Combine(pathProvider.GetModsPath(), "../ModPackages")
            );
        }
    }
}
```

#### 2. ModManagerCore（平台无关的模组管理器）🟢

```csharp
// ModSystem.Core/Runtime/ModManagerCore.cs
namespace ModSystem.Core
{
    /// <summary>
    /// 平台无关的模组管理器核心
    /// 负责模组的加载、管理和生命周期控制
    /// </summary>
    public class ModManagerCore
    {
        private readonly ILogger logger;
        private readonly IPathProvider pathProvider;
        private readonly IEventBus eventBus;
        private readonly IServiceRegistry serviceRegistry;
        private readonly ModLoader modLoader;
        private readonly Dictionary<string, ModInstance> modInstances;
        
        public string LastError { get; private set; }
        public List<string> ValidationErrors { get; private set; } = new List<string>();
        
        public ModManagerCore(
            ILogger logger, 
            IPathProvider pathProvider,
            IEventBus eventBus,
            IServiceRegistry serviceRegistry)
        {
            this.logger = logger;
            this.pathProvider = pathProvider;
            this.eventBus = eventBus;
            this.serviceRegistry = serviceRegistry;
            
            var securityConfig = LoadSecurityConfig();
            var securityManager = new SecurityManager(securityConfig, logger);
            
            modLoader = new ModLoader(logger, pathProvider, securityManager);
            modInstances = new Dictionary<string, ModInstance>();
        }
        
        public async Task<bool> LoadMod(string modPath)
        {
            try
            {
                ValidationErrors.Clear();
                
                // 加载模组
                var loadedMod = await modLoader.LoadModAsync(modPath);
                
                // 创建模组实例
                var instance = CreateModInstance(loadedMod);
                modInstances[loadedMod.Manifest.id] = instance;
                
                // 初始化行为
                foreach (var behaviour in loadedMod.Behaviours)
                {
                    var context = CreateModContext(loadedMod, instance);
                    behaviour.OnInitialize(context);
                }
                
                // 发布模组加载事件
                eventBus.Publish(new ModLoadedEvent
                {
                    ModId = loadedMod.Manifest.id,
                    ModName = loadedMod.Manifest.name,
                    Version = loadedMod.Manifest.version
                });
                
                logger.Log($"Mod loaded: {loadedMod.Manifest.name} v{loadedMod.Manifest.version}");
                return true;
            }
            catch (Exception ex)
            {
                LastError = ex.Message;
                logger.LogError($"Failed to load mod: {ex}");
                return false;
            }
        }
        
        private ModInstance CreateModInstance(LoadedMod loadedMod)
        {
            return new ModInstance
            {
                LoadedMod = loadedMod,
                State = ModState.Loaded
            };
        }
        
        private IModContext CreateModContext(LoadedMod loadedMod, ModInstance instance)
        {
            return new ModContext
            {
                ModId = loadedMod.Manifest.id,
                EventBus = eventBus,
                Services = serviceRegistry,
                Logger = logger,
                API = CreateModAPI(loadedMod)
            };
        }
        
        public async Task LoadModsFromDirectory(string directory)
        {
            if (!Directory.Exists(directory))
            {
                logger.LogWarning($"Mods directory not found: {directory}");
                return;
            }
            
            foreach (var modDir in Directory.GetDirectories(directory))
            {
                await LoadMod(modDir);
            }
        }
        
        // 其他方法...
    }
}
```

#### 3. ModManager（Unity包装器）🔵

```csharp
// ModSystem.Unity/ModManager.cs
using UnityEngine;
using ModSystem.Core;
using System.Collections.Generic;

namespace ModSystem.Unity
{
    /// <summary>
    /// Unity特定的ModManager包装器
    /// 处理Unity生命周期和GameObject管理
    /// </summary>
    public class ModManager : MonoBehaviour
    {
        private ModManagerCore core;
        private Dictionary<string, ModUnityInstance> unityInstances;
        private IObjectFactory objectFactory;
        
        public void Initialize(ModManagerCore core)
        {
            this.core = core;
            unityInstances = new Dictionary<string, ModUnityInstance>();
            objectFactory = new UnityObjectFactory();
            
            // 监听模组加载事件
            core.EventBus.Subscribe<ModLoadedEvent>(OnModLoaded);
            core.EventBus.Subscribe<ModUnloadedEvent>(OnModUnloaded);
        }
        
        private void OnModLoaded(ModLoadedEvent e)
        {
            CreateUnityInstance(e.ModId);
        }
        
        private void CreateUnityInstance(string modId)
        {
            var modInstance = core.GetModInstance(modId);
            if (modInstance == null) return;
            
            // 创建Unity容器
            var container = new GameObject($"Mod_{modId}");
            container.transform.SetParent(transform);
            
            var unityInstance = new ModUnityInstance
            {
                Container = container,
                GameObjects = new List<GameObject>()
            };
            
            // 为每个行为创建GameObject
            foreach (var behaviour in modInstance.LoadedMod.Behaviours)
            {
                var behaviourObj = new GameObject($"Behaviour_{behaviour.BehaviourId}");
                behaviourObj.transform.SetParent(container.transform);
                
                // 添加更新组件
                var updater = behaviourObj.AddComponent<ModBehaviourUpdater>();
                updater.Initialize(behaviour);
                
                unityInstance.GameObjects.Add(behaviourObj);
            }
            
            // 创建对象定义中的GameObject
            CreateObjectsFromDefinitions(modInstance, unityInstance);
            
            unityInstances[modId] = unityInstance;
        }
        
        private async void CreateObjectsFromDefinitions(
            ModInstance modInstance, 
            ModUnityInstance unityInstance)
        {
            foreach (var objDef in modInstance.LoadedMod.Resources.ObjectDefinitions.Values)
            {
                try
                {
                    var obj = await objectFactory.CreateObjectFromDefinitionAsync(objDef);
                    obj.transform.SetParent(unityInstance.Container.transform);
                    unityInstance.GameObjects.Add(obj);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Failed to create object {objDef.objectId}: {ex.Message}");
                }
            }
        }
        
        void OnDestroy()
        {
            // 清理所有Unity实例
            foreach (var instance in unityInstances.Values)
            {
                if (instance.Container != null)
                    Destroy(instance.Container);
            }
        }
    }
    
    public class ModUnityInstance
    {
        public GameObject Container { get; set; }
        public List<GameObject> GameObjects { get; set; }
    }
}
```

#### 4. ModLoader（平台无关的模组加载器）🟢

```csharp
// ModSystem.Core/Runtime/ModLoader.cs
using System;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    /// <summary>
    /// 平台无关的模组加载器
    /// 负责加载模组文件和程序集
    /// </summary>
    public class ModLoader
    {
        private readonly ILogger logger;
        private readonly IPathProvider pathProvider;
        private readonly SecurityManager securityManager;
        private readonly Dictionary<string, LoadedMod> loadedMods;
        
        public ModLoader(ILogger logger, IPathProvider pathProvider, SecurityManager securityManager = null)
        {
            this.logger = logger;
            this.pathProvider = pathProvider;
            this.securityManager = securityManager;
            this.loadedMods = new Dictionary<string, LoadedMod>();
        }
        
        public async Task<LoadedMod> LoadModAsync(string modDirectory)
        {
            try
            {
                // 1. 加载清单文件
                var manifestPath = Path.Combine(modDirectory, "manifest.json");
                if (!File.Exists(manifestPath))
                {
                    throw new FileNotFoundException("Manifest file not found");
                }
                
                var manifestJson = await File.ReadAllTextAsync(manifestPath);
                var manifest = JsonConvert.DeserializeObject<ModManifest>(manifestJson);
                
                // 2. 验证安全性
                if (securityManager != null && !securityManager.ValidateMod(modDirectory))
                {
                    throw new SecurityException("Mod failed security validation");
                }
                
                // 3. 加载程序集
                Assembly assembly = null;
                var dllPath = Path.Combine(modDirectory, "Assemblies", $"{manifest.id}.dll");
                if (File.Exists(dllPath))
                {
                    assembly = Assembly.LoadFrom(dllPath);
                }
                
                // 4. 加载资源
                var resources = await LoadResourcesAsync(modDirectory, manifest);
                
                // 5. 创建模组实例
                var loadedMod = new LoadedMod
                {
                    Manifest = manifest,
                    Assembly = assembly,
                    Resources = resources,
                    RootPath = modDirectory
                };
                
                // 6. 实例化主模组行为类（不是对象行为）
                if (!string.IsNullOrEmpty(manifest.mainClass) && assembly != null)
                {
                    var mainType = assembly.GetType(manifest.mainClass);
                    if (mainType != null && typeof(IModBehaviour).IsAssignableFrom(mainType))
                    {
                        var behaviour = Activator.CreateInstance(mainType) as IModBehaviour;
                        loadedMod.Behaviours.Add(behaviour);
                    }
                }
                
                loadedMods[manifest.id] = loadedMod;
                logger.Log($"Mod loaded: {manifest.name} v{manifest.version}");
                
                return loadedMod;
            }
            catch (Exception ex)
            {
                logger.LogError($"Failed to load mod from {modDirectory}: {ex.Message}");
                throw;
            }
        }
        
        private async Task<ModResources> LoadResourcesAsync(string modDirectory, ModManifest manifest)
        {
            var resources = new ModResources();
            
            // 加载对象定义
            var objectsDir = Path.Combine(modDirectory, "Objects");
            if (Directory.Exists(objectsDir))
            {
                foreach (var objectFile in Directory.GetFiles(objectsDir, "*.json"))
                {
                    try
                    {
                        var objectJson = await File.ReadAllTextAsync(objectFile);
                        var objectDef = JsonConvert.DeserializeObject<ObjectDefinition>(objectJson);
                        resources.ObjectDefinitions[Path.GetFileName(objectFile)] = objectDef;
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Failed to load object definition {objectFile}: {ex.Message}");
                    }
                }
            }
            
            // 加载配置文件
            var configDir = Path.Combine(modDirectory, "Config");
            if (Directory.Exists(configDir))
            {
                foreach (var configFile in Directory.GetFiles(configDir, "*.json"))
                {
                    try
                    {
                        var configData = await File.ReadAllTextAsync(configFile);
                        resources.Configs[Path.GetFileName(configFile)] = configData;
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Failed to load config {configFile}: {ex.Message}");
                    }
                }
            }
            
            // 记录资源路径（不实际加载）
            resources.ModelPaths = GetResourcePaths(modDirectory, "Models", "*.gltf", "*.glb");
            resources.TexturePaths = GetResourcePaths(modDirectory, "Resources/Textures", "*.png", "*.jpg");
            resources.AudioPaths = GetResourcePaths(modDirectory, "Resources/Audio", "*.wav", "*.mp3");
            
            return resources;
        }
        
        private Dictionary<string, string> GetResourcePaths(string baseDir, string subDir, params string[] patterns)
        {
            var paths = new Dictionary<string, string>();
            var dir = Path.Combine(baseDir, subDir);
            
            if (Directory.Exists(dir))
            {
                foreach (var pattern in patterns)
                {
                    foreach (var file in Directory.GetFiles(dir, pattern))
                    {
                        paths[Path.GetFileName(file)] = file;
                    }
                }
            }
            
            return paths;
        }
        
        public void UnloadMod(string modId)
        {
            if (loadedMods.TryGetValue(modId, out var mod))
            {
                // 销毁所有行为
                foreach (var behaviour in mod.Behaviours)
                {
                    try
                    {
                        behaviour.OnDestroy();
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Error destroying behaviour: {ex.Message}");
                    }
                }
                
                // 清理临时文件
                if (mod.IsTemporary && Directory.Exists(mod.RootPath))
                {
                    try
                    {
                        Directory.Delete(mod.RootPath, true);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Failed to delete temporary files: {ex.Message}");
                    }
                }
                
                loadedMods.Remove(modId);
                logger.Log($"Mod {modId} unloaded");
            }
        }
    }
}
```

#### 5. ObjectFactory（对象工厂系统）🟢

```csharp
// ModSystem.Core/Runtime/ObjectFactory.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    /// <summary>
    /// 对象定义，替代Unity的Prefab系统
    /// </summary>
    [Serializable]
    public class ObjectDefinition
    {
        public string objectId { get; set; }
        public string name { get; set; }
        public List<ComponentDefinition> components { get; set; }
    }
    
    [Serializable]
    public class ComponentDefinition
    {
        public string type { get; set; }
        public Dictionary<string, object> properties { get; set; }
        
        public T GetProperty<T>(string key, T defaultValue = default)
        {
            if (properties != null && properties.TryGetValue(key, out var value))
            {
                try
                {
                    if (value is Newtonsoft.Json.Linq.JArray jArray && typeof(T).IsArray)
                    {
                        var elementType = typeof(T).GetElementType();
                        var array = jArray.ToObject(typeof(T));
                        return (T)array;
                    }
                    
                    return (T)Convert.ChangeType(value, typeof(T));
                }
                catch
                {
                    return defaultValue;
                }
            }
            return defaultValue;
        }
    }
    
    /// <summary>
    /// 平台无关的对象工厂接口
    /// </summary>
    public interface IObjectFactory
    {
        Task<IGameObject> CreateObjectAsync(string definitionPath);
        Task<IGameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition);
    }
    
    /// <summary>
    /// 抽象对象工厂基类
    /// </summary>
    public abstract class ObjectFactoryBase : IObjectFactory
    {
        protected readonly Dictionary<string, ObjectDefinition> definitionCache;
        protected readonly string basePath;
        protected readonly ILogger logger;
        
        protected ObjectFactoryBase(string basePath, ILogger logger)
        {
            this.basePath = basePath;
            this.logger = logger;
            definitionCache = new Dictionary<string, ObjectDefinition>();
        }
        
        public async Task<IGameObject> CreateObjectAsync(string definitionPath)
        {
            ObjectDefinition definition;
            
            if (definitionCache.ContainsKey(definitionPath))
            {
                definition = definitionCache[definitionPath];
            }
            else
            {
                var json = await LoadJsonAsync(definitionPath);
                definition = JsonConvert.DeserializeObject<ObjectDefinition>(json);
                definitionCache[definitionPath] = definition;
            }
            
            return await CreateObjectFromDefinitionAsync(definition);
        }
        
        public abstract Task<IGameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition);
        
        protected virtual async Task<string> LoadJsonAsync(string path)
        {
            var fullPath = System.IO.Path.Combine(basePath, path);
            return await System.IO.File.ReadAllTextAsync(fullPath);
        }
        
        /// <summary>
        /// 配置对象行为（而不是模组行为）
        /// </summary>
        protected virtual void ConfigureObjectBehaviour(IGameObject obj, ComponentDefinition compDef)
        {
            var behaviourClass = compDef.GetProperty<string>("behaviourClass");
            if (string.IsNullOrEmpty(behaviourClass))
            {
                logger.LogError("ObjectBehaviour requires behaviourClass property");
                return;
            }
            
            var behaviourType = Type.GetType(behaviourClass);
            if (behaviourType != null && typeof(IObjectBehaviour).IsAssignableFrom(behaviourType))
            {
                var behaviour = Activator.CreateInstance(behaviourType) as IObjectBehaviour;
                
                // 附加到对象
                behaviour.OnAttach(obj);
                
                // 配置行为
                var config = compDef.GetProperty<Dictionary<string, object>>("config");
                if (config != null)
                {
                    behaviour.OnConfigure(config);
                }
                
                // 存储引用以便后续清理
                obj.AddComponent<ObjectBehaviourComponent>().Behaviour = behaviour;
            }
            else
            {
                logger.LogError($"Could not find or instantiate behaviour class: {behaviourClass}");
            }
        }
    }
    
    /// <summary>
    /// 用于存储对象行为引用的组件
    /// </summary>
    public class ObjectBehaviourComponent
    {
        public IObjectBehaviour Behaviour { get; set; }
    }
}
```

### 通信系统

#### 1. 事件总线实现 🟢

```csharp
// ModSystem.Core/EventSystem/ModEventBus.cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace ModSystem.Core
{
    public interface IEventLogger
    {
        void LogEvent(IModEvent e);
        void LogSubscription(string eventType, string subscriber);
        void LogError(string message);
    }
    
    public class ModEventBus : IEventBus
    {
        private readonly Dictionary<Type, List<EventHandler>> handlers;
        private readonly object lockObject = new object();
        private readonly IEventLogger logger;
        
        public event Action<IModEvent> OnEventPublished;
        
        private class EventHandler
        {
            public Delegate Handler { get; set; }
            public Predicate<IModEvent> Filter { get; set; }
            public string SubscriberId { get; set; }
            public WeakReference TargetRef { get; set; }
        }
        
        public ModEventBus(IEventLogger logger = null)
        {
            handlers = new Dictionary<Type, List<EventHandler>>();
            this.logger = logger;
        }
        
        public void Subscribe<T>(Action<T> handler) where T : IModEvent
        {
            Subscribe(handler, null);
        }
        
        public void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                {
                    handlers[eventType] = new List<EventHandler>();
                }
                
                handlers[eventType].Add(new EventHandler
                {
                    Handler = handler,
                    Filter = filter != null ? e => filter((T)e) : null,
                    SubscriberId = handler.Target?.GetType().Name ?? "Anonymous",
                    TargetRef = handler.Target != null ? new WeakReference(handler.Target) : null
                });
                
                logger?.LogSubscription(eventType.Name, handler.Target?.GetType().Name);
            }
        }
        
        public void Publish<T>(T eventData) where T : IModEvent
        {
            if (eventData == null) return;
            
            eventData.Timestamp = DateTime.Now;
            logger?.LogEvent(eventData);
            OnEventPublished?.Invoke(eventData);
            
            List<EventHandler> eventHandlers;
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                // 清理已释放的处理器
                handlers[eventType].RemoveAll(h => 
                    h.TargetRef != null && !h.TargetRef.IsAlive);
                
                eventHandlers = handlers[eventType].ToList();
            }
            
            foreach (var handler in eventHandlers)
            {
                try
                {
                    if (handler.Filter != null && !handler.Filter(eventData))
                        continue;
                    
                    ((Action<T>)handler.Handler)?.Invoke(eventData);
                }
                catch (Exception ex)
                {
                    logger?.LogError($"Handler error for {typeof(T).Name}: {ex.Message}");
                }
            }
        }
        
        public void Unsubscribe<T>(Action<T> handler) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                handlers[eventType].RemoveAll(h => h.Handler.Equals(handler));
                
                if (handlers[eventType].Count == 0)
                    handlers.Remove(eventType);
            }
        }
        
        public void UnsubscribeAll(object subscriber)
        {
            lock (lockObject)
            {
                foreach (var handlerList in handlers.Values)
                {
                    handlerList.RemoveAll(h => 
                        h.TargetRef != null && 
                        h.TargetRef.IsAlive && 
                        h.TargetRef.Target == subscriber);
                }
                
                // 清理空列表
                var emptyKeys = handlers.Where(kvp => kvp.Value.Count == 0)
                    .Select(kvp => kvp.Key).ToList();
                foreach (var key in emptyKeys)
                {
                    handlers.Remove(key);
                }
            }
        }
    }
}
```

### 模板示例 🟡

#### 按钮模组模板

```json
// Templates/BuiltIn/ButtonMod/template.json
{
  "id": "button_mod_template",
  "name": "按钮模组模板",
  "description": "创建一个可交互的按钮模组",
  "version": "1.0.0",
  "variables": [
    {
      "name": "ButtonType",
      "description": "按钮类型 (toggle/momentary/hold)",
      "type": "string",
      "defaultValue": "toggle",
      "required": false
    }
  ],
  "files": [
    {
      "template": "Source/ButtonBehaviour.cs.template",
      "output": "Source/{{PascalCase ModId}}Behaviour.cs"
    },
    {
      "template": "Config/config.json.template",
      "output": "Config/config.json"
    },
    {
      "template": "Objects/button.json.template",
      "output": "Objects/{{ModId}}_button.json"
    },
    {
      "template": "manifest.json.template",
      "output": "manifest.json"
    },
    {
      "template": "README.md.template",
      "output": "README.md"
    },
    {
      "template": "ModProject.csproj.template",
      "output": "{{PascalCase ModId}}.csproj"
    }
  ],
  "directories": [
    "Models",
    "Resources/Textures",
    "Resources/Audio"
  ]
}
```

#### 按钮行为模板文件

```csharp
// Templates/BuiltIn/ButtonMod/Source/ButtonBehaviour.cs.template
using System;
using System.Collections.Generic;
using ModSystem.Core;

namespace {{PascalCase ModId}}
{
    public class {{PascalCase ModId}}Behaviour : IModBehaviour
    {
        public string BehaviourId => "{{ModId}}_behaviour";
        public string Version => "1.0.0";
        
        private IModContext context;
        private ButtonConfiguration config;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            config = LoadConfiguration();
            
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            context.Log($"{{ModName}} initialized");
        }
        
        private void OnInteraction(InteractionEvent e)
        {
            if (e.TargetId != context.GameObject.Name)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {
                OnButtonClick();
            }
        }
        
        private void OnButtonClick()
        {
            var buttonEvent = new ButtonPressedEvent
            {
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                ButtonType = "{{ButtonType}}",
                Parameters = config.ActionParameters
            };
            
            context.EventBus.Publish(buttonEvent);
            context.Log($"Button {config.ButtonId} clicked");
        }
        
        public void OnUpdate(float deltaTime) { }
        
        public void OnDestroy() 
        {
            context.Log($"{{ModName}} destroyed");
        }
        
        private ButtonConfiguration LoadConfiguration()
        {
            // TODO: 从配置文件加载
            return new ButtonConfiguration
            {
                ButtonId = "{{ModId}}_btn_01",
                ButtonType = ButtonType.{{ButtonType}},
                ActionParameters = new Dictionary<string, object>()
            };
        }
    }
    
    public class ButtonConfiguration
    {
        public string ButtonId { get; set; }
        public ButtonType ButtonType { get; set; }
        public Dictionary<string, object> ActionParameters { get; set; }
    }
    
    public enum ButtonType
    {
        Toggle,
        Momentary,
        Hold
    }
    
    public class ButtonPressedEvent : IModEvent
    {
        public string EventId => "button_pressed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
}
```

### 开发流程示例

#### 1. 创建新模组

```bash
# 交互式创建
ModBuilder

# 选择模板并填写信息
# 1. 创建新模组项目
# 选择模板: 1 (按钮模组模板)
# 模组ID: my_smart_button
# 模组名称: 智能按钮
# 作者名称: John Doe
# 按钮类型: toggle
```

#### 2. 编辑模组代码

```csharp
// my_smart_button/Source/MySmartButtonBehaviour.cs
using ModSystem.Core;

namespace MySmartButton
{
    public class MySmartButtonBehaviour : IModBehaviour
    {
        // 自动生成的代码...
        
        // 添加自定义功能
        private void OnButtonClick()
        {
            // 添加智能逻辑
            if (IsSmartConditionMet())
            {
                PublishSmartEvent();
            }
            
            base.OnButtonClick();
        }
    }
}
```

#### 3. 构建和打包

```bash
# 构建模组
cd my_smart_button
ModBuilder build

# 打包为.modpack文件
ModBuilder package

# 输出: my_smart_button_v1.0.0.modpack
```

## 部署和安装

### Unity项目集成

#### 1. 设置Unity项目结构

```bash
UnityProject/
├── Assets/
│   └── ModSystem/
│       ├── Core/
│       │   └── Assemblies/
│       │       ├── ModSystem.Core.dll     # 从独立项目复制
│       │       └── Newtonsoft.Json.dll
│       ├── Unity/
│       │   ├── ModSystemController.cs
│       │   ├── ModManager.cs
│       │   └── UnityImplementations/
│       └── Editor/
│           └── ModSystemMenu.cs
└── StreamingAssets/
    ├── ModConfigs/
    ├── Mods/                              # 开发中的模组
    └── ModPackages/                       # 发布的模组包
```

#### 2. Unity编辑器菜单 🔵

```csharp
// ModSystem.Unity/Editor/ModSystemMenu.cs
using UnityEngine;
using UnityEditor;
using System.IO;

namespace ModSystem.Unity.Editor
{
    public class ModSystemMenu
    {
        [MenuItem("ModSystem/Setup Project")]
        public static void SetupProject()
        {
            Debug.Log("Setting up ModSystem...");
            
            // 创建必要的目录
            CreateDirectories();
            
            // 创建ModSystemController
            CreateModSystemController();
            
            // 创建层级
            CreateLayers();
            
            Debug.Log("ModSystem setup complete!");
        }
        
        [MenuItem("ModSystem/Import Core DLL")]
        public static void ImportCoreDLL()
        {
            var path = EditorUtility.OpenFilePanel("Select ModSystem.Core.dll", "", "dll");
            if (!string.IsNullOrEmpty(path))
            {
                var destPath = "Assets/ModSystem/Core/Assemblies/ModSystem.Core.dll";
                File.Copy(path, destPath, true);
                AssetDatabase.Refresh();
                Debug.Log("Core DLL imported successfully!");
            }
        }
        
        [MenuItem("ModSystem/Create Test Mod")]
        public static void CreateTestMod()
        {
            var modPath = Path.Combine(Application.streamingAssetsPath, "Mods/TestMod");
            Directory.CreateDirectory(modPath);
            
            // 创建基本结构
            Directory.CreateDirectory(Path.Combine(modPath, "Source"));
            Directory.CreateDirectory(Path.Combine(modPath, "Config"));
            Directory.CreateDirectory(Path.Combine(modPath, "Objects"));
            
            // 创建manifest.json
            var manifest = @"{
  ""id"": ""test_mod"",
  ""name"": ""Test Mod"",
  ""version"": ""1.0.0"",
  ""author"": ""Developer"",
  ""main_class"": ""TestMod.TestBehaviour"",
  ""permissions"": [""event_publish"", ""event_subscribe""]
}";
            File.WriteAllText(Path.Combine(modPath, "manifest.json"), manifest);
            
            AssetDatabase.Refresh();
            Debug.Log("Test mod created!");
        }
        
        [MenuItem("ModSystem/Open Event Monitor")]
        public static void OpenEventMonitor()
        {
            var monitor = GameObject.FindObjectOfType<Debug.EventMonitor>();
            if (monitor == null)
            {
                var go = new GameObject("EventMonitor");
                monitor = go.AddComponent<Debug.EventMonitor>();
            }
            
            Selection.activeGameObject = monitor.gameObject;
            Debug.Log("Event Monitor opened!");
        }
        
        private static void CreateDirectories()
        {
            var dirs = new[]
            {
                "Assets/ModSystem/Core/Assemblies",
                "Assets/ModSystem/Unity",
                "Assets/ModSystem/Unity/UnityImplementations",
                "Assets/ModSystem/Examples",
                "Assets/StreamingAssets/ModConfigs",
                "Assets/StreamingAssets/Mods",
                "Assets/StreamingAssets/ModPackages"
            };
            
            foreach (var dir in dirs)
            {
                Directory.CreateDirectory(dir);
            }
        }
        
        private static void CreateModSystemController()
        {
            var existing = GameObject.FindObjectOfType<ModSystemController>();
            if (existing == null)
            {
                var go = new GameObject("ModSystemController");
                go.AddComponent<ModSystemController>();
                Debug.Log("ModSystemController created!");
            }
        }
        
        private static void CreateLayers()
        {
            // 创建Interactable层
            CreateLayer("Interactable", 10);
            CreateLayer("ModObjects", 11);
        }
        
        private static void CreateLayer(string name, int layer)
        {
            var tagManager = new SerializedObject(
                AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]
            );
            var layers = tagManager.FindProperty("layers");
            
            if (layers.GetArrayElementAtIndex(layer).stringValue == "")
            {
                layers.GetArrayElementAtIndex(layer).stringValue = name;
                tagManager.ApplyModifiedProperties();
                Debug.Log($"Layer '{name}' created at index {layer}");
            }
        }
    }
}
```

### 模组安装方式

#### 1. 开发模式安装

```bash
# 将模组文件夹复制到StreamingAssets/Mods/
UnityProject/Assets/StreamingAssets/Mods/
├── ButtonMod/
│   ├── manifest.json
│   ├── Source/
│   └── Config/
└── RobotMod/
    ├── manifest.json
    ├── Source/
    └── Config/
```

#### 2. 发布模式安装

```bash
# 将.modpack文件复制到StreamingAssets/ModPackages/
UnityProject/Assets/StreamingAssets/ModPackages/
├── button_mod_v1.0.0.modpack
├── robot_mod_v2.0.0.modpack
└── sensor_mod_v1.5.0.modpack
```

#### 3. 运行时安装

```csharp
// 在游戏运行时安装模组
public class ModInstaller : MonoBehaviour
{
    public async void InstallModFromFile(string modpackPath)
    {
        try
        {
            var modManager = GetComponent<ModManager>();
            var success = await modManager.LoadModPackage(modpackPath);
            
            if (success)
            {
                Debug.Log($"Mod installed successfully from {modpackPath}");
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"Failed to install mod: {ex.Message}");
        }
    }
}
```

## 调试和优化

### 性能分析工具 🔵

```csharp
// ModSystem.Unity/Debug/ModPerformanceProfiler.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UnityEngine;

namespace ModSystem.Unity.Debug
{
    public class ModPerformanceProfiler : MonoBehaviour
    {
        private static ModPerformanceProfiler instance;
        private Dictionary<string, ProfileData> profileData = new Dictionary<string, ProfileData>();
        private Dictionary<string, Stopwatch> activeTimers = new Dictionary<string, Stopwatch>();
        
        public static ModPerformanceProfiler Instance
        {
            get
            {
                if (instance == null)
                {
                    var go = new GameObject("ModPerformanceProfiler");
                    instance = go.AddComponent<ModPerformanceProfiler>();
                    DontDestroyOnLoad(go);
                }
                return instance;
            }
        }
        
        public class ProfileData
        {
            public string Name { get; set; }
            public int CallCount { get; set; }
            public double TotalTime { get; set; }
            public double MinTime { get; set; } = double.MaxValue;
            public double MaxTime { get; set; } = double.MinValue;
            public double AverageTime => CallCount > 0 ? TotalTime / CallCount : 0;
            public double LastTime { get; set; }
            public Queue<double> RecentTimes { get; set; } = new Queue<double>();
        }
        
        public void BeginSample(string name)
        {
            if (!profileData.ContainsKey(name))
            {
                profileData[name] = new ProfileData { Name = name };
            }
            
            var sw = Stopwatch.StartNew();
            activeTimers[name] = sw;
        }
        
        public void EndSample(string name)
        {
            if (activeTimers.TryGetValue(name, out var sw))
            {
                sw.Stop();
                var elapsed = sw.Elapsed.TotalMilliseconds;
                
                var data = profileData[name];
                data.CallCount++;
                data.TotalTime += elapsed;
                data.LastTime = elapsed;
                data.MinTime = Math.Min(data.MinTime, elapsed);
                data.MaxTime = Math.Max(data.MaxTime, elapsed);
                
                // 保留最近100次的时间
                data.RecentTimes.Enqueue(elapsed);
                if (data.RecentTimes.Count > 100)
                    data.RecentTimes.Dequeue();
                
                activeTimers.Remove(name);
            }
        }
        
        public ProfileScope BeginScope(string name)
        {
            return new ProfileScope(this, name);
        }
        
        public class ProfileScope : IDisposable
        {
            private readonly ModPerformanceProfiler profiler;
            private readonly string name;
            
            public ProfileScope(ModPerformanceProfiler profiler, string name)
            {
                this.profiler = profiler;
                this.name = name;
                profiler.BeginSample(name);
            }
            
            public void Dispose()
            {
                profiler.EndSample(name);
            }
        }
        
        // GUI显示
        private bool showWindow = false;
        private Vector2 scrollPosition;
        private SortMode sortMode = SortMode.TotalTime;
        private string filterText = "";
        
        private enum SortMode
        {
            Name,
            CallCount,
            TotalTime,
            AverageTime,
            LastTime
        }
        
        void Update()
        {
            if (Input.GetKeyDown(KeyCode.F10))
            {
                showWindow = !showWindow;
            }
        }
        
        void OnGUI()
        {
            if (!showWindow) return;
            
            var rect = new Rect(10, 10, 800, 600);
            GUI.Window(1, rect, DrawProfilerWindow, "Mod Performance Profiler");
        }
        
        void DrawProfilerWindow(int windowId)
        {
            GUILayout.BeginVertical();
            
            // 工具栏
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Button("Clear", GUILayout.Width(60)))
            {
                profileData.Clear();
                activeTimers.Clear();
            }
            
            if (GUILayout.Button("Export", GUILayout.Width(60)))
            {
                ExportReport();
            }
            
            GUILayout.Space(20);
            
            GUILayout.Label("Filter:", GUILayout.Width(50));
            filterText = GUILayout.TextField(filterText, GUILayout.Width(200));
            
            GUILayout.FlexibleSpace();
            
            GUILayout.Label($"Samples: {profileData.Count}");
            
            GUILayout.EndHorizontal();
            
            // 排序按钮
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Toggle(sortMode == SortMode.Name, "Name", "Button"))
                sortMode = SortMode.Name;
            
            if (GUILayout.Toggle(sortMode == SortMode.CallCount, "Calls", "Button"))
                sortMode = SortMode.CallCount;
            
            if (GUILayout.Toggle(sortMode == SortMode.TotalTime, "Total (ms)", "Button"))
                sortMode = SortMode.TotalTime;
            
            if (GUILayout.Toggle(sortMode == SortMode.AverageTime, "Avg (ms)", "Button"))
                sortMode = SortMode.AverageTime;
            
            if (GUILayout.Toggle(sortMode == SortMode.LastTime, "Last (ms)", "Button"))
                sortMode = SortMode.LastTime;
            
            GUILayout.EndHorizontal();
            
            // 数据列表
            scrollPosition = GUILayout.BeginScrollView(scrollPosition);
            
            var sortedData = GetSortedData();
            
            foreach (var data in sortedData)
            {
                DrawProfileEntry(data);
            }
            
            GUILayout.EndScrollView();
            
            // 统计信息
            DrawStatistics();
            
            GUILayout.EndVertical();
            
            GUI.DragWindow();
        }
        
        private IEnumerable<ProfileData> GetSortedData()
        {
            var filtered = profileData.Values.AsEnumerable();
            
            if (!string.IsNullOrEmpty(filterText))
            {
                filtered = filtered.Where(d => d.Name.ToLower().Contains(filterText.ToLower()));
            }
            
            return sortMode switch
            {
                SortMode.Name => filtered.OrderBy(d => d.Name),
                SortMode.CallCount => filtered.OrderByDescending(d => d.CallCount),
                SortMode.TotalTime => filtered.OrderByDescending(d => d.TotalTime),
                SortMode.AverageTime => filtered.OrderByDescending(d => d.AverageTime),
                SortMode.LastTime => filtered.OrderByDescending(d => d.LastTime),
                _ => filtered
            };
        }
        
        private void DrawProfileEntry(ProfileData data)
        {
            GUILayout.BeginHorizontal("box");
            
            // 性能指示器颜色
            var avgTime = data.AverageTime;
            GUI.color = avgTime > 16 ? Color.red :
                       avgTime > 8 ? Color.yellow :
                       Color.green;
            
            GUILayout.Label("●", GUILayout.Width(20));
            GUI.color = Color.white;
            
            GUILayout.Label(data.Name, GUILayout.Width(300));
            GUILayout.Label(data.CallCount.ToString(), GUILayout.Width(60));
            GUILayout.Label($"{data.TotalTime:F2}", GUILayout.Width(80));
            GUILayout.Label($"{data.AverageTime:F2}", GUILayout.Width(80));
            GUILayout.Label($"{data.MinTime:F2}", GUILayout.Width(60));
            GUILayout.Label($"{data.MaxTime:F2}", GUILayout.Width(60));
            GUILayout.Label($"{data.LastTime:F2}", GUILayout.Width(60));
            
            // 迷你图
            if (data.RecentTimes.Count > 0)
            {
                DrawMiniGraph(data.RecentTimes.ToArray(), 100, 20);
            }
            
            GUILayout.EndHorizontal();
        }
        
        private void DrawMiniGraph(double[] values, float width, float height)
        {
            var rect = GUILayoutUtility.GetRect(width, height);
            
            if (values.Length < 2) return;
            
            var max = values.Max();
            var min = values.Min();
            var range = max - min;
            
            if (range < 0.001) range = 1;
            
            var points = new Vector3[values.Length];
            for (int i = 0; i < values.Length; i++)
            {
                var x = rect.x + (i / (float)(values.Length - 1)) * rect.width;
                var y = rect.y + rect.height - ((float)((values[i] - min) / range)) * rect.height;
                points[i] = new Vector3(x, y, 0);
            }
            
            // 简单的线条绘制
            Handles.color = Color.cyan;
            Handles.DrawAAPolyLine(2f, points);
        }
        
        private void DrawStatistics()
        {
            GUILayout.BeginHorizontal("box");
            
            var totalTime = profileData.Values.Sum(d => d.TotalTime);
            var totalCalls = profileData.Values.Sum(d => d.CallCount);
            
            GUILayout.Label($"Total Time: {totalTime:F2} ms");
            GUILayout.Label($"Total Calls: {totalCalls}");
            GUILayout.Label($"Active Timers: {activeTimers.Count}");
            
            GUILayout.EndHorizontal();
        }
        
        private void ExportReport()
        {
            var report = "Mod Performance Report\n";
            report += $"Generated: {DateTime.Now}\n\n";
            report += "Name\tCalls\tTotal(ms)\tAvg(ms)\tMin(ms)\tMax(ms)\n";
            
            foreach (var data in GetSortedData())
            {
                report += $"{data.Name}\t{data.CallCount}\t{data.TotalTime:F2}\t";
                report += $"{data.AverageTime:F2}\t{data.MinTime:F2}\t{data.MaxTime:F2}\n";
            }
            
            var path = Path.Combine(Application.persistentDataPath, 
                $"ModPerformance_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            
            File.WriteAllText(path, report);
            UnityEngine.Debug.Log($"Performance report exported to: {path}");
        }
    }
    
    // 使用示例
    public static class ProfilerExtensions
    {
        public static void ProfileMethod(this IModBehaviour behaviour, string methodName, Action action)
        {
            using (ModPerformanceProfiler.Instance.BeginScope($"{behaviour.BehaviourId}.{methodName}"))
            {
                action();
            }
        }
        
        public static async Task ProfileMethodAsync(this IModBehaviour behaviour, string methodName, Func<Task> action)
        {
            using (ModPerformanceProfiler.Instance.BeginScope($"{behaviour.BehaviourId}.{methodName}"))
            {
                await action();
            }
        }
    }
}
```

### 内存监控 🔵

```csharp
// ModSystem.Unity/Debug/ModMemoryMonitor.cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Profiling;

namespace ModSystem.Unity.Debug
{
    public class ModMemoryMonitor : MonoBehaviour
    {
        private Dictionary<string, MemoryStats> modMemoryStats = new Dictionary<string, MemoryStats>();
        private float updateInterval = 1f;
        private float lastUpdateTime;
        
        public class MemoryStats
        {
            public long TotalAllocated { get; set; }
            public long CurrentUsage { get; set; }
            public int ObjectCount { get; set; }
            public int TextureMemory { get; set; }
            public int MeshMemory { get; set; }
            public List<float> UsageHistory { get; set; } = new List<float>();
        }
        
        void Start()
        {
            InvokeRepeating(nameof(UpdateMemoryStats), 1f, updateInterval);
        }
        
        void UpdateMemoryStats()
        {
            var modManager = FindObjectOfType<ModManager>();
            if (modManager == null) return;
            
            foreach (var modInstance in modManager.GetLoadedMods())
            {
                var stats = GetOrCreateStats(modInstance.ModId);
                
                // 更新对象计数
                stats.ObjectCount = modInstance.GameObjects.Count;
                
                // 计算纹理内存
                stats.TextureMemory = CalculateTextureMemory(modInstance);
                
                // 计算网格内存
                stats.MeshMemory = CalculateMeshMemory(modInstance);
                
                // 更新使用历史
                stats.UsageHistory.Add(stats.CurrentUsage / 1024f / 1024f); // MB
                if (stats.UsageHistory.Count > 60) // 保留60秒历史
                    stats.UsageHistory.RemoveAt(0);
            }
        }
        
        private MemoryStats GetOrCreateStats(string modId)
        {
            if (!modMemoryStats.ContainsKey(modId))
            {
                modMemoryStats[modId] = new MemoryStats();
            }
            return modMemoryStats[modId];
        }
        
        private int CalculateTextureMemory(ModUnityInstance instance)
        {
            int totalMemory = 0;
            
            foreach (var obj in instance.GameObjects)
            {
                if (obj == null) continue;
                
                var renderers = obj.GetComponentsInChildren<Renderer>();
                foreach (var renderer in renderers)
                {
                    if (renderer.sharedMaterial != null && renderer.sharedMaterial.mainTexture != null)
                    {
                        totalMemory += Profiler.GetRuntimeMemorySizeLong(renderer.sharedMaterial.mainTexture);
                    }
                }
            }
            
            return totalMemory;
        }
        
        private int CalculateMeshMemory(ModUnityInstance instance)
        {
            int totalMemory = 0;
            
            foreach (var obj in instance.GameObjects)
            {
                if (obj == null) continue;
                
                var meshFilters = obj.GetComponentsInChildren<MeshFilter>();
                foreach (var meshFilter in meshFilters)
                {
                    if (meshFilter.sharedMesh != null)
                    {
                        totalMemory += Profiler.GetRuntimeMemorySizeLong(meshFilter.sharedMesh);
                    }
                }
            }
            
            return totalMemory;
        }
        
        // GUI显示
        void OnGUI()
        {
            if (!Input.GetKey(KeyCode.LeftShift)) return;
            
            var rect = new Rect(Screen.width - 310, 10, 300, 400);
            GUI.Box(rect, "Mod Memory Usage");
            
            GUILayout.BeginArea(new Rect(rect.x + 10, rect.y + 30, rect.width - 20, rect.height - 40));
            
            foreach (var kvp in modMemoryStats)
            {
                DrawModMemoryInfo(kvp.Key, kvp.Value);
            }
            
            GUILayout.EndArea();
        }
        
        private void DrawModMemoryInfo(string modId, MemoryStats stats)
        {
            GUILayout.BeginVertical("box");
            
            GUILayout.Label($"<b>{modId}</b>", GetRichTextStyle());
            GUILayout.Label($"Objects: {stats.ObjectCount}");
            GUILayout.Label($"Textures: {stats.TextureMemory / 1024 / 1024:F2} MB");
            GUILayout.Label($"Meshes: {stats.MeshMemory / 1024 / 1024:F2} MB");
            
            // 绘制内存使用趋势
            if (stats.UsageHistory.Count > 1)
            {
                DrawMemoryGraph(stats.UsageHistory, 280, 50);
            }
            
            GUILayout.EndVertical();
        }
        
        private void DrawMemoryGraph(List<float> values, float width, float height)
        {
            // 简化的内存使用图表绘制
            var rect = GUILayoutUtility.GetRect(width, height);
            GUI.Box(rect, "");
            
            if (values.Count < 2) return;
            
            var max = Mathf.Max(values.ToArray());
            if (max < 0.1f) max = 0.1f;
            
            for (int i = 1; i < values.Count; i++)
            {
                var x1 = rect.x + ((i - 1) / (float)(values.Count - 1)) * rect.width;
                var y1 = rect.y + rect.height - (values[i - 1] / max) * rect.height;
                
                var x2 = rect.x + (i / (float)(values.Count - 1)) * rect.width;
                var y2 = rect.y + rect.height - (values[i] / max) * rect.height;
                
                DrawLine(new Vector2(x1, y1), new Vector2(x2, y2), Color.green);
            }
        }
        
        private void DrawLine(Vector2 start, Vector2 end, Color color)
        {
            var originalColor = GUI.color;
            GUI.color = color;
            
            var angle = Mathf.Atan2(end.y - start.y, end.x - start.x) * 180f / Mathf.PI;
            var length = Vector2.Distance(start, end);
            
            GUIUtility.RotateAroundPivot(angle, start);
            GUI.DrawTexture(new Rect(start.x, start.y - 1, length, 2), Texture2D.whiteTexture);
            GUIUtility.RotateAroundPivot(-angle, start);
            
            GUI.color = originalColor;
        }
        
        private GUIStyle GetRichTextStyle()
        {
            var style = new GUIStyle(GUI.skin.label);
            style.richText = true;
            return style;
        }
    }
}
```

### 常见问题排查

#### 1. 模组加载失败

```csharp
// 诊断工具
public class ModDiagnostics
{
    public static void DiagnoseModLoadFailure(string modPath, ILogger logger)
    {
        logger.Log($"=== 模组加载诊断 ===");
        logger.Log($"模组路径: {modPath}");
        
        // 检查路径存在性
        if (!Directory.Exists(modPath))
        {
            logger.LogError("✗ 模组目录不存在");
            return;
        }
        logger.Log("✓ 模组目录存在");
        
        // 检查manifest.json
        var manifestPath = Path.Combine(modPath, "manifest.json");
        if (!File.Exists(manifestPath))
        {
            logger.LogError("✗ manifest.json 文件不存在");
            return;
        }
        logger.Log("✓ manifest.json 文件存在");
        
        // 验证JSON格式
        try
        {
            var json = File.ReadAllText(manifestPath);
            var manifest = JsonSerializer.Deserialize<ModManifest>(json);
            logger.Log("✓ manifest.json 格式正确");
            
            // 检查必要字段
            if (string.IsNullOrEmpty(manifest.id))
                logger.LogError("✗ 缺少模组ID");
            if (string.IsNullOrEmpty(manifest.name))
                logger.LogError("✗ 缺少模组名称");
            if (string.IsNullOrEmpty(manifest.version))
                logger.LogError("✗ 缺少版本号");
        }
        catch (Exception ex)
        {
            logger.LogError($"✗ manifest.json 解析失败: {ex.Message}");
        }
        
        // 检查DLL文件
        var dllPath = Path.Combine(modPath, "Assemblies", "*.dll");
        var dlls = Directory.GetFiles(Path.Combine(modPath, "Assemblies"), "*.dll");
        if (dlls.Length == 0)
        {
            logger.LogWarning("! 没有找到DLL文件");
        }
        else
        {
            logger.Log($"✓ 找到 {dlls.Length} 个DLL文件");
            foreach (var dll in dlls)
            {
                logger.Log($"  - {Path.GetFileName(dll)}");
            }
        }
        
        // 检查依赖
        // ... 更多诊断逻辑
    }
}
```

#### 2. 事件未接收

```csharp
// 事件调试助手
public static class EventDebugHelper
{
    public static void TraceEvent<T>(this IEventBus eventBus, string tag = "") where T : IModEvent
    {
        eventBus.Subscribe<T>(e =>
        {
            UnityEngine.Debug.Log($"[EventTrace{(string.IsNullOrEmpty(tag) ? "" : $"-{tag}")}] " +
                $"{typeof(T).Name} from {e.SenderId} at {e.Timestamp:HH:mm:ss.fff}");
        });
    }
    
    public static void LogSubscriptions(this ModEventBus eventBus)
    {
        var field = typeof(ModEventBus).GetField("handlers", 
            System.Reflection.BindingFlags.NonPublic | 
            System.Reflection.BindingFlags.Instance);
        
        if (field != null)
        {
            var handlers = field.GetValue(eventBus) as Dictionary<Type, object>;
            UnityEngine.Debug.Log("=== Current Event Subscriptions ===");
            foreach (var kvp in handlers)
            {
                UnityEngine.Debug.Log($"{kvp.Key.Name}: {(kvp.Value as IList)?.Count ?? 0} handlers");
            }
        }
    }
}
```

#### 3. 性能问题

```csharp
// 性能优化建议
public class PerformanceOptimizer
{
    public static void OptimizeModPerformance(IModBehaviour behaviour, IModContext context)
    {
        // 1. 事件节流
        var throttledPublish = CreateThrottledAction<IModEvent>(
            e => context.EventBus.Publish(e),
            TimeSpan.FromMilliseconds(100)
        );
        
        // 2. 对象池
        var objectPool = new ModObjectPool<GameObject>(
            () => new GameObject("PooledObject"),
            obj => obj.transform.position = Vector3.zero,
            maxSize: 50
        );
        
        // 3. 批处理
        var batchProcessor = new BatchEventProcessor(context.EventBus);
        
        // 4. LOD系统
        EnableLODSystem(behaviour, context);
    }
    
    private static Action<T> CreateThrottledAction<T>(Action<T> action, TimeSpan delay)
    {
        var lastCall = DateTime.MinValue;
        return arg =>
        {
            var now = DateTime.Now;
            if (now - lastCall >= delay)
            {
                action(arg);
                lastCall = now;
            }
        };
    }
    
    private static void EnableLODSystem(IModBehaviour behaviour, IModContext context)
    {
        // 基于距离的细节级别调整
        var camera = Camera.main;
        if (camera != null)
        {
            var distance = Vector3.Distance(
                camera.transform.position, 
                context.GameObject.Transform.Position
            );
            
            if (distance > 50)
            {
                // 降低更新频率
                behaviour.SetUpdateRate(0.1f); // 10 FPS
            }
            else if (distance > 20)
            {
                behaviour.SetUpdateRate(0.033f); // 30 FPS
            }
            else
            {
                behaviour.SetUpdateRate(0.016f); // 60 FPS
            }
        }
    }
}
```

## 最佳实践

### 1. 模组开发规范

#### 命名约定

```csharp
// ✓ 好的命名
namespace MyCompany.MyModName
{
    public class MyModBehaviour : IModBehaviour { }
    public class MyModButtonPressedEvent : IModEvent { }
    public interface IMyModService : IModService { }
}

// ✗ 避免的命名
namespace Mod1
{
    public class Behaviour : IModBehaviour { }  // 太通用
    public class Event1 : IModEvent { }         // 无意义
    public interface Service : IModService { }   // 太通用
}
```

#### 资源管理

```csharp
public class ResourceAwareModBehaviour : IModBehaviour
{
    private readonly List<IDisposable> disposables = new List<IDisposable>();
    private readonly List<Coroutine> coroutines = new List<Coroutine>();
    
    public void OnInitialize(IModContext context)
    {
        // 跟踪所有需要清理的资源
        var timer = new Timer(Callback, null, 1000, 1000);
        disposables.Add(timer);
        
        // 跟踪协程
        var coroutine = context.API.Utilities.StartCoroutine(UpdateCoroutine());
        coroutines.Add(coroutine);
    }
    
    public void OnDestroy()
    {
        // 清理所有资源
        foreach (var disposable in disposables)
        {
            disposable?.Dispose();
        }
        disposables.Clear();
        
        // 停止所有协程
        foreach (var coroutine in coroutines)
        {
            if (coroutine != null)
                context.API.Utilities.StopCoroutine(coroutine);
        }
        coroutines.Clear();
        
        // 取消所有事件订阅
        context.EventBus.UnsubscribeAll(this);
    }
}
```

#### 错误处理

```csharp
public class RobustModBehaviour : IModBehaviour
{
    private IModContext context;
    
    public void OnInitialize(IModContext context)
    {
        this.context = context;
        
        try
        {
            InitializeComponents();
        }
        catch (Exception ex)
        {
            context.LogError($"Failed to initialize components: {ex.Message}");
            // 进入安全模式
            EnterSafeMode();
        }
    }
    
    private void HandleEvent(ButtonPressedEvent e)
    {
        try
        {
            ProcessButtonPress(e);
        }
        catch (Exception ex)
        {
            context.LogError($"Error handling button press: {ex.Message}");
            
            // 发送错误事件
            context.EventBus.Publish(new ModErrorEvent
            {
                SenderId = BehaviourId,
                ErrorType = "EventHandlingError",
                Message = ex.Message,
                StackTrace = ex.StackTrace
            });
        }
    }
    
    private void EnterSafeMode()
    {
        context.Log("Entering safe mode due to initialization failure");
        // 禁用非关键功能
        // 只保留基本功能
    }
}
```

### 2. 通信模式选择指南

| 场景 | 推荐模式 | 示例代码 |
|------|----------|----------|
| 简单通知 | 事件模式 | `eventBus.Publish(new StatusChangedEvent())` |
| 需要确认 | 请求-响应 | `var response = await SendRequestAsync<Request, Response>()` |
| API调用 | 服务模式 | `service.ExecuteAction(parameters)` |
| 复杂流程 | 配置驱动 | 通过JSON配置定义行为 |

### 3. 性能优化技巧

#### 使用对象池

```csharp
public class PooledEffectSystem
{
    private readonly Dictionary<string, Queue<GameObject>> pools;
    private readonly Transform poolContainer;
    
    public GameObject GetEffect(string effectName)
    {
        if (!pools.ContainsKey(effectName))
        {
            pools[effectName] = new Queue<GameObject>();
        }
        
        var pool = pools[effectName];
        
        if (pool.Count > 0)
        {
            var effect = pool.Dequeue();
            effect.SetActive(true);
            return effect;
        }
        else
        {
            return CreateNewEffect(effectName);
        }
    }
    
    public void ReturnEffect(string effectName, GameObject effect)
    {
        effect.SetActive(false);
        effect.transform.SetParent(poolContainer);
        
        if (pools[effectName].Count < MaxPoolSize)
        {
            pools[effectName].Enqueue(effect);
        }
        else
        {
            GameObject.Destroy(effect);
        }
    }
}
```

#### 事件批处理

```csharp
public class BatchedEventPublisher
{
    private readonly IEventBus eventBus;
    private readonly Dictionary<Type, List<IModEvent>> pendingEvents;
    private float batchInterval = 0.1f;
    private float lastBatchTime;
    
    public void PublishBatched<T>(T eventData) where T : IModEvent
    {
        var type = typeof(T);
        if (!pendingEvents.ContainsKey(type))
        {
            pendingEvents[type] = new List<IModEvent>();
        }
        
        pendingEvents[type].Add(eventData);
    }
    
    public void ProcessBatches()
    {
        if (Time.time - lastBatchTime < batchInterval)
            return;
        
        foreach (var kvp in pendingEvents)
        {
            if (kvp.Value.Count > 0)
            {
                // 发送批量事件
                eventBus.Publish(new BatchedEvent
                {
                    EventType = kvp.Key.Name,
                    Events = kvp.Value.ToList()
                });
                
                kvp.Value.Clear();
            }
        }
        
        lastBatchTime = Time.time;
    }
}
```

### 4. 安全编码实践

```csharp
public class SecureModBehaviour : IModBehaviour
{
    private readonly HashSet<string> allowedCommands = new HashSet<string>
    {
        "move", "rotate", "scale", "activate", "deactivate"
    };
    
    public void ExecuteCommand(string command, Dictionary<string, object> parameters)
    {
        // 验证命令
        if (!allowedCommands.Contains(command.ToLower()))
        {
            context.LogError($"Unauthorized command: {command}");
            return;
        }
        
        // 验证参数
        if (!ValidateParameters(command, parameters))
        {
            context.LogError($"Invalid parameters for command: {command}");
            return;
        }
        
        // 检查权限
        if (!context.SecurityContext.HasPermission($"execute_{command}"))
        {
            context.LogError($"No permission to execute: {command}");
            return;
        }
        
        // 执行命令
        try
        {
            ExecuteSecureCommand(command, parameters);
        }
        catch (Exception ex)
        {
            context.LogError($"Command execution failed: {ex.Message}");
            LogSecurityEvent(command, parameters, ex);
        }
    }
    
    private bool ValidateParameters(string command, Dictionary<string, object> parameters)
    {
        // 实现参数验证逻辑
        switch (command)
        {
            case "move":
                return parameters.ContainsKey("position") && 
                       parameters["position"] is Vector3;
            case "rotate":
                return parameters.ContainsKey("rotation") && 
                       parameters["rotation"] is Quaternion;
            default:
                return true;
        }
    }
}
```

## 常见问题解答

### 开发相关

**Q: 我需要安装Unity来开发模组吗？**  
A: 不需要。使用ModSDK可以在Visual Studio中独立开发模组，只需要.NET SDK。

**Q: 支持哪些.NET版本？**  
A: 推荐使用.NET Standard 2.1，这与Unity 2021.3+兼容。

**Q: 可以使用第三方库吗？**  
A: 可以，但需要确保：
- 库兼容.NET Standard 2.1
- 不依赖Unity特定功能
- 包含在模组包中
- 不与安全策略冲突

**Q: 如何调试模组？**  
A: 有多种方式：
1. 使用Visual Studio附加到Unity进程
2. 使用内置的EventMonitor和性能分析器
3. 在模组代码中添加日志输出
4. 使用条件断点

### 架构相关

**Q: Core层和Unity层的区别是什么？**  
A: 
- **Core层**：平台无关的纯C#代码，可在任何.NET环境运行
- **Unity层**：依赖Unity API的代码，只能在Unity中运行

**Q: 为什么要分离IModBehaviour和IObjectBehaviour？**  
A: 
- **IModBehaviour**：主模组逻辑，由ModManager管理生命周期
- **IObjectBehaviour**：附加到游戏对象的行为，由ObjectFactory创建

**Q: 事件总线是线程安全的吗？**  
A: 是的，ModEventBus使用锁机制确保线程安全，但建议主要在主线程使用。

### 性能相关

**Q: 模组会影响游戏性能吗？**  
A: 会有影响，但可以通过以下方式最小化：
- 使用对象池
- 批处理事件
- 合理的更新频率
- LOD系统
- 资源限制

**Q: 如何处理大量事件？**  
A: 
- 使用事件过滤减少不必要的处理
- 批量处理相似事件
- 使用优先级队列
- 考虑使用专门的高性能消息系统

### 安全相关

**Q: 模组可以访问文件系统吗？**  
A: 默认不允许。需要在manifest中声明file_access权限，并且只能访问指定目录。

**Q: 如何防止恶意模组？**  
A: 系统提供多层保护：
- 代码签名验证
- 权限系统
- API黑名单
- 资源限制
- 沙箱执行环境

### 部署相关

**Q: .modpack文件是什么格式？**  
A: 是标准的ZIP文件，包含：
- manifest.json
- 编译的DLL文件
- 资源文件
- 配置文件

**Q: 模组可以自动更新吗？**  
A: 系统不提供自动更新，但可以：
- 检查版本号
- 下载新版本
- 提示用户手动更新

**Q: 支持模组依赖管理吗？**  
A: 是的，在manifest.json中声明依赖，系统会检查并按顺序加载。

## 总结

Unity模组通信系统v4提供了一个完整的模组化开发框架，具有以下特点：

### 核心优势

1. **真正的平台无关性**：Core层不依赖Unity，可用于任何.NET项目
2. **灵活的通信机制**：支持事件、请求-响应、服务、配置驱动等多种模式
3. **完整的工具链**：从开发到部署的全流程工具支持
4. **强大的调试能力**：内置事件监控、性能分析、内存监控工具
5. **安全可靠**：完善的权限系统和安全检查机制
6. **易于扩展**：模板系统支持自定义模组类型

### 适用场景

- 游戏模组系统
- 插件化应用架构
- 微服务风格的Unity应用
- 动态内容加载系统
- 可扩展的编辑器工具

### 后续发展

- 支持更多编程语言（通过.NET互操作）
- 可视化模组编辑器
- 云端模组仓库
- 热重载支持
- 性能优化和内存管理改进

通过本系统，开发者可以轻松创建、分发和管理模组，为Unity应用添加无限的扩展可能。

```csharp
// ModSystem.Core/Communication/RequestResponse.cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace ModSystem.Core
{
    public abstract class ModRequest : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; } = Guid.NewGuid().ToString();
    }
    
    public abstract class ModResponse : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; }
        public bool Success { get; set; }
        public string Message { get; set; }
        public object Result { get; set; }
    }
    
    public interface IRequestResponseManager
    {
        Task<TResponse> SendRequestAsync<TRequest, TResponse>(
            TRequest request, 
            TimeSpan? timeout = null) 
            where TRequest : ModRequest 
            where TResponse : ModResponse;
    }
    
    public class RequestResponseManager : IRequestResponseManager
    {
        private readonly IEventBus eventBus;
        private readonly Dictionary<string, PendingRequest> pendingRequests;
        private readonly Timer cleanupTimer;
        
        private class PendingRequest
        {
            public TaskCompletionSource<ModResponse> CompletionSource { get; set; }
            public Type ResponseType { get; set; }
            public DateTime CreatedAt { get; set; }
            public CancellationTokenSource CancellationTokenSource { get; set; }
        }
        
        public RequestResponseManager(IEventBus eventBus)
        {
            this.eventBus = eventBus;
            this.pendingRequests = new Dictionary<string, PendingRequest>();
            
            // 定期清理超时请求
            cleanupTimer = new Timer(CleanupTimeoutRequests, null, 
                TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        }
        
        public async Task<TResponse> SendRequestAsync<TRequest, TResponse>(
            TRequest request, 
            TimeSpan? timeout = null) 
            where TRequest : ModRequest 
            where TResponse : ModResponse
        {
            var actualTimeout = timeout ?? TimeSpan.FromSeconds(30);
            var cts = new CancellationTokenSource(actualTimeout);
            var tcs = new TaskCompletionSource<ModResponse>();
            
            // 注册取消回调
            cts.Token.Register(() =>
            {
                tcs.TrySetCanceled();
                CleanupRequest(request.RequestId);
            });
            
            pendingRequests[request.RequestId] = new PendingRequest
            {
                CompletionSource = tcs,
                ResponseType = typeof(TResponse),
                CreatedAt = DateTime.Now,
                CancellationTokenSource = cts
            };
            
            Action<TResponse> responseHandler = null;
            responseHandler = (response) =>
            {
                if (response.RequestId == request.RequestId)
                {
                    if (pendingRequests.TryGetValue(request.RequestId, out var pending))
                    {
                        pending.CompletionSource.TrySetResult(response);
                        CleanupRequest(request.RequestId);
                    }
                    eventBus.Unsubscribe(responseHandler);
                }
            };
            
            eventBus.Subscribe(responseHandler);
            eventBus.Publish(request);
            
            try
            {
                var result = await tcs.Task;
                return (TResponse)result;
            }
            catch (TaskCanceledException)
            {
                throw new TimeoutException($"Request {request.RequestId} timed out after {actualTimeout}");
            }
        }
        
        private void CleanupRequest(string requestId)
        {
            if (pendingRequests.TryGetValue(requestId, out var pending))
            {
                pending.CancellationTokenSource?.Dispose();
                pendingRequests.Remove(requestId);
            }
        }
        
        private void CleanupTimeoutRequests(object state)
        {
            var now = DateTime.Now;
            var timeoutRequests = pendingRequests
                .Where(kvp => (now - kvp.Value.CreatedAt) > TimeSpan.FromMinutes(5))
                .Select(kvp => kvp.Key)
                .ToList();
            
            foreach (var requestId in timeoutRequests)
            {
                if (pendingRequests.TryGetValue(requestId, out var pending))
                {
                    pending.CompletionSource.TrySetException(
                        new TimeoutException("Request timed out during cleanup")
                    );
                    CleanupRequest(requestId);
                }
            }
        }
        
        public void Dispose()
        {
            cleanupTimer?.Dispose();
            
            // 取消所有待处理请求
            foreach (var requestId in pendingRequests.Keys.ToList())
            {
                CleanupRequest(requestId);
            }
        }
    }
}
```

#### 3. 服务注册系统 🟢

```csharp
// ModSystem.Core/Services/ServiceRegistry.cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace ModSystem.Core
{
    public interface IModService
    {
        string ServiceId { get; }
        string ProviderId { get; }
        string Version { get; }
    }
    
    public interface IServiceRegistry
    {
        void RegisterService<T>(T service) where T : class, IModService;
        T GetService<T>() where T : class, IModService;
        T GetService<T>(string serviceId) where T : class, IModService;
        IEnumerable<T> GetServices<T>() where T : class, IModService;
        bool UnregisterService<T>(string serviceId) where T : class, IModService;
        bool IsServiceRegistered<T>() where T : class, IModService;
        bool IsServiceRegistered<T>(string serviceId) where T : class, IModService;
    }
    
    public class ModServiceRegistry : IServiceRegistry
    {
        private readonly Dictionary<Type, Dictionary<string, IModService>> services;
        private readonly IEventBus eventBus;
        private readonly ILogger logger;
        private readonly object lockObject = new object();
        
        public ModServiceRegistry(IEventBus eventBus, ILogger logger = null)
        {
            this.services = new Dictionary<Type, Dictionary<string, IModService>>();
            this.eventBus = eventBus;
            this.logger = logger;
        }
        
        public void RegisterService<T>(T service) where T : class, IModService
        {
            if (service == null)
                throw new ArgumentNullException(nameof(service));
            
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (!services.ContainsKey(serviceType))
                {
                    services[serviceType] = new Dictionary<string, IModService>();
                }
                
                if (services[serviceType].ContainsKey(service.ServiceId))
                {
                    logger?.LogWarning($"Service {service.ServiceId} is already registered, replacing...");
                }
                
                services[serviceType][service.ServiceId] = service;
            }
            
            eventBus?.Publish(new ServiceRegisteredEvent
            {
                ServiceType = serviceType.Name,
                ServiceId = service.ServiceId,
                ProviderId = service.ProviderId,
                Version = service.Version
            });
            
            logger?.Log($"Service registered: {serviceType.Name} - {service.ServiceId}");
        }
        
        public T GetService<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType) && services[serviceType].Count > 0)
                {
                    return services[serviceType].Values.First() as T;
                }
            }
            
            return null;
        }
        
        public T GetService<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType) && 
                    services[serviceType].TryGetValue(serviceId, out var service))
                {
                    return service as T;
                }
            }
            
            return null;
        }
        
        public IEnumerable<T> GetServices<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType))
                {
                    return services[serviceType].Values.Cast<T>().ToList();
                }
            }
            
            return Enumerable.Empty<T>();
        }
        
        public bool UnregisterService<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            IModService removedService = null;
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType) && 
                    services[serviceType].TryGetValue(serviceId, out removedService))
                {
                    services[serviceType].Remove(serviceId);
                    
                    if (services[serviceType].Count == 0)
                    {
                        services.Remove(serviceType);
                    }
                }
            }
            
            if (removedService != null)
            {
                eventBus?.Publish(new ServiceUnregisteredEvent
                {
                    ServiceType = serviceType.Name,
                    ServiceId = serviceId,
                    ProviderId = removedService.ProviderId
                });
                
                logger?.Log($"Service unregistered: {serviceType.Name} - {serviceId}");
                return true;
            }
            
            return false;
        }
        
        public bool IsServiceRegistered<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                return services.ContainsKey(serviceType) && services[serviceType].Count > 0;
            }
        }
        
        public bool IsServiceRegistered<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                return services.ContainsKey(serviceType) && 
                       services[serviceType].ContainsKey(serviceId);
            }
        }
    }
    
    public class ServiceRegisteredEvent : IModEvent
    {
        public string EventId => "service_registered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
        public string Version { get; set; }
    }
    
    public class ServiceUnregisteredEvent : IModEvent
    {
        public string EventId => "service_unregistered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
    }
}
```

#### 4. 配置驱动路由 🟢

```csharp
// ModSystem.Core/Communication/CommunicationRouter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Reflection;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    public class CommunicationConfig
    {
        public List<RouteConfig> Routes { get; set; } = new List<RouteConfig>();
        public List<WorkflowConfig> Workflows { get; set; } = new List<WorkflowConfig>();
        public RouterSettings Settings { get; set; } = new RouterSettings();
    }
    
    public class RouteConfig
    {
        public string Name { get; set; }
        public string SourceEvent { get; set; }
        public List<ConditionConfig> Conditions { get; set; } = new List<ConditionConfig>();
        public List<ActionConfig> Actions { get; set; } = new List<ActionConfig>();
        public bool Enabled { get; set; } = true;
        public int Priority { get; set; } = 0;
    }
    
    public class RouterSettings
    {
        public bool EnableDebugLogging { get; set; } = false;
        public int MaxConcurrentActions { get; set; } = 10;
        public int DefaultActionTimeout { get; set; } = 5000;
    }
    
    public class CommunicationRouter
    {
        private readonly IEventBus eventBus;
        private readonly ILogger logger;
        private readonly CommunicationConfig config;
        private readonly Dictionary<string, List<RouteConfig>> routeMap;
        private readonly Dictionary<Type, MethodInfo> subscribeMethodCache;
        private readonly SemaphoreSlim actionSemaphore;
        
        public CommunicationRouter(IEventBus eventBus, string configJson, ILogger logger = null)
        {
            this.eventBus = eventBus;
            this.logger = logger;
            this.config = JsonConvert.DeserializeObject<CommunicationConfig>(configJson);
            this.routeMap = BuildRouteMap();
            this.subscribeMethodCache = new Dictionary<Type, MethodInfo>();
            this.actionSemaphore = new SemaphoreSlim(config.Settings.MaxConcurrentActions);
            
            SubscribeToEvents();
        }
        
        private Dictionary<string, List<RouteConfig>> BuildRouteMap()
        {
            var map = new Dictionary<string, List<RouteConfig>>();
            
            foreach (var route in config.Routes.Where(r => r.Enabled))
            {
                if (!map.ContainsKey(route.SourceEvent))
                {
                    map[route.SourceEvent] = new List<RouteConfig>();
                }
                map[route.SourceEvent].Add(route);
            }
            
            // 按优先级排序
            foreach (var routes in map.Values)
            {
                routes.Sort((a, b) => b.Priority.CompareTo(a.Priority));
            }
            
            return map;
        }
        
        private void SubscribeToEvents()
        {
            foreach (var eventTypeName in routeMap.Keys)
            {
                try
                {
                    var eventType = GetTypeFromName(eventTypeName);
                    if (eventType == null)
                    {
                        logger?.LogError($"Event type not found: {eventTypeName}");
                        continue;
                    }
                    
                    var subscribeMethod = GetSubscribeMethod(eventType);
                    var handlerType = typeof(Action<>).MakeGenericType(eventType);
                    var handleMethod = GetType().GetMethod(nameof(HandleEvent), 
                        BindingFlags.NonPublic | BindingFlags.Instance);
                    var genericHandleMethod = handleMethod.MakeGenericMethod(eventType);
                    
                    var handler = Delegate.CreateDelegate(handlerType, this, genericHandleMethod);
                    
                    subscribeMethod.Invoke(eventBus, new[] { handler });
                    
                    logger?.Log($"Router subscribed to {eventTypeName}");
                }
                catch (Exception ex)
                {
                    logger?.LogError($"Failed to subscribe to {eventTypeName}: {ex.Message}");
                }
            }
        }
        
        private MethodInfo GetSubscribeMethod(Type eventType)
        {
            if (!subscribeMethodCache.TryGetValue(eventType, out var method))
            {
                method = eventBus.GetType()
                    .GetMethod("Subscribe")
                    .MakeGenericMethod(eventType);
                subscribeMethodCache[eventType] = method;
            }
            return method;
        }
        
        private Type GetTypeFromName(string typeName)
        {
            // 首先尝试在所有已加载的程序集中查找
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                var type = assembly.GetType(typeName);
                if (type != null) return type;
            }
            
            // 尝试Type.GetType（支持程序集限定名）
            return Type.GetType(typeName);
        }
        
        private async void HandleEvent<T>(T eventData) where T : IModEvent
        {
            var eventTypeName = typeof(T).FullName ?? typeof(T).Name;
            
            if (config.Settings.EnableDebugLogging)
            {
                logger?.Log($"Router handling event: {eventTypeName}");
            }
            
            if (routeMap.TryGetValue(eventTypeName, out var routes))
            {
                var tasks = new List<Task>();
                
                foreach (var route in routes)
                {
                    if (EvaluateConditions(route.Conditions, eventData))
                    {
                        tasks.Add(ExecuteActionsAsync(route, eventData));
                    }
                }
                
                if (tasks.Count > 0)
                {
                    try
                    {
                        await Task.WhenAll(tasks);
                    }
                    catch (Exception ex)
                    {
                        logger?.LogError($"Error executing route actions: {ex.Message}");
                    }
                }
            }
        }
        
        private bool EvaluateConditions<T>(List<ConditionConfig> conditions, T eventData)
        {
            if (conditions == null || conditions.Count == 0)
                return true;
            
            foreach (var condition in conditions)
            {
                var value = GetPropertyValue(eventData, condition.Property);
                
                if (!EvaluateCondition(value, condition.Operator, condition.Value))
                {
                    if (config.Settings.EnableDebugLogging)
                    {
                        logger?.Log($"Condition failed: {condition.Property} {condition.Operator} {condition.Value}");
                    }
                    return false;
                }
            }
            
            return true;
        }
        
        private async Task ExecuteActionsAsync<T>(RouteConfig route, T sourceEvent)
        {
            foreach (var action in route.Actions)
            {
                await actionSemaphore.WaitAsync();
                
                try
                {
                    if (action.Delay > 0)
                    {
                        await Task.Delay(action.Delay);
                    }
                    
                    var parameters = PrepareParameters(action.Parameters, sourceEvent);
                    var targetEvent = CreateEvent(action.EventType, parameters);
                    
                    if (targetEvent != null)
                    {
                        eventBus.Publish(targetEvent);
                        
                        if (config.Settings.EnableDebugLogging)
                        {
                            logger?.Log($"Route {route.Name} published {action.EventType}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    logger?.LogError($"Failed to execute action in route {route.Name}: {ex.Message}");
                }
                finally
                {
                    actionSemaphore.Release();
                }
            }
        }
    }
}
```

### 安全系统

#### SecurityManager（安全管理器）🟢

```csharp
// ModSystem.Core/Security/SecurityManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Reflection;

namespace ModSystem.Core
{
    public class SecurityManager
    {
        private readonly SecurityConfig config;
        private readonly ILogger logger;
        private readonly HashSet<string> whitelistedPaths;
        private readonly HashSet<string> blacklistedAPIs;
        
        public SecurityManager(SecurityConfig config, ILogger logger)
        {
            this.config = config;
            this.logger = logger;
            this.whitelistedPaths = new HashSet<string>();
            this.blacklistedAPIs = InitializeBlacklistedAPIs();
        }
        
        public bool ValidateMod(string modPath)
        {
            try
            {
                // 1. 检查路径安全性
                if (!IsPathSafe(modPath))
                {
                    logger.LogError($"Mod path is not safe: {modPath}");
                    return false;
                }
                
                // 2. 验证数字签名（如果启用）
                if (config.RequireSignedMods)
                {
                    if (!VerifySignature(modPath))
                    {
                        logger.LogError($"Mod signature verification failed: {modPath}");
                        return false;
                    }
                }
                
                // 3. 扫描恶意代码
                if (!ScanForMaliciousCode(modPath))
                {
                    logger.LogError($"Mod contains suspicious code: {modPath}");
                    return false;
                }
                
                // 4. 验证权限
                if (!ValidatePermissions(modPath))
                {
                    logger.LogError($"Mod requests unauthorized permissions: {modPath}");
                    return false;
                }
                
                logger.Log($"Mod validation passed: {modPath}");
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Security validation error: {ex.Message}");
                return false;
            }
        }
        
        private bool IsPathSafe(string path)
        {
            try
            {
                var fullPath = Path.GetFullPath(path);
                var allowedPaths = config.AllowedModPaths ?? new List<string> { config.ModDirectory };
                
                // 检查是否在允许的路径内
                bool isInAllowedPath = false;
                foreach (var allowedPath in allowedPaths)
                {
                    var fullAllowedPath = Path.GetFullPath(allowedPath);
                    if (fullPath.StartsWith(fullAllowedPath, StringComparison.OrdinalIgnoreCase))
                    {
                        isInAllowedPath = true;
                        break;
                    }
                }
                
                if (!isInAllowedPath)
                {
                    logger.LogError($"Path {fullPath} is not in allowed directories");
                    return false;
                }
                
                // 检查路径遍历攻击
                if (path.Contains("..") || path.Contains("~"))
                {
                    logger.LogError("Path contains traversal characters");
                    return false;
                }
                
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Path validation error: {ex.Message}");
                return false;
            }
        }
        
        private bool VerifySignature(string modPath)
        {
            var signaturePath = Path.Combine(modPath, "signature.sig");
            if (!File.Exists(signaturePath))
            {
                logger.LogWarning($"Signature file not found: {signaturePath}");
                return false;
            }
            
            try
            {
                using (var rsa = new RSACryptoServiceProvider())
                {
                    // 加载公钥
                    if (!File.Exists(config.PublicKeyPath))
                    {
                        logger.LogError("Public key file not found");
                        return false;
                    }
                    
                    var publicKey = File.ReadAllText(config.PublicKeyPath);
                    rsa.FromXmlString(publicKey);
                    
                    // 计算清单文件哈希
                    var manifestPath = Path.Combine(modPath, "manifest.json");
                    if (!File.Exists(manifestPath))
                    {
                        logger.LogError("Manifest file not found for signature verification");
                        return false;
                    }
                    
                    var manifestData = File.ReadAllBytes(manifestPath);
                    using (var sha256 = SHA256.Create())
                    {
                        var hash = sha256.ComputeHash(manifestData);
                        var signature = File.ReadAllBytes(signaturePath);
                        
                        return rsa.VerifyHash(hash, CryptoConfig.MapNameToOID("SHA256"), signature);
                    }
                }
            }
            catch (Exception ex)
            {
                logger.LogError($"Signature verification error: {ex.Message}");
                return false;
            }
        }
        
        private bool ScanForMaliciousCode(string modPath)
        {
            var dllFiles = Directory.GetFiles(modPath, "*.dll", SearchOption.AllDirectories);
            
            foreach (var dll in dllFiles)
            {
                if (!ScanAssembly(dll))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        private bool ScanAssembly(string assemblyPath)
        {
            try
            {
                // 使用ReflectionOnlyLoad避免执行代码
                var assemblyName = AssemblyName.GetAssemblyName(assemblyPath);
                var assembly = Assembly.ReflectionOnlyLoad(assemblyName.FullName);
                
                foreach (var type in assembly.GetTypes())
                {
                    // 检查危险的基类
                    if (IsDangerousType(type))
                    {
                        logger.LogError($"Dangerous type detected: {type.FullName}");
                        return false;
                    }
                    
                    // 检查方法调用
                    foreach (var method in type.GetMethods(
                        BindingFlags.Public | BindingFlags.NonPublic | 
                        BindingFlags.Instance | BindingFlags.Static))
                    {
                        if (IsDangerousMethod(method))
                        {
                            logger.LogError($"Dangerous method detected: {method.Name} in {type.FullName}");
                            return false;
                        }
                    }
                }
                
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Assembly scan error: {ex.Message}");
                return false;
            }
        }
        
        private bool IsDangerousType(Type type)
        {
            var dangerousTypes = new[]
            {
                "System.Diagnostics.Process",
                "System.IO.FileSystemWatcher",
                "System.Net.WebClient",
                "System.Net.Http.HttpClient",
                "Microsoft.Win32.Registry"
            };
            
            return dangerousTypes.Any(dt => 
                type.FullName == dt || 
                (type.BaseType != null && type.BaseType.FullName == dt));
        }
        
        private bool IsDangerousMethod(MethodInfo method)
        {
            var dangerousPatterns = new[]
            {
                "Process.Start",
                "File.Delete",
                "Directory.Delete",
                "Registry.",
                "Assembly.Load",
                "AppDomain.CreateDomain",
                "Marshal.GetDelegateForFunctionPointer"
            };
            
            var methodFullName = $"{method.DeclaringType?.Name}.{method.Name}";
            
            return dangerousPatterns.Any(pattern => 
                methodFullName.Contains(pattern));
        }
        
        private bool ValidatePermissions(string modPath)
        {
            var manifestPath = Path.Combine(modPath, "manifest.json");
            if (!File.Exists(manifestPath))
            {
                logger.LogError("Manifest file not found for permission validation");
                return false;
            }
            
            try
            {
                var manifestJson = File.ReadAllText(manifestPath);
                var manifest = JsonConvert.DeserializeObject<ModManifest>(manifestJson);
                
                if (manifest.permissions == null || manifest.permissions.Length == 0)
                {
                    return true; // 没有请求特殊权限
                }
                
                // 检查每个请求的权限
                foreach (var permission in manifest.permissions)
                {
                    if (!config.AllowedPermissions.Contains(permission))
                    {
                        logger.LogError($"Unauthorized permission requested: {permission}");
                        return false;
                    }
                }
                
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Permission validation error: {ex.Message}");
                return false;
            }
        }
        
        private HashSet<string> InitializeBlacklistedAPIs()
        {
            return new HashSet<string>
            {
                "System.IO.File.Delete",
                "System.IO.Directory.Delete",
                "System.Diagnostics.Process.Start",
                "System.Net.WebClient",
                "System.Net.Http.HttpClient",
                "System.Reflection.Assembly.Load",
                "System.Reflection.Assembly.LoadFrom",
                "System.Reflection.Assembly.LoadFile",
                "System.AppDomain.CreateDomain",
                "System.Runtime.InteropServices.Marshal",
                "Microsoft.Win32.Registry",
                "System.Security.Cryptography",
                "System.Threading.Thread.Abort",
                "System.Environment.Exit"
            };
        }
        
        public SecurityContext CreateContext(string modId, string[] requestedPermissions)
        {
            var grantedPermissions = new HashSet<string>();
            
            // 检查模组是否在信任列表中
            if (config.TrustedMods?.Contains(modId) == true)
            {
                // 信任的模组获得所有请求的权限
                grantedPermissions = new HashSet<string>(requestedPermissions);
            }
            else if (config.ModPermissions?.TryGetValue(modId, out var allowedPermissions) == true)
            {
                // 只授予配置中允许的权限
                foreach (var permission in requestedPermissions)
                {
                    if (allowedPermissions.Contains(permission))
                    {
                        grantedPermissions.Add(permission);
                    }
                }
            }
            else
            {
                // 使用默认权限集
                foreach (var permission in requestedPermissions)
                {
                    if (config.DefaultPermissions?.Contains(permission) == true)
                    {
                        grantedPermissions.Add(permission);
                    }
                }
            }
            
            var resourceLimits = config.ModResourceLimits?.GetValueOrDefault(modId) ?? 
                                config.ModResourceLimits?.GetValueOrDefault("default") ?? 
                                new ResourceLimits();
            
            return new SecurityContext
            {
                ModId = modId,
                Permissions = grantedPermissions,
                ResourceLimits = resourceLimits
            };
        }
    }
    
    public class SecurityContext
    {
        public string ModId { get; set; }
        public HashSet<string> Permissions { get; set; }
        public ResourceLimits ResourceLimits { get; set; }
        
        public bool HasPermission(string permission)
        {
            return Permissions?.Contains(permission) ?? false;
        }
    }
    
    public class SecurityConfig
    {
        public bool RequireSignedMods { get; set; } = true;
        public string PublicKeyPath { get; set; }
        public string ModDirectory { get; set; } = "Mods";
        public List<string> AllowedModPaths { get; set; }
        public HashSet<string> AllowedPermissions { get; set; } = new HashSet<string>
        {
            "event_publish",
            "event_subscribe", 
            "service_register",
            "object_create",
            "config_read",
            "audio_play",
            "ui_create"
        };
        public HashSet<string> DefaultPermissions { get; set; } = new HashSet<string>
        {
            "event_publish",
            "event_subscribe",
            "config_read"
        };
        public Dictionary<string, List<string>> ModPermissions { get; set; }
        public Dictionary<string, ResourceLimits> ModResourceLimits { get; set; }
        public List<string> TrustedMods { get; set; }
    }
    
    public class ResourceLimits
    {
        public int MaxMemoryMB { get; set; } = 100;
        public int MaxCpuTimeMs { get; set; } = 10;
        public int MaxObjects { get; set; } = 50;
        public int MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
        public int MaxEventRate { get; set; } = 100; // 每秒最多事件数
        public int MaxServiceCalls { get; set; } = 1000; // 每分钟最多服务调用
    }
}
```

## 通信模式详解

### 1. 事件模式（Event Pattern）

适用于单向通知、状态变化广播等场景。

```csharp
// 定义事件
public class ButtonPressedEvent : IModEvent
{
    public string EventId => "button_pressed";
    public string SenderId { get; set; }
    public DateTime Timestamp { get; set; }
    
    public string ButtonId { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
}

// 发布事件
context.EventBus.Publish(new ButtonPressedEvent 
{ 
    ButtonId = "btn_1",
    Parameters = new Dictionary<string, object> { ["action"] = "rotate" }
});

// 订阅事件
context.EventBus.Subscribe<ButtonPressedEvent>(e => 
{
    Console.WriteLine($"Button {e.ButtonId} was pressed");
});

// 带条件订阅
context.EventBus.Subscribe<ButtonPressedEvent>(
    e => HandleButtonPress(e),
    e => e.ButtonId == "btn_1" // 只处理特定按钮
);
```

### 2. 请求-响应模式（Request-Response Pattern）

适用于需要返回结果的操作、命令确认等场景。

```csharp
// 定义请求和响应
public class MoveRobotRequest : ModRequest
{
    public Vector3 TargetPosition { get; set; }
    public float Speed { get; set; }
}

public class MoveRobotResponse : ModResponse
{
    public float ActualDistance { get; set; }
    public float TimeTaken { get; set; }
}

// 发送请求
var response = await context.API.RequestResponse.SendRequestAsync<MoveRobotRequest, MoveRobotResponse>(
    new MoveRobotRequest 
    { 
        TargetPosition = new Vector3(1, 2, 3),
        Speed = 5.0f
    },
    TimeSpan.FromSeconds(10)
);

if (response.Success)
{
    Console.WriteLine($"Robot moved {response.ActualDistance} units in {response.TimeTaken} seconds");
}

// 处理请求
context.EventBus.Subscribe<MoveRobotRequest>(async request =>
{
    // 执行移动逻辑
    var result = await MoveRobot(request.TargetPosition, request.Speed);
    
    // 发送响应
    context.EventBus.Publish(new MoveRobotResponse
    {
        RequestId = request.RequestId,
        Success = result.Success,
        ActualDistance = result.Distance,
        TimeTaken = result.Time
    });
});
```

### 3. 服务模式（Service Pattern）

适用于模组间紧密协作、API式调用等场景。

```csharp
// 定义服务接口
public interface IRobotService : IModService
{
    Task<bool> MoveToPosition(Vector3 position);
    Task<RobotStatus> GetStatus();
    void EmergencyStop();
}

// 实现服务
public class RobotService : IRobotService
{
    public string ServiceId => "robot_service_01";
    public string ProviderId => "RobotMod";
    public string Version => "1.0.0";
    
    public async Task<bool> MoveToPosition(Vector3 position)
    {
        // 实现移动逻辑
        return true;
    }
    
    // 其他方法实现...
}

// 注册服务
context.Services.RegisterService<IRobotService>(new RobotService());

// 使用服务
var robotService = context.Services.GetService<IRobotService>();
if (robotService != null)
{
    await robotService.MoveToPosition(new Vector3(5, 0, 5));
}

// 等待服务可用
if (!context.Services.IsServiceRegistered<IRobotService>())
{
    context.EventBus.Subscribe<ServiceRegisteredEvent>(e =>
    {
        if (e.ServiceType == nameof(IRobotService))
        {
            // 服务现在可用
            var service = context.Services.GetService<IRobotService>();
            // 使用服务...
        }
    });
}
```

### 4. 配置驱动模式（Configuration-Driven Pattern）

通过JSON配置文件定义事件路由和行为。

```json
{
  "routes": [
    {
      "name": "button_to_robot_movement",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "move_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.MoveCommand",
          "parameters": {
            "direction": "forward",
            "distance": 1.0
          },
          "delay": 100
        }
      ]
    },
    {
      "name": "sensor_triggers_alarm",
      "sourceEvent": "SensorMod.ProximityEvent",
      "conditions": [
        {
          "property": "Distance",
          "operator": "<",
          "value": 0.5
        }
      ],
      "actions": [
        {
          "eventType": "AlarmMod.TriggerAlarm",
          "parameters": {
            "level": "warning",
            "message": "Object too close"
          }
        }
      ]
    }
  ],
  "settings": {
    "enableDebugLogging": true,
    "maxConcurrentActions": 5
  }
}
```

## 模组开发

### 创建简单的按钮模组 🟢

```csharp
// ButtonMod/ButtonBehaviour.cs
using System;
using System.Collections.Generic;
using ModSystem.Core;

namespace ButtonMod
{
    public class ButtonBehaviour : IModBehaviour
    {
        public string BehaviourId => "simple_button";
        public string Version => "1.0.0";
        
        private IModContext context;
        private ButtonConfig config;
        private float lastPressTime;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            
            // 加载配置
            config = LoadConfig();
            
            // 订阅交互事件
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            
            context.Log($"Button {config.ButtonId} initialized");
        }
        
        private void OnInteraction(InteractionEvent e)
        {
            // 检查是否是针对此按钮的交互
            if (e.TargetId != context.GameObject.Name)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {
                OnButtonClick();
            }
        }
        
        private void OnButtonClick()
        {
            // 检查冷却时间
            var currentTime = DateTime.Now.Ticks / TimeSpan.TicksPerSecond;
            if (currentTime - lastPressTime < config.CooldownTime)
                return;
            
            lastPressTime = currentTime;
            
            // 发布按钮事件
            context.EventBus.Publish(new ButtonPressedEvent
            {
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                ButtonType = config.ButtonType,
                Parameters = config.ActionParameters
            });
            
            context.Log($"Button {config.ButtonId} clicked");
        }
        
        public void OnUpdate(float deltaTime)
        {
            // 按钮通常不需要每帧更新
        }
        
        public void OnDestroy()
        {
            context.Log($"Button {config.ButtonId} destroyed");
        }
        
        private ButtonConfig LoadConfig()
        {
            // 从配置文件加载或使用默认值
            return new ButtonConfig
            {
                ButtonId = "btn_01",
                ButtonType = "toggle",
                CooldownTime = 0.5f,
                ActionParameters = new Dictionary<string, object>
                {
                    ["action"] = "default_action"
                }
            };
        }
    }
    
    public class ButtonConfig
    {
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public float CooldownTime { get; set; }
        public Dictionary<string, object> ActionParameters { get; set; }
    }
    
    public class ButtonPressedEvent : IModEvent
    {
        public string EventId => "button_pressed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
}
```

### 创建机器人服务模组 🟢

```csharp
// RobotMod/RobotArmBehaviour.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ModSystem.Core;

namespace RobotMod
{
    public class RobotArmBehaviour : IModBehaviour, IRobotService
    {
        public string BehaviourId => "robot_arm_controller";
        public string Version => "2.0.0";
        
        // IModService implementation
        public string ServiceId => "robot_arm_01";
        public string ProviderId => "RobotMod";
        string IModService.Version => Version;
        
        private IModContext context;
        private RobotConfiguration config;
        private Dictionary<string, JointState> joints;
        private bool emergencyStop = false;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            
            // 加载配置
            config = LoadConfiguration();
            
            // 初始化关节
            joints = InitializeJoints();
            
            // 注册服务
            context.Services.RegisterService<IRobotService>(this);
            
            // 订阅事件
            SubscribeToEvents();
            
            context.Log($"Robot arm {ServiceId} initialized with {joints.Count} joints");
        }
        
        private void SubscribeToEvents()
        {
            // 订阅按钮事件
            context.EventBus.Subscribe<ButtonPressedEvent>(OnButtonPressed);
            
            // 订阅紧急停止事件
            context.EventBus.Subscribe<EmergencyStopEvent>(e => EmergencyStop());
            
            // 订阅控制请求
            context.EventBus.Subscribe<RobotControlRequest>(HandleControlRequest);
        }
        
        private void OnButtonPressed(ButtonPressedEvent e)
        {
            if (emergencyStop) return;
            
            // 根据按钮参数执行动作
            if (e.Parameters?.TryGetValue("action", out var action) == true)
            {
                switch (action.ToString())
                {
                    case "move_forward":
                        _ = MoveToPosition(new Vector3(1, 0, 0));
                        break;
                    case "rotate_base":
                        _ = RotateJoint("base", 45);
                        break;
                    case "home_position":
                        _ = MoveToHomePosition();
                        break;
                }
            }
        }
        
        private async void HandleControlRequest(RobotControlRequest request)
        {
            var response = new RobotControlResponse
            {
                RequestId = request.RequestId,
                SenderId = ServiceId
            };
            
            try
            {
                switch (request.Command)
                {
                    case "move_joint":
                        var jointName = request.Parameters["joint"].ToString();
                        var angle = Convert.ToSingle(request.Parameters["angle"]);
                        response.Success = await RotateJoint(jointName, angle);
                        break;
                        
                    case "get_status":
                        response.Result = await GetStatus();
                        response.Success = true;
                        break;
                        
                    default:
                        response.Success = false;
                        response.Message = $"Unknown command: {request.Command}";
                        break;
                }
            }
            catch (Exception ex)
            {
                response.Success = false;
                response.Message = ex.Message;
            }
            
            context.EventBus.Publish(response);
        }
        
        // IRobotService implementation
        public async Task<bool> MoveToPosition(Vector3 position)
        {
            if (emergencyStop) return false;
            
            context.Log($"Moving to position: {position}");
            
            // 计算逆运动学
            var jointAngles = CalculateInverseKinematics(position);
            
            // 移动所有关节
            var tasks = new List<Task<bool>>();
            foreach (var kvp in jointAngles)
            {
                tasks.Add(RotateJoint(kvp.Key, kvp.Value));
            }
            
            var results = await Task.WhenAll(tasks);
            return Array.TrueForAll(results, r => r);
        }
        
        public async Task<RobotStatus> GetStatus()
        {
            return await Task.FromResult(new RobotStatus
            {
                IsMoving = IsAnyJointMoving(),
                CurrentPosition = GetEndEffectorPosition(),
                JointStates = new Dictionary<string, float>(
                    joints.ToDictionary(j => j.Key, j => j.Value.CurrentAngle)
                ),
                IsEmergencyStopped = emergencyStop
            });
        }
        
        public void EmergencyStop()
        {
            emergencyStop = true;
            
            // 停止所有关节
            foreach (var joint in joints.Values)
            {
                joint.TargetAngle = joint.CurrentAngle;
                joint.IsMoving = false;
            }
            
            // 发布紧急停止事件
            context.EventBus.Publish(new RobotStateChangedEvent
            {
                SenderId = ServiceId,
                State = "emergency_stopped"
            });
            
            context.Log("Emergency stop activated!");
        }
        
        public void OnUpdate(float deltaTime)
        {
            if (emergencyStop) return;
            
            // 更新关节位置
            foreach (var joint in joints.Values)
            {
                if (joint.IsMoving)
                {
                    UpdateJoint(joint, deltaTime);
                }
            }
            
            // 检查碰撞等
            if (config.EnableCollisionDetection)
            {
                CheckCollisions();
            }
        }
        
        public void OnDestroy()
        {
            // 注销服务
            context.Services.UnregisterService<IRobotService>(ServiceId);
            
            context.Log($"Robot arm {ServiceId} destroyed");
        }
        
        // 辅助方法
        private async Task<bool> RotateJoint(string jointName, float angle)
        {
            if (!joints.TryGetValue(jointName, out var joint))
            {
                context.LogError($"Joint {jointName} not found");
                return false;
            }
            
            joint.TargetAngle = Math.Clamp(angle, joint.MinAngle, joint.MaxAngle);
            joint.IsMoving = true;
            
            // 发布状态变化事件
            context.EventBus.Publish(new JointMovementEvent
            {
                SenderId = ServiceId,
                JointName = jointName,
                TargetAngle = joint.TargetAngle
            });
            
            // 模拟异步移动
            while (Math.Abs(joint.CurrentAngle - joint.TargetAngle) > 0.1f)
            {
                await Task.Delay(10);
            }
            
            return true;
        }
        
        private void UpdateJoint(JointState joint, float deltaTime)
        {
            var diff = joint.TargetAngle - joint.CurrentAngle;
            var moveAmount = Math.Sign(diff) * Math.Min(
                Math.Abs(diff), 
                joint.MaxSpeed * deltaTime
            );
            
            joint.CurrentAngle += moveAmount;
            
            if (Math.Abs(joint.CurrentAngle - joint.TargetAngle) < 0.1f)
            {
                joint.CurrentAngle = joint.TargetAngle;
                joint.IsMoving = false;
            }
        }
        
        // 其他辅助方法实现...
    }
}
```

## 完整代码实现

### Unity层实现 🔵

#### UnityLogger

```csharp
// ModSystem.Unity/UnityImplementations/UnityLogger.cs
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity
{
    public class UnityLogger : ILogger
    {
        private readonly string prefix;
        
        public UnityLogger(string prefix = "[ModSystem]")
        {
            this.prefix = prefix;
        }
        
        public void Log(string message)
        {
            Debug.Log($"{prefix} {message}");
        }
        
        public void LogWarning(string message)
        {
            Debug.LogWarning($"{prefix} {message}");
        }
        
        public void LogError(string message)
        {
            Debug.LogError($"{prefix} {message}");
        }
    }
}
```

#### UnityPathProvider

```csharp
// ModSystem.Unity/UnityImplementations/UnityPathProvider.cs
using UnityEngine;
using System.IO;
using ModSystem.Core;

namespace ModSystem.Unity
{
    public class UnityPathProvider : IPathProvider
    {
        public string GetModsPath()
        {
            return Path.Combine(Application.streamingAssetsPath, "Mods");
        }
        
        public string GetConfigPath()
        {
            return Path.Combine(Application.streamingAssetsPath, "ModConfigs");
        }
        
        public string GetTempPath()
        {
            return Path.Combine(Application.temporaryCachePath, "ModTemp");
        }
        
        public string GetPersistentDataPath()
        {
            return Application.persistentDataPath;
        }
    }
}
```

#### UnityObjectFactory

```csharp
// ModSystem.Unity/UnityImplementations/UnityObjectFactory.cs
using UnityEngine;
using System.Threading.Tasks;
using ModSystem.Core;
using System.Collections.Generic;

namespace ModSystem.Unity
{
    public class UnityObjectFactory : ObjectFactoryBase
    {
        public UnityObjectFactory() : base(Application.streamingAssetsPath, new UnityLogger())
        {
        }
        
        public override async Task<IGameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition)
        {
            var gameObject = new GameObject(definition.name);
            var wrapper = new UnityGameObjectWrapper(gameObject);
            
            foreach (var compDef in definition.components)
            {
                await AddComponentAsync(wrapper, compDef);
            }
            
            return wrapper;
        }
        
        private async Task AddComponentAsync(UnityGameObjectWrapper wrapper, ComponentDefinition compDef)
        {
            switch (compDef.type)
            {
                case "Transform":
                    ConfigureTransform(wrapper.GameObject.transform, compDef);
                    break;
                    
                case "MeshRenderer":
                    await ConfigureMeshRenderer(wrapper.GameObject, compDef);
                    break;
                    
                case "BoxCollider":
                    ConfigureBoxCollider(wrapper.GameObject, compDef);
                    break;
                    
                case "SphereCollider":
                    ConfigureSphereCollider(wrapper.GameObject, compDef);
                    break;
                    
                case "RigidBody":
                    ConfigureRigidBody(wrapper.GameObject, compDef);
                    break;
                    
                case "Light":
                    ConfigureLight(wrapper.GameObject, compDef);
                    break;
                    
                case "Camera":
                    ConfigureCamera(wrapper.GameObject, compDef);
                    break;
                    
                case "AudioSource":
                    ConfigureAudioSource(wrapper.GameObject, compDef);
                    break;
                    
                case "ObjectBehaviour":
                    ConfigureObjectBehaviour(wrapper, compDef);
                    break;
                    
                default:
                    logger.LogWarning($"Unknown component type: {compDef.type}");
                    break;
            }
        }
        
        private void ConfigureTransform(Transform transform, ComponentDefinition compDef)
        {
            var position = compDef.GetProperty<float[]>("position", new float[] { 0, 0, 0 });
            var rotation = compDef.GetProperty<float[]>("rotation", new float[] { 0, 0, 0 });
            var scale = compDef.GetProperty<float[]>("scale", new float[] { 1, 1, 1 });
            
            transform.position = new Vector3(position[0], position[1], position[2]);
            transform.rotation = Quaternion.Euler(rotation[0], rotation[1], rotation[2]);
            transform.localScale = new Vector3(scale[0], scale[1], scale[2]);
        }
        
        private async Task ConfigureMeshRenderer(GameObject obj, ComponentDefinition compDef)
        {
            var renderer = obj.AddComponent<MeshRenderer>();
            var meshFilter = obj.AddComponent<MeshFilter>();
            
            // 设置网格
            var meshType = compDef.GetProperty<string>("meshType", "cube");
            meshFilter.mesh = GetPrimitiveMesh(meshType);
            
            // 设置材质
            var material = new Material(Shader.Find("Standard"));
            var color = compDef.GetProperty<float[]>("color", new float[] { 1, 1, 1, 1 });
            material.color = new Color(color[0], color[1], color[2], color[3]);
            
            var metallic = compDef.GetProperty<float>("metallic", 0f);
            material.SetFloat("_Metallic", metallic);
            
            var smoothness = compDef.GetProperty<float>("smoothness", 0.5f);
            material.SetFloat("_Glossiness", smoothness);
            
            renderer.material = material;
            
            // 如果指定了模型文件，尝试加载
            var modelPath = compDef.GetProperty<string>("model");
            if (!string.IsNullOrEmpty(modelPath))
            {
                await LoadGLTFModel(obj, modelPath);
            }
        }
        
        private Mesh GetPrimitiveMesh(string meshType)
        {
            var primitiveType = meshType.ToLower() switch
            {
                "cube" => PrimitiveType.Cube,
                "sphere" => PrimitiveType.Sphere,
                "cylinder" => PrimitiveType.Cylinder,
                "capsule" => PrimitiveType.Capsule,
                "plane" => PrimitiveType.Plane,
                "quad" => PrimitiveType.Quad,
                _ => PrimitiveType.Cube
            };
            
            var tempObj = GameObject.CreatePrimitive(primitiveType);
            var mesh = tempObj.GetComponent<MeshFilter>().sharedMesh;
            GameObject.Destroy(tempObj);
            return mesh;
        }
        
        private void ConfigureBoxCollider(GameObject obj, ComponentDefinition compDef)
        {
            var collider = obj.AddComponent<BoxCollider>();
            
            var center = compDef.GetProperty<float[]>("center", new float[] { 0, 0, 0 });
            var size = compDef.GetProperty<float[]>("size", new float[] { 1, 1, 1 });
            var isTrigger = compDef.GetProperty<bool>("isTrigger", false);
            
            collider.center = new Vector3(center[0], center[1], center[2]);
            collider.size = new Vector3(size[0], size[1], size[2]);
            collider.isTrigger = isTrigger;
        }
        
        private void ConfigureSphereCollider(GameObject obj, ComponentDefinition compDef)
        {
            var collider = obj.AddComponent<SphereCollider>();
            
            var center = compDef.GetProperty<float[]>("center", new float[] { 0, 0, 0 });
            var radius = compDef.GetProperty<float>("radius", 0.5f);
            var isTrigger = compDef.GetProperty<bool>("isTrigger", false);
            
            collider.center = new Vector3(center[0], center[1], center[2]);
            collider.radius = radius;
            collider.isTrigger = isTrigger;
        }
        
        private void ConfigureRigidBody(GameObject obj, ComponentDefinition compDef)
        {
            var rb = obj.AddComponent<Rigidbody>();
            
            rb.mass = compDef.GetProperty<float>("mass", 1f);
            rb.drag = compDef.GetProperty<float>("drag", 0f);
            rb.angularDrag = compDef.GetProperty<float>("angularDrag", 0.05f);
            rb.useGravity = compDef.GetProperty<bool>("useGravity", true);
            rb.isKinematic = compDef.GetProperty<bool>("isKinematic", false);
            
            var constraints = compDef.GetProperty<string[]>("constraints");
            if (constraints != null)
            {
                RigidbodyConstraints rbConstraints = RigidbodyConstraints.None;
                foreach (var constraint in constraints)
                {
                    if (System.Enum.TryParse<RigidbodyConstraints>(constraint, out var c))
                    {
                        rbConstraints |= c;
                    }
                }
                rb.constraints = rbConstraints;
            }
        }
        
        private void ConfigureLight(GameObject obj, ComponentDefinition compDef)
        {
            var light = obj.AddComponent<Light>();
            
            var lightType = compDef.GetProperty<string>("lightType", "Directional");
            if (System.Enum.TryParse<LightType>(lightType, out var type))
            {
                light.type = type;
            }
            
            var color = compDef.GetProperty<float[]>("color", new float[] { 1, 1, 1, 1 });
            light.color = new Color(color[0], color[1], color[2], color[3]);
            
            light.intensity = compDef.GetProperty<float>("intensity", 1f);
            light.range = compDef.GetProperty<float>("range", 10f);
            light.spotAngle = compDef.GetProperty<float>("spotAngle", 30f);
            light.shadows = compDef.GetProperty<bool>("shadows", false) ? 
                LightShadows.Soft : LightShadows.None;
        }
        
        private void ConfigureCamera(GameObject obj, ComponentDefinition compDef)
        {
            var camera = obj.AddComponent<Camera>();
            
            camera.fieldOfView = compDef.GetProperty<float>("fieldOfView", 60f);
            camera.nearClipPlane = compDef.GetProperty<float>("nearClipPlane", 0.3f);
            camera.farClipPlane = compDef.GetProperty<float>("farClipPlane", 1000f);
            camera.depth = compDef.GetProperty<float>("depth", 0f);
            
            var clearFlags = compDef.GetProperty<string>("clearFlags", "Skybox");
            if (System.Enum.TryParse<CameraClearFlags>(clearFlags, out var flags))
            {
                camera.clearFlags = flags;
            }
            
            var backgroundColor = compDef.GetProperty<float[]>("backgroundColor", 
                new float[] { 0.19f, 0.3f, 0.47f, 1f });
            camera.backgroundColor = new Color(
                backgroundColor[0], 
                backgroundColor[1], 
                backgroundColor[2], 
                backgroundColor[3]
            );
        }
        
        private void ConfigureAudioSource(GameObject obj, ComponentDefinition compDef)
        {
            var audioSource = obj.AddComponent<AudioSource>();
            
            audioSource.volume = compDef.GetProperty<float>("volume", 1f);
            audioSource.pitch = compDef.GetProperty<float>("pitch", 1f);
            audioSource.loop = compDef.GetProperty<bool>("loop", false);
            audioSource.playOnAwake = compDef.GetProperty<bool>("playOnAwake", false);
            audioSource.spatialBlend = compDef.GetProperty<float>("spatialBlend", 1f);
            audioSource.minDistance = compDef.GetProperty<float>("minDistance", 1f);
            audioSource.maxDistance = compDef.GetProperty<float>("maxDistance", 500f);
        }
        
        private async Task LoadGLTFModel(GameObject obj, string modelPath)
        {
            // 这里应该使用实际的glTF加载库
            logger.Log($"Would load glTF model from: {modelPath}");
            await Task.Delay(100); // 模拟异步加载
        }
    }
    
    /// <summary>
    /// Unity GameObject的包装器，实现IGameObject接口
    /// </summary>
    public class UnityGameObjectWrapper : IGameObject
    {
        public GameObject GameObject { get; }
        
        public UnityGameObjectWrapper(GameObject gameObject)
        {
            GameObject = gameObject;
        }
        
        public string Name
        {
            get => GameObject.name;
            set => GameObject.name = value;
        }
        
        public bool IsActive
        {
            get => GameObject.activeSelf;
            set => GameObject.SetActive(value);
        }
        
        public ITransform Transform => new UnityTransformWrapper(GameObject.transform);
        
        public T GetComponent<T>() where T : class
        {
            if (typeof(T) == typeof(ObjectBehaviourComponent))
            {
                var comp = GameObject.GetComponent<UnityObjectBehaviourComponent>();
                return comp as T;
            }
            
            var component = GameObject.GetComponent(typeof(T));
            return component as T;
        }
        
        public T AddComponent<T>() where T : class
        {
            if (typeof(T) == typeof(ObjectBehaviourComponent))
            {
                var comp = GameObject.AddComponent<UnityObjectBehaviourComponent>();
                return comp as T;
            }
            
            var component = GameObject.AddComponent(typeof(T) as System.Type);
            return component as T;
        }
    }
    
    /// <summary>
    /// Unity Transform的包装器
    /// </summary>
    public class UnityTransformWrapper : ITransform
    {
        private readonly Transform transform;
        
        public UnityTransformWrapper(Transform transform)
        {
            this.transform = transform;
        }
        
        public Vector3 Position
        {
            get => transform.position;
            set => transform.position = value;
        }
        
        public Quaternion Rotation
        {
            get => transform.rotation;
            set => transform.rotation = value;
        }
        
        public Vector3 Scale
        {
            get => transform.localScale;
            set => transform.localScale = value;
        }
        
        public ITransform Parent
        {
            get => transform.parent != null ? new UnityTransformWrapper(transform.parent) : null;
            set
            {
                if (value is UnityTransformWrapper wrapper)
                {
                    transform.parent = wrapper.transform;
                }
            }
        }
    }
    
    /// <summary>
    /// Unity中的ObjectBehaviour组件
    /// </summary>
    public class UnityObjectBehaviourComponent : MonoBehaviour, ObjectBehaviourComponent
    {
        public IObjectBehaviour Behaviour { get; set; }
        
        void OnDestroy()
        {
            Behaviour?.OnDetach();
        }
    }
}
```

#### ModBehaviourUpdater

```csharp
// ModSystem.Unity/ModBehaviourUpdater.cs
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity
{
    /// <summary>
    /// Unity组件，负责调用模组行为的Update方法
    /// </summary>
    public class ModBehaviourUpdater : MonoBehaviour
    {
        private IModBehaviour behaviour;
        private float lastUpdateTime;
        
        public void Initialize(IModBehaviour behaviour)
        {
            this.behaviour = behaviour;
            lastUpdateTime = Time.time;
        }
        
        void Update()
        {
            if (behaviour != null)
            {
                float deltaTime = Time.time - lastUpdateTime;
                behaviour.OnUpdate(deltaTime);
                lastUpdateTime = Time.time;
            }
        }
        
        void OnDestroy()
        {
            behaviour?.OnDestroy();
        }
        
        void OnEnable()
        {
            // 可以添加恢复逻辑
        }
        
        void OnDisable()
        {
            // 可以添加暂停逻辑
        }
    }
}
```

### 事件监控和调试工具 🔵

```csharp
// ModSystem.Unity/Debug/EventMonitor.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity.Debug
{
    public class EventMonitor : MonoBehaviour, IEventLogger
    {
        [SerializeField] private bool showUI = true;
        [SerializeField] private int maxEventHistory = 100;
        [SerializeField] private Vector2 windowPosition = new Vector2(10, 10);
        [SerializeField] private Vector2 windowSize = new Vector2(600, 400);
        
        private List<EventLogEntry> eventHistory = new List<EventLogEntry>();
        private Vector2 scrollPosition;
        private bool isWindowMinimized = false;
        private Dictionary<string, int> eventCounts = new Dictionary<string, int>();
        private string filterText = "";
        private bool showOnlyErrors = false;
        private HashSet<string> mutedEventTypes = new HashSet<string>();
        private bool isPaused = false;
        
        // 性能统计
        private Dictionary<string, EventStats> eventStats = new Dictionary<string, EventStats>();
        
        public class EventLogEntry
        {
            public DateTime Timestamp { get; set; }
            public string EventType { get; set; }
            public string SenderId { get; set; }
            public string Details { get; set; }
            public LogLevel Level { get; set; }
            public Color Color { get; set; }
        }
        
        public class EventStats
        {
            public int Count { get; set; }
            public float TotalProcessingTime { get; set; }
            public float AverageProcessingTime => Count > 0 ? TotalProcessingTime / Count : 0;
            public float MaxProcessingTime { get; set; }
            public DateTime LastOccurrence { get; set; }
        }
        
        public enum LogLevel
        {
            Info,
            Warning,
            Error
        }
        
        void Awake()
        {
            DontDestroyOnLoad(gameObject);
        }
        
        void Start()
        {
            var controller = FindObjectOfType<ModSystemController>();
            if (controller != null && controller.EventBus is ModEventBus eventBus)
            {
                eventBus.OnEventPublished += OnEventPublished;
            }
        }
        
        private void OnEventPublished(IModEvent e)
        {
            if (isPaused) return;
            
            if (!mutedEventTypes.Contains(e.GetType().Name))
            {
                LogEvent(e);
            }
        }
        
        public void LogEvent(IModEvent e)
        {
            var entry = new EventLogEntry
            {
                Timestamp = e.Timestamp,
                EventType = e.GetType().Name,
                SenderId = e.SenderId ?? "Unknown",
                Details = SerializeEventDetails(e),
                Level = LogLevel.Info,
                Color = GetEventColor(e)
            };
            
            AddLogEntry(entry);
            UpdateStats(e.GetType().Name);
        }
        
        private void UpdateStats(string eventType)
        {
            if (!eventStats.ContainsKey(eventType))
            {
                eventStats[eventType] = new EventStats();
            }
            
            var stats = eventStats[eventType];
            stats.Count++;
            stats.LastOccurrence = DateTime.Now;
            
            // 更新事件计数
            if (!eventCounts.ContainsKey(eventType))
                eventCounts[eventType] = 0;
            eventCounts[eventType]++;
        }
        
        void OnGUI()
        {
            if (!showUI) return;
            
            // 使用更现代的GUI样式
            GUI.skin.window = CreateWindowStyle();
            GUI.skin.button = CreateButtonStyle();
            
            var windowRect = new Rect(windowPosition, windowSize);
            windowRect = GUI.Window(0, windowRect, DrawWindow, "Event Monitor");
            windowPosition = windowRect.position;
        }
        
        private GUIStyle CreateWindowStyle()
        {
            var style = new GUIStyle(GUI.skin.window);
            style.normal.background = CreateTexture(new Color(0.2f, 0.2f, 0.2f, 0.95f));
            style.normal.textColor = Color.white;
            style.fontSize = 14;
            style.fontStyle = FontStyle.Bold;
            return style;
        }
        
        private GUIStyle CreateButtonStyle()
        {
            var style = new GUIStyle(GUI.skin.button);
            style.normal.background = CreateTexture(new Color(0.3f, 0.3f, 0.3f, 1f));
            style.hover.background = CreateTexture(new Color(0.4f, 0.4f, 0.4f, 1f));
            style.active.background = CreateTexture(new Color(0.5f, 0.5f, 0.5f, 1f));
            style.normal.textColor = Color.white;
            return style;
        }
        
        private Texture2D CreateTexture(Color color)
        {
            var texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            return texture;
        }
        
        void DrawWindow(int windowId)
        {
            GUILayout.BeginVertical();
            
            // 标题栏
            DrawTitleBar();
            
            if (!isWindowMinimized)
            {
                // 工具栏
                DrawToolbar();
                
                // 选项卡
                DrawTabs();
                
                // 内容区域
                DrawContent();
            }
            
            GUILayout.EndVertical();
            
            GUI.DragWindow();
        }
        
        private enum Tab
        {
            Events,
            Statistics,
            Settings
        }
        
        private Tab currentTab = Tab.Events;
        
        void DrawTabs()
        {
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Toggle(currentTab == Tab.Events, "Events", "Button"))
                currentTab = Tab.Events;
            
            if (GUILayout.Toggle(currentTab == Tab.Statistics, "Statistics", "Button"))
                currentTab = Tab.Statistics;
            
            if (GUILayout.Toggle(currentTab == Tab.Settings, "Settings", "Button"))
                currentTab = Tab.Settings;
            
            GUILayout.EndHorizontal();
        }
        
        void DrawContent()
        {
            switch (currentTab)
            {
                case Tab.Events:
                    DrawEventList();
                    break;
                case Tab.Statistics:
                    DrawStatistics();
                    break;
                case Tab.Settings:
                    DrawSettings();
                    break;
            }
        }
        
        void DrawStatistics()
        {
            GUILayout.BeginVertical("box");
            
            GUILayout.Label("Event Statistics", "BoldLabel");
            
            // 排序统计数据
            var sortedStats = eventStats.OrderByDescending(kvp => kvp.Value.Count).ToList();
            
            scrollPosition = GUILayout.BeginScrollView(scrollPosition);
            
            foreach (var kvp in sortedStats)
            {
                GUILayout.BeginHorizontal("box");
                
                GUILayout.Label(kvp.Key, GUILayout.Width(200));
                GUILayout.Label($"Count: {kvp.Value.Count}", GUILayout.Width(100));
                GUILayout.Label($"Avg: {kvp.Value.AverageProcessingTime:F2}ms", GUILayout.Width(100));
                GUILayout.Label($"Max: {kvp.Value.MaxProcessingTime:F2}ms", GUILayout.Width(100));
                GUILayout.Label($"Last: {kvp.Value.LastOccurrence:HH:mm:ss}", GUILayout.Width(100));
                
                if (GUILayout.Button("Mute", GUILayout.Width(50)))
                {
                    if (mutedEventTypes.Contains(kvp.Key))
                        mutedEventTypes.Remove(kvp.Key);
                    else
                        mutedEventTypes.Add(kvp.Key);
                }
                
                GUILayout.EndHorizontal();
            }
            
            GUILayout.EndScrollView();
            GUILayout.EndVertical();
        }
        
        void DrawSettings()
        {
            GUILayout.BeginVertical("box");
            
            GUILayout.Label("Monitor Settings", "BoldLabel");
            
            maxEventHistory = (int)GUILayout.HorizontalSlider(maxEventHistory, 10, 1000);
            GUILayout.Label($"Max Event History: {maxEventHistory}");
            
            showOnlyErrors = GUILayout.Toggle(showOnlyErrors, "Show Only Errors");
            
            GUILayout.Space(20);
            
            GUILayout.Label("Muted Events:");
            foreach (var eventType in mutedEventTypes.ToList())
            {
                GUILayout.BeginHorizontal();
                GUILayout.Label(eventType);
                if (GUILayout.Button("Unmute", GUILayout.Width(60)))
                {
                    mutedEventTypes.Remove(eventType);
                }
                GUILayout.EndHorizontal();
            }
            
            GUILayout.EndVertical();
        }
        
        // 其他GUI方法实现...
        
        void Update()
        {
            // 快捷键
            if (Input.GetKeyDown(KeyCode.F12))
            {
                showUI = !showUI;
            }
            
            if (Input.GetKeyDown(KeyCode.F11))
            {
                isPaused = !isPaused;
            }
        }
        
        // IEventLogger实现
        public void LogSubscription(string eventType, string subscriber)
        {
            var entry = new EventLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = "Subscription",
                SenderId = subscriber ?? "Unknown",
                Details = $"Subscribed to {eventType}",
                Level = LogLevel.Info,
                Color = Color.cyan
            };
            
            AddLogEntry(entry);
        }
        
        public void LogError(string message)
        {
            var entry = new EventLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = "Error",
                SenderId = "System",
                Details = message,
                Level = LogLevel.Error,
                Color = Color.red
            };
            
            AddLogEntry(entry);
        }
        
        private void AddLogEntry(EventLogEntry entry)
        {
            eventHistory.Add(entry);
            
            // 保持历史记录在限制范围内
            while (eventHistory.Count > maxEventHistory)
            {
                eventHistory.RemoveAt(0);
            }
        }
        
        private string SerializeEventDetails(IModEvent e)
        {
            var properties = e.GetType().GetProperties()
                .Where(p => p.Name != "EventId" && p.Name != "SenderId" && p.Name != "Timestamp")
                .Select(p => 
                {
                    try
                    {
                        var value = p.GetValue(e);
                        return $"{p.Name}: {value ?? "null"}";
                    }
                    catch
                    {
                        return $"{p.Name}: <error>";
                    }
                })
                .ToList();
            
            return string.Join(", ", properties);
        }
        
        private Color GetEventColor(IModEvent e)
        {
            // 根据事件类型返回不同颜色
            var typeName = e.GetType().Name;
            
            if (typeName.Contains("Error") || typeName.Contains("Exception"))
                return Color.red;
            if (typeName.Contains("Warning"))
                return Color.yellow;
            if (typeName.Contains("Success") || typeName.Contains("Complete"))
                return Color.green;
            if (typeName.Contains("Button"))
                return new Color(0.5f, 1f, 0.5f);
            if (typeName.Contains("Robot"))
                return new Color(0.5f, 0.5f, 1f);
            if (typeName.Contains("Service"))
                return Color.yellow;
            
            return Color.white;
        }
    }
}
```

## 配置系统

### 模组清单（manifest.json）🟡

```json
{
  "id": "button_robot_controller",
  "name": "按钮机器人控制器",
  "version": "1.0.0",
  "author": "Your Name",
  "description": "通过按钮控制机器人手臂的模组",
  "unity_version": "2021.3",
  "sdk_version": "1.0.0",
  "main_class": "ButtonRobotController.MainBehaviour",
  "dependencies": [
    {
      "id": "mod_system_core",
      "version": ">=1.0.0",
      "optional": false
    }
  ],
  "services": [
    {
      "interface": "IRobotService",
      "implementation": "ButtonRobotController.RobotServiceImpl"
    }
  ],
  "permissions": [
    "event_publish",
    "event_subscribe",
    "service_register",
    "object_create",
    "config_read"
  ],
  "resources": {
    "models": ["Models/button.gltf", "Models/robot_arm.gltf"],
    "objects": ["Objects/interactive_button.json", "Objects/robot_controller.json"],
    "configs": ["Config/main_config.json"],
    "textures": ["Resources/Textures/button_texture.png"],
    "audio": ["Resources/Audio/button_click.wav"]
  },
  "metadata": {
    "tags": ["control", "robot", "button"],
    "category": "interaction",
    "homepage": "https://example.com/mods/button-robot"
  }
}
```

### 对象定义示例 🟡

```json
{
  "objectId": "interactive_button_advanced",
  "name": "高级交互按钮",
  "components": [
    {
      "type": "Transform",
      "properties": {
        "position": [0, 1, 0],
        "rotation": [0, 0, 0],
        "scale": [1, 0.2, 1]
      }
    },
    {
      "type": "MeshRenderer",
      "properties": {
        "meshType": "cube",
        "color": [0.2, 0.8, 0.2, 1],
        "metallic": 0.5,
        "smoothness": 0.8,
        "model": "Models/button.gltf"
      }
    },
    {
      "type": "BoxCollider",
      "properties": {
        "center": [0, 0, 0],
        "size": [1, 0.2, 1],
        "isTrigger": false
      }
    },
    {
      "type": "RigidBody",
      "properties": {
        "mass": 0.5,
        "drag": 1,
        "angularDrag": 1,
        "useGravity": false,
        "isKinematic": true
      }
    },
    {
      "type": "AudioSource",
      "properties": {
        "clip": "audio/button_click.wav",
        "volume": 0.8,
        "pitch": 1,
        "playOnAwake": false,
        "spatialBlend": 1
      }
    },
    {
      "type": "Light",
      "properties": {
        "lightType": "Point",
        "color": [0, 1, 0, 1],
        "intensity": 2,
        "range": 5,
        "shadows": true
      }
    },
    {
      "type": "ObjectBehaviour",
      "properties": {
        "behaviourClass": "ButtonMod.InteractiveButtonBehaviour",
        "config": {
          "buttonId": "advanced_btn_01",
          "buttonType": "toggle",
          "clickSound": "button_click",
          "glowOnHover": true,
          "pressDepth": 0.05,
          "cooldownTime": 0.3
        }
      }
    }
  ]
}
```

### 通信配置 🟡

```json
{
  "routes": [
    {
      "name": "button_controls_robot",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "robot_control_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.MoveJointEvent",
          "parameters": {
            "jointName": "base_rotation",
            "angle": 45,
            "speed": 30
          },
          "delay": 0
        }
      ],
      "enabled": true,
      "priority": 10
    },
    {
      "name": "emergency_stop_all",
      "sourceEvent": "SafetyMod.EmergencyButtonEvent",
      "conditions": [],
      "actions": [
        {
          "eventType": "ModSystem.Core.EmergencyStopEvent",
          "parameters": {
            "reason": "Emergency button pressed"
          }
        }
      ],
      "enabled": true,
      "priority": 100
    }
  ],
  "workflows": [
    {
      "name": "robot_startup_sequence",
      "trigger": {
        "event": "SystemMod.StartupEvent"
      },
      "steps": [
        {
          "action": "publish_event",
          "event": "RobotMod.InitializeEvent",
          "delay": 1000
        },
        {
          "action": "wait_for_event",
          "event": "RobotMod.InitializedEvent",
          "timeout": 5000
        },
        {
          "action": "publish_event",
          "event": "RobotMod.HomePositionEvent"
        }
      ]
    }
  ],
  "settings": {
    "enableDebugLogging": true,
    "maxConcurrentActions": 10,
    "defaultActionTimeout": 5000
  }
}
```

## 独立开发SDK

### ModBuilder 2.0（基于模板系统）🟢

```csharp
// ModBuilder/Program.cs
using System;
using System.IO;
using System.Text.Json;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace ModBuilder
{
    class Program
    {
        private static readonly string SDKPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "SDK");
        private static readonly string TemplatesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Templates");
        private static readonly string UserTemplatesPath = Path.Combine(TemplatesPath, "UserTemplates");
        
        static void Main(string[] args)
        {
            Console.WriteLine("╔══════════════════════════════╗");
            Console.WriteLine("║     Mod Builder v2.0.0       ║");
            Console.WriteLine("║   Unity模组独立开发工具       ║");
            Console.WriteLine("╚══════════════════════════════╝\n");
            
            if (args.Length == 0)
            {
                ShowInteractiveMenu();
            }
            else
            {
                ProcessCommand(args);
            }
        }
        
        static void ShowInteractiveMenu()
        {
            while (true)
            {
                Console.WriteLine("\n请选择操作:");
                Console.WriteLine("1. 创建新模组项目");
                Console.WriteLine("2. 构建现有模组");
                Console.WriteLine("3. 测试模组");
                Console.WriteLine("4. 打包模组");
                Console.WriteLine("5. 管理模板");
                Console.WriteLine("6. 查看帮助");
                Console.WriteLine("7. 退出");
                Console.Write("\n请输入选项 (1-7): ");
                
                var choice = Console.ReadLine();
                Console.WriteLine();
                
                switch (choice)
                {
                    case "1":
                        CreateNewMod();
                        break;
                    case "2":
                        BuildMod();
                        break;
                    case "3":
                        TestMod();
                        break;
                    case "4":
                        PackageMod();
                        break;
                    case "5":
                        ManageTemplates();
                        break;
                    case "6":
                        ShowHelp();
                        break;
                    case "7":
                        return;
                    default:
                        Console.WriteLine("无效选项，请重试。");
                        break;
                }
            }
        }
        
        static void CreateNewMod()
        {
            Console.WriteLine("=== 创建新模组 ===\n");
            
            // 获取可用模板
            var templates = GetAvailableTemplates();
            if (templates.Count == 0)
            {
                Console.WriteLine("错误：没有找到可用的模板。");
                return;
            }
            
            // 显示模板列表
            Console.WriteLine("可用模板:");
            for (int i = 0; i < templates.Count; i++)
            {
                Console.WriteLine($"{i + 1}. {templates[i].Name} - {templates[i].Description}");
            }
            
            Console.Write("\n选择模板 (输入编号): ");
            if (!int.TryParse(Console.ReadLine(), out int templateIndex) || 
                templateIndex < 1 || templateIndex > templates.Count)
            {
                Console.WriteLine("无效的选择。");
                return;
            }
            
            var selectedTemplate = templates[templateIndex - 1];
            
            // 收集变量值
            var variables = new Dictionary<string, string>();
            
            Console.Write("\n模组ID (例如: my_custom_mod): ");
            variables["ModId"] = Console.ReadLine()?.ToLower().Replace(" ", "_");
            
            Console.Write("模组名称: ");
            variables["ModName"] = Console.ReadLine();
            
            Console.Write("作者名称: ");
            variables["Author"] = Console.ReadLine();
            
            // 收集模板特定变量
            foreach (var varDef in selectedTemplate.Variables)
            {
                if (!variables.ContainsKey(varDef.Name))
                {
                    Console.Write($"{varDef.Description}: ");
                    variables[varDef.Name] = Console.ReadLine();
                }
            }
            
            // 添加衍生变量
            variables["PascalCaseModId"] = ToPascalCase(variables["ModId"]);
            variables["Year"] = DateTime.Now.Year.ToString();
            variables["Date"] = DateTime.Now.ToString("yyyy-MM-dd");
            
            // 创建项目
            var projectPath = Path.Combine(Directory.GetCurrentDirectory(), variables["ModId"]);
            
            try
            {
                CreateProjectFromTemplate(projectPath, selectedTemplate, variables);
                Console.WriteLine($"\n✓ 模组项目创建成功!");
                Console.WriteLine($"  位置: {projectPath}");
                Console.WriteLine($"\n下一步:");
                Console.WriteLine($"  1. cd {variables["ModId"]}");
                Console.WriteLine($"  2. 编辑源代码和配置文件");
                Console.WriteLine($"  3. 运行 ModBuilder build 构建模组");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n✗ 创建失败: {ex.Message}");
            }
        }
        
        static List<ModTemplate> GetAvailableTemplates()
        {
            var templates = new List<ModTemplate>();
            
            // 加载内置模板
            LoadTemplatesFromDirectory(Path.Combine(TemplatesPath, "BuiltIn"), templates);
            
            // 加载用户模板
            if (Directory.Exists(UserTemplatesPath))
            {
                LoadTemplatesFromDirectory(UserTemplatesPath, templates);
            }
            
            return templates;
        }
        
        static void LoadTemplatesFromDirectory(string directory, List<ModTemplate> templates)
        {
            if (!Directory.Exists(directory))
                return;
            
            foreach (var templateDir in Directory.GetDirectories(directory))
            {
                var templateFile = Path.Combine(templateDir, "template.json");
                if (File.Exists(templateFile))
                {
                    try
                    {
                        var json = File.ReadAllText(templateFile);
                        var template = JsonSerializer.Deserialize<ModTemplate>(json);
                        template.Path = templateDir;
                        templates.Add(template);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"警告：无法加载模板 {templateDir}: {ex.Message}");
                    }
                }
            }
        }
        
        static void CreateProjectFromTemplate(string projectPath, ModTemplate template, Dictionary<string, string> variables)
        {
            // 创建项目目录
            Directory.CreateDirectory(projectPath);
            
            // 处理每个文件规则
            foreach (var fileRule in template.Files)
            {
                var sourcePath = Path.Combine(template.Path, fileRule.Template);
                var destPath = Path.Combine(projectPath, ProcessTemplate(fileRule.Output, variables));
                
                // 创建目标目录
                var destDir = Path.GetDirectoryName(destPath);
                if (!string.IsNullOrEmpty(destDir))
                {
                    Directory.CreateDirectory(destDir);
                }
                
                // 处理文件
                if (fileRule.IsBinary)
                {
                    // 二进制文件直接复制
                    File.Copy(sourcePath, destPath);
                }
                else
                {
                    // 文本文件进行模板处理
                    var content = File.ReadAllText(sourcePath);
                    content = ProcessTemplate(content, variables);
                    File.WriteAllText(destPath, content);
                }
            }
            
            // 复制SDK
            var sdkDestPath = Path.Combine(projectPath, "SDK");
            CopyDirectory(SDKPath, sdkDestPath);
            
            // 创建额外的目录结构
            foreach (var dir in template.Directories ?? new List<string>())
            {
                var dirPath = Path.Combine(projectPath, ProcessTemplate(dir, variables));
                Directory.CreateDirectory(dirPath);
            }
            
            // 执行后处理脚本
            if (!string.IsNullOrEmpty(template.PostCreateScript))
            {
                ExecutePostCreateScript(projectPath, template.PostCreateScript, variables);
            }
        }
        
        static string ProcessTemplate(string template, Dictionary<string, string> variables)
        {
            var result = template;
            
            // 替换变量
            foreach (var kvp in variables)
            {
                result = result.Replace($"{{{{{kvp.Key}}}}}", kvp.Value);
            }
            
            // 处理内置函数
            result = Regex.Replace(result, @"{{PascalCase\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? ToPascalCase(variables[varName]) : m.Value;
            });
            
            result = Regex.Replace(result, @"{{CamelCase\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? ToCamelCase(variables[varName]) : m.Value;
            });
            
            result = Regex.Replace(result, @"{{Upper\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? variables[varName].ToUpper() : m.Value;
            });
            
            result = Regex.Replace(result, @"{{Lower\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? variables[varName].ToLower() : m.Value;
            });
            
            return result;
        }
        
        static void ManageTemplates()
        {
            Console.WriteLine("=== 模板管理 ===\n");
            Console.WriteLine("1. 列出所有模板");
            Console.WriteLine("2. 安装新模板");
            Console.WriteLine("3. 创建自定义模板");
            Console.WriteLine("4. 删除模板");
            Console.WriteLine("5. 返回");
            
            Console.Write("\n请选择: ");
            var choice = Console.ReadLine();
            
            switch (choice)
            {
                case "1":
                    ListTemplates();
                    break;
                case "2":
                    InstallTemplate();
                    break;
                case "3":
                    CreateCustomTemplate();
                    break;
                case "4":
                    DeleteTemplate();
                    break;
            }
        }
        
        static void CreateCustomTemplate()
        {
            Console.WriteLine("\n=== 创建自定义模板 ===\n");
            
            Console.Write("模板ID: ");
            var templateId = Console.ReadLine();
            
            Console.Write("模板名称: ");
            var templateName = Console.ReadLine();
            
            Console.Write("模板描述: ");
            var description = Console.ReadLine();
            
            Console.Write("基于现有项目创建? (y/n): ");
            var useExisting = Console.ReadLine()?.ToLower() == "y";
            
            if (useExisting)
            {
                Console.Write("项目路径: ");
                var projectPath = Console.ReadLine();
                
                if (!Directory.Exists(projectPath))
                {
                    Console.WriteLine("错误：项目路径不存在。");
                    return;
                }
                
                CreateTemplateFromProject(templateId, templateName, description, projectPath);
            }
            else
            {
                CreateEmptyTemplate(templateId, templateName, description);
            }
        }
        
        // 其他方法实现...
        
        static string ToPascalCase(string text)
        {
            return string.Join("", text.Split('_')
                .Select(word => char.ToUpper(word[0]) + word.Substring(1).ToLower()));
        }
        
        static string ToCamelCase(string text)
        {
            var pascal = ToPascalCase(text);
            return char.ToLower(pascal[0]) + pascal.Substring(1);
        }
    }
    
    // 模板数据结构
    public class ModTemplate
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public string Version { get; set; }
        public List<TemplateVariable> Variables { get; set; }
        public List<FileRule> Files { get; set; }
        public List<string> Directories { get; set; }
        public string PostCreateScript { get; set; }
        public string Path { get; set; } // 运行时设置
    }
    
    public class TemplateVariable
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string Type { get; set; }
        public string DefaultValue { get; set; }
        public bool Required { get; set; }
    }
    
    public class FileRule
    {
        public string Template { get; set; }
        public string Output { get; set; }
        public bool IsBinary { get; set; }
    }
}
            