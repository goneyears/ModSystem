# Unityæ¨¡ç»„é€šä¿¡ç³»ç»Ÿ - å®Œæ•´å®ç°ä¸æ–‡æ¡£ v4

## ç›®å½•
1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
3. [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
   - 3.1 [åŸºç¡€æ¥å£å®šä¹‰](#åŸºç¡€æ¥å£å®šä¹‰)
   - 3.2 [è¿è¡Œæ—¶æ ¸å¿ƒç»„ä»¶](#è¿è¡Œæ—¶æ ¸å¿ƒç»„ä»¶)
   - 3.3 [é€šä¿¡ç³»ç»Ÿ](#é€šä¿¡ç³»ç»Ÿ)
   - 3.4 [å®‰å…¨ç³»ç»Ÿ](#å®‰å…¨ç³»ç»Ÿ)
4. [é€šä¿¡æ¨¡å¼è¯¦è§£](#é€šä¿¡æ¨¡å¼è¯¦è§£)
5. [æ¨¡ç»„å¼€å‘](#æ¨¡ç»„å¼€å‘)
6. [å®Œæ•´ä»£ç å®ç°](#å®Œæ•´ä»£ç å®ç°)
7. [é…ç½®ç³»ç»Ÿ](#é…ç½®ç³»ç»Ÿ)
8. [ç‹¬ç«‹å¼€å‘SDK](#ç‹¬ç«‹å¼€å‘sdk)
9. [éƒ¨ç½²å’Œå®‰è£…](#éƒ¨ç½²å’Œå®‰è£…)
10. [è°ƒè¯•å’Œä¼˜åŒ–](#è°ƒè¯•å’Œä¼˜åŒ–)
11. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
12. [å¸¸è§é—®é¢˜è§£ç­”](#å¸¸è§é—®é¢˜è§£ç­”)

## ç³»ç»Ÿæ¦‚è¿°

æœ¬é€šä¿¡ç³»ç»Ÿæä¾›äº†ä¸€ä¸ªå®Œæ•´çš„Unityæ¨¡ç»„åŒ–å¼€å‘æ¡†æ¶ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **å¹³å°æ— å…³çš„æ ¸å¿ƒå±‚**ï¼šCoreå±‚ä¸ä¾èµ–Unityï¼Œå¯ç”¨äºä»»ä½•.NETé¡¹ç›®
- **å¤šç§é€šä¿¡æ¨¡å¼**ï¼šäº‹ä»¶ç³»ç»Ÿã€è¯·æ±‚-å“åº”ã€æœåŠ¡æ³¨å†Œã€é…ç½®é©±åŠ¨
- **ç‹¬ç«‹å¼€å‘æ”¯æŒ**ï¼šæ— éœ€Unityç¼–è¾‘å™¨å³å¯å¼€å‘æ¨¡ç»„
- **ç±»å‹å®‰å…¨**ï¼šé€šè¿‡æ¥å£å’Œæ³›å‹ä¿è¯ç±»å‹å®‰å…¨
- **å¯¹è±¡å®šä¹‰ç³»ç»Ÿ**ï¼šä½¿ç”¨JSONæ›¿ä»£Unityçš„Prefabç³»ç»Ÿ
- **å®‰å…¨æœºåˆ¶**ï¼šé˜²æ­¢æ¶æ„ä»£ç æ‰§è¡Œ
- **å®Œæ•´å·¥å…·é“¾**ï¼šä»å¼€å‘åˆ°æ‰“åŒ…çš„å…¨æµç¨‹æ”¯æŒ

### å¼€å‘ç¯å¢ƒæ ‡è¯†

- ğŸ”µ **Unityç¼–è¾‘å™¨ä¸­å¼€å‘**ï¼šéœ€è¦Unityç¯å¢ƒçš„ä»£ç 
- ğŸŸ¢ **Visual Studioç‹¬ç«‹å¼€å‘**ï¼šçº¯C#ä»£ç ï¼Œå¯ç¼–è¯‘ä¸ºDLL
- ğŸŸ¡ **æ–‡æœ¬ç¼–è¾‘å™¨**ï¼šJSONé…ç½®æ–‡ä»¶

## é¡¹ç›®ç»“æ„

### å®Œæ•´çš„å·¥ä½œåŒºç»“æ„

```
å·¥ä½œåŒº/
â”œâ”€â”€ ModSystemCore/              # ğŸŸ¢ VSç‹¬ç«‹é¡¹ç›®ï¼ˆå¹³å°æ— å…³ï¼‰
â”‚   â”œâ”€â”€ ModSystem.Core.sln
â”‚   â”œâ”€â”€ ModSystem.Core/
â”‚   â”‚   â”œâ”€â”€ Interfaces/         # æ¥å£å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ EventSystem/        # äº‹ä»¶ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ Communication/      # é€šä¿¡ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ Services/           # æœåŠ¡ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ Runtime/            # è¿è¡Œæ—¶æ ¸å¿ƒ
â”‚   â”‚   â””â”€â”€ Security/           # å®‰å…¨ç³»ç»Ÿ
â”‚   â””â”€â”€ bin/Release/
â”‚       â””â”€â”€ ModSystem.Core.dll  â†’ å¤åˆ¶åˆ°Unityé¡¹ç›®
â”‚
â”œâ”€â”€ ModSDK/                     # ğŸŸ¢ ç‹¬ç«‹å¼€å‘SDK
â”‚   â”œâ”€â”€ SDK/
â”‚   â”‚   â”œâ”€â”€ ModSDK.Core.dll    # ä»ModSystemCoreæ„å»º
â”‚   â”‚   â”œâ”€â”€ ModSDK.Runtime.dll
â”‚   â”‚   â””â”€â”€ Newtonsoft.Json.dll
â”‚   â”œâ”€â”€ Tools/
â”‚   â”‚   â”œâ”€â”€ ModBuilder.exe
â”‚   â”‚   â””â”€â”€ ModEditor.exe
â”‚   â””â”€â”€ Templates/              # ğŸŸ¡ æ¨¡æ¿ç³»ç»Ÿ
â”‚       â”œâ”€â”€ ButtonMod/
â”‚       â”œâ”€â”€ RobotMod/
â”‚       â””â”€â”€ template-registry.json
â”‚
â”œâ”€â”€ MyMods/                     # ğŸŸ¢ æ¨¡ç»„å¼€å‘é¡¹ç›®
â”‚   â”œâ”€â”€ ButtonMod/
â”‚   â””â”€â”€ RobotMod/
â”‚
â””â”€â”€ UnityGameProject/           # ğŸ”µ Unityé¡¹ç›®
    â””â”€â”€ Assets/
        â””â”€â”€ ModSystem/
            â”œâ”€â”€ Core/
            â”‚   â””â”€â”€ Assemblies/  # Core DLLæ”¾ç½®ä½ç½®
            â”œâ”€â”€ Unity/           # Unityç‰¹å®šä»£ç 
            â”‚   â”œâ”€â”€ ModSystemController.cs
            â”‚   â”œâ”€â”€ ModManager.cs
            â”‚   â”œâ”€â”€ UnityImplementations/
            â”‚   â””â”€â”€ Editor/
            â”œâ”€â”€ Examples/        # ç¤ºä¾‹é¡¹ç›®
            â””â”€â”€ StreamingAssets/
                â”œâ”€â”€ ModConfigs/
                â”œâ”€â”€ Mods/
                â””â”€â”€ ModPackages/
```

### å±‚æ¬¡æ¶æ„è¯´æ˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ç”¨æˆ·æ¨¡ç»„ (User Mods)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               ModSDK (å¼€å‘SDK)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Unityå±‚ (Unity Specific)           â”‚
â”‚  ModSystemController, Unityå®ç°, Editorå·¥å…·   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          æ ¸å¿ƒå±‚ (ModSystem.Core)             â”‚
â”‚     å¹³å°æ— å…³çš„æ¥å£ã€äº‹ä»¶ç³»ç»Ÿã€é€šä¿¡ç³»ç»Ÿ         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ ¸å¿ƒç»„ä»¶

### åŸºç¡€æ¥å£å®šä¹‰

#### 1. æ ¸å¿ƒæŠ½è±¡æ¥å£ï¼ˆå¹³å°æ— å…³ï¼‰ğŸŸ¢

```csharp
// ModSystem.Core/Interfaces/IPlatformAbstractions.cs
namespace ModSystem.Core
{
    /// <summary>
    /// æ—¥å¿—æ¥å£ï¼Œç”¨äºæ›¿ä»£Unityçš„Debugç±»
    /// </summary>
    public interface ILogger
    {
        void Log(string message);
        void LogWarning(string message);
        void LogError(string message);
    }
    
    /// <summary>
    /// è·¯å¾„æä¾›æ¥å£ï¼Œç”¨äºæ›¿ä»£Unityçš„Applicationç±»
    /// </summary>
    public interface IPathProvider
    {
        string GetModsPath();
        string GetConfigPath();
        string GetTempPath();
        string GetPersistentDataPath();
    }
    
    /// <summary>
    /// æ¸¸æˆå¯¹è±¡æ¥å£ï¼Œç”¨äºæŠ½è±¡Unityçš„GameObject
    /// </summary>
    public interface IGameObject
    {
        string Name { get; set; }
        bool IsActive { get; set; }
        ITransform Transform { get; }
        T GetComponent<T>() where T : class;
        T AddComponent<T>() where T : class;
    }
    
    /// <summary>
    /// å˜æ¢æ¥å£ï¼Œç”¨äºæŠ½è±¡Unityçš„Transform
    /// </summary>
    public interface ITransform
    {
        Vector3 Position { get; set; }
        Quaternion Rotation { get; set; }
        Vector3 Scale { get; set; }
        ITransform Parent { get; set; }
    }
}
```

#### 2. æ¨¡ç»„ç³»ç»Ÿæ ¸å¿ƒæ¥å£ ğŸŸ¢

```csharp
// ModSystem.Core/Interfaces/IModEvent.cs
namespace ModSystem.Core
{
    /// <summary>
    /// æ¨¡ç»„äº‹ä»¶åŸºç¡€æ¥å£
    /// </summary>
    public interface IModEvent
    {
        string EventId { get; }
        string SenderId { get; set; }
        DateTime Timestamp { get; set; }
    }
    
    /// <summary>
    /// äº‹ä»¶æ€»çº¿æ¥å£
    /// </summary>
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler) where T : IModEvent;
        void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent;
        void Publish<T>(T eventData) where T : IModEvent;
        void Unsubscribe<T>(Action<T> handler) where T : IModEvent;
    }
    
    /// <summary>
    /// æ¨¡ç»„è¡Œä¸ºæ¥å£
    /// </summary>
    public interface IModBehaviour
    {
        string BehaviourId { get; }
        string Version { get; }
        void OnInitialize(IModContext context);
        void OnUpdate(float deltaTime);
        void OnDestroy();
    }
    
    /// <summary>
    /// å¯¹è±¡é™„åŠ è¡Œä¸ºæ¥å£ï¼ˆç”¨äºObjectFactoryåˆ›å»ºçš„å¯¹è±¡ï¼‰
    /// </summary>
    public interface IObjectBehaviour
    {
        void OnAttach(IGameObject gameObject);
        void OnConfigure(Dictionary<string, object> config);
        void OnDetach();
    }
    
    /// <summary>
    /// æ¨¡ç»„ä¸Šä¸‹æ–‡æ¥å£
    /// </summary>
    public interface IModContext
    {
        string ModId { get; }
        IGameObject GameObject { get; }
        IEventBus EventBus { get; }
        IModAPI API { get; }
        IServiceRegistry Services { get; }
        T GetComponent<T>() where T : class;
        void Log(string message);
        void LogError(string message);
    }
}
```

### è¿è¡Œæ—¶æ ¸å¿ƒç»„ä»¶

#### 1. ModSystemControllerï¼ˆUnityé›†æˆæ§åˆ¶å™¨ï¼‰ğŸ”µ

```csharp
// ModSystem.Unity/ModSystemController.cs
using UnityEngine;
using ModSystem.Core;
using System.IO;

namespace ModSystem.Unity
{
    /// <summary>
    /// Unityæ¨¡ç»„ç³»ç»Ÿä¸»æ§åˆ¶å™¨
    /// è´Ÿè´£åˆå§‹åŒ–å’Œç®¡ç†æ•´ä¸ªæ¨¡ç»„ç³»ç»Ÿ
    /// </summary>
    public class ModSystemController : MonoBehaviour
    {
        private ModManagerCore modManagerCore;
        private ModEventBus eventBus;
        private ModServiceRegistry serviceRegistry;
        private CommunicationRouter router;
        private UnityLogger logger;
        private UnityPathProvider pathProvider;
        
        public IEventBus EventBus => eventBus;
        public IServiceRegistry ServiceRegistry => serviceRegistry;
        
        void Awake()
        {
            // åˆ›å»ºUnityå®ç°
            logger = new UnityLogger();
            pathProvider = new UnityPathProvider();
            
            // åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
            eventBus = new ModEventBus(new UnityEventLogger());
            serviceRegistry = new ModServiceRegistry(eventBus);
            
            // åˆ›å»ºæ ¸å¿ƒæ¨¡ç»„ç®¡ç†å™¨
            modManagerCore = new ModManagerCore(logger, pathProvider, eventBus, serviceRegistry);
            
            // åˆ›å»ºUnityåŒ…è£…å™¨
            var modManager = gameObject.AddComponent<ModManager>();
            modManager.Initialize(modManagerCore);
            
            // åŠ è½½é€šä¿¡é…ç½®
            LoadCommunicationConfig();
        }
        
        void Start()
        {
            // åŠ è½½æ¨¡ç»„
            LoadMods();
        }
        
        private void LoadCommunicationConfig()
        {
            string configPath = Path.Combine(pathProvider.GetConfigPath(), 
                "communication_config.json");
            
            if (File.Exists(configPath))
            {
                string configJson = File.ReadAllText(configPath);
                router = new CommunicationRouter(eventBus, configJson);
                logger.Log("Communication config loaded");
            }
        }
        
        private async void LoadMods()
        {
            // åŠ è½½å†…ç½®æ¨¡ç»„
            await modManagerCore.LoadModsFromDirectory(pathProvider.GetModsPath());
            
            // åŠ è½½å¤–éƒ¨æ¨¡ç»„åŒ…
            await modManagerCore.LoadModPackagesFromDirectory(
                Path.Combine(pathProvider.GetModsPath(), "../ModPackages")
            );
        }
    }
}
```

#### 2. ModManagerCoreï¼ˆå¹³å°æ— å…³çš„æ¨¡ç»„ç®¡ç†å™¨ï¼‰ğŸŸ¢

```csharp
// ModSystem.Core/Runtime/ModManagerCore.cs
namespace ModSystem.Core
{
    /// <summary>
    /// å¹³å°æ— å…³çš„æ¨¡ç»„ç®¡ç†å™¨æ ¸å¿ƒ
    /// è´Ÿè´£æ¨¡ç»„çš„åŠ è½½ã€ç®¡ç†å’Œç”Ÿå‘½å‘¨æœŸæ§åˆ¶
    /// </summary>
    public class ModManagerCore
    {
        private readonly ILogger logger;
        private readonly IPathProvider pathProvider;
        private readonly IEventBus eventBus;
        private readonly IServiceRegistry serviceRegistry;
        private readonly ModLoader modLoader;
        private readonly Dictionary<string, ModInstance> modInstances;
        
        public string LastError { get; private set; }
        public List<string> ValidationErrors { get; private set; } = new List<string>();
        
        public ModManagerCore(
            ILogger logger, 
            IPathProvider pathProvider,
            IEventBus eventBus,
            IServiceRegistry serviceRegistry)
        {
            this.logger = logger;
            this.pathProvider = pathProvider;
            this.eventBus = eventBus;
            this.serviceRegistry = serviceRegistry;
            
            var securityConfig = LoadSecurityConfig();
            var securityManager = new SecurityManager(securityConfig, logger);
            
            modLoader = new ModLoader(logger, pathProvider, securityManager);
            modInstances = new Dictionary<string, ModInstance>();
        }
        
        public async Task<bool> LoadMod(string modPath)
        {
            try
            {
                ValidationErrors.Clear();
                
                // åŠ è½½æ¨¡ç»„
                var loadedMod = await modLoader.LoadModAsync(modPath);
                
                // åˆ›å»ºæ¨¡ç»„å®ä¾‹
                var instance = CreateModInstance(loadedMod);
                modInstances[loadedMod.Manifest.id] = instance;
                
                // åˆå§‹åŒ–è¡Œä¸º
                foreach (var behaviour in loadedMod.Behaviours)
                {
                    var context = CreateModContext(loadedMod, instance);
                    behaviour.OnInitialize(context);
                }
                
                // å‘å¸ƒæ¨¡ç»„åŠ è½½äº‹ä»¶
                eventBus.Publish(new ModLoadedEvent
                {
                    ModId = loadedMod.Manifest.id,
                    ModName = loadedMod.Manifest.name,
                    Version = loadedMod.Manifest.version
                });
                
                logger.Log($"Mod loaded: {loadedMod.Manifest.name} v{loadedMod.Manifest.version}");
                return true;
            }
            catch (Exception ex)
            {
                LastError = ex.Message;
                logger.LogError($"Failed to load mod: {ex}");
                return false;
            }
        }
        
        private ModInstance CreateModInstance(LoadedMod loadedMod)
        {
            return new ModInstance
            {
                LoadedMod = loadedMod,
                State = ModState.Loaded
            };
        }
        
        private IModContext CreateModContext(LoadedMod loadedMod, ModInstance instance)
        {
            return new ModContext
            {
                ModId = loadedMod.Manifest.id,
                EventBus = eventBus,
                Services = serviceRegistry,
                Logger = logger,
                API = CreateModAPI(loadedMod)
            };
        }
        
        public async Task LoadModsFromDirectory(string directory)
        {
            if (!Directory.Exists(directory))
            {
                logger.LogWarning($"Mods directory not found: {directory}");
                return;
            }
            
            foreach (var modDir in Directory.GetDirectories(directory))
            {
                await LoadMod(modDir);
            }
        }
        
        // å…¶ä»–æ–¹æ³•...
    }
}
```

#### 3. ModManagerï¼ˆUnityåŒ…è£…å™¨ï¼‰ğŸ”µ

```csharp
// ModSystem.Unity/ModManager.cs
using UnityEngine;
using ModSystem.Core;
using System.Collections.Generic;

namespace ModSystem.Unity
{
    /// <summary>
    /// Unityç‰¹å®šçš„ModManageråŒ…è£…å™¨
    /// å¤„ç†Unityç”Ÿå‘½å‘¨æœŸå’ŒGameObjectç®¡ç†
    /// </summary>
    public class ModManager : MonoBehaviour
    {
        private ModManagerCore core;
        private Dictionary<string, ModUnityInstance> unityInstances;
        private IObjectFactory objectFactory;
        
        public void Initialize(ModManagerCore core)
        {
            this.core = core;
            unityInstances = new Dictionary<string, ModUnityInstance>();
            objectFactory = new UnityObjectFactory();
            
            // ç›‘å¬æ¨¡ç»„åŠ è½½äº‹ä»¶
            core.EventBus.Subscribe<ModLoadedEvent>(OnModLoaded);
            core.EventBus.Subscribe<ModUnloadedEvent>(OnModUnloaded);
        }
        
        private void OnModLoaded(ModLoadedEvent e)
        {
            CreateUnityInstance(e.ModId);
        }
        
        private void CreateUnityInstance(string modId)
        {
            var modInstance = core.GetModInstance(modId);
            if (modInstance == null) return;
            
            // åˆ›å»ºUnityå®¹å™¨
            var container = new GameObject($"Mod_{modId}");
            container.transform.SetParent(transform);
            
            var unityInstance = new ModUnityInstance
            {
                Container = container,
                GameObjects = new List<GameObject>()
            };
            
            // ä¸ºæ¯ä¸ªè¡Œä¸ºåˆ›å»ºGameObject
            foreach (var behaviour in modInstance.LoadedMod.Behaviours)
            {
                var behaviourObj = new GameObject($"Behaviour_{behaviour.BehaviourId}");
                behaviourObj.transform.SetParent(container.transform);
                
                // æ·»åŠ æ›´æ–°ç»„ä»¶
                var updater = behaviourObj.AddComponent<ModBehaviourUpdater>();
                updater.Initialize(behaviour);
                
                unityInstance.GameObjects.Add(behaviourObj);
            }
            
            // åˆ›å»ºå¯¹è±¡å®šä¹‰ä¸­çš„GameObject
            CreateObjectsFromDefinitions(modInstance, unityInstance);
            
            unityInstances[modId] = unityInstance;
        }
        
        private async void CreateObjectsFromDefinitions(
            ModInstance modInstance, 
            ModUnityInstance unityInstance)
        {
            foreach (var objDef in modInstance.LoadedMod.Resources.ObjectDefinitions.Values)
            {
                try
                {
                    var obj = await objectFactory.CreateObjectFromDefinitionAsync(objDef);
                    obj.transform.SetParent(unityInstance.Container.transform);
                    unityInstance.GameObjects.Add(obj);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Failed to create object {objDef.objectId}: {ex.Message}");
                }
            }
        }
        
        void OnDestroy()
        {
            // æ¸…ç†æ‰€æœ‰Unityå®ä¾‹
            foreach (var instance in unityInstances.Values)
            {
                if (instance.Container != null)
                    Destroy(instance.Container);
            }
        }
    }
    
    public class ModUnityInstance
    {
        public GameObject Container { get; set; }
        public List<GameObject> GameObjects { get; set; }
    }
}
```

#### 4. ModLoaderï¼ˆå¹³å°æ— å…³çš„æ¨¡ç»„åŠ è½½å™¨ï¼‰ğŸŸ¢

```csharp
// ModSystem.Core/Runtime/ModLoader.cs
using System;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    /// <summary>
    /// å¹³å°æ— å…³çš„æ¨¡ç»„åŠ è½½å™¨
    /// è´Ÿè´£åŠ è½½æ¨¡ç»„æ–‡ä»¶å’Œç¨‹åºé›†
    /// </summary>
    public class ModLoader
    {
        private readonly ILogger logger;
        private readonly IPathProvider pathProvider;
        private readonly SecurityManager securityManager;
        private readonly Dictionary<string, LoadedMod> loadedMods;
        
        public ModLoader(ILogger logger, IPathProvider pathProvider, SecurityManager securityManager = null)
        {
            this.logger = logger;
            this.pathProvider = pathProvider;
            this.securityManager = securityManager;
            this.loadedMods = new Dictionary<string, LoadedMod>();
        }
        
        public async Task<LoadedMod> LoadModAsync(string modDirectory)
        {
            try
            {
                // 1. åŠ è½½æ¸…å•æ–‡ä»¶
                var manifestPath = Path.Combine(modDirectory, "manifest.json");
                if (!File.Exists(manifestPath))
                {
                    throw new FileNotFoundException("Manifest file not found");
                }
                
                var manifestJson = await File.ReadAllTextAsync(manifestPath);
                var manifest = JsonConvert.DeserializeObject<ModManifest>(manifestJson);
                
                // 2. éªŒè¯å®‰å…¨æ€§
                if (securityManager != null && !securityManager.ValidateMod(modDirectory))
                {
                    throw new SecurityException("Mod failed security validation");
                }
                
                // 3. åŠ è½½ç¨‹åºé›†
                Assembly assembly = null;
                var dllPath = Path.Combine(modDirectory, "Assemblies", $"{manifest.id}.dll");
                if (File.Exists(dllPath))
                {
                    assembly = Assembly.LoadFrom(dllPath);
                }
                
                // 4. åŠ è½½èµ„æº
                var resources = await LoadResourcesAsync(modDirectory, manifest);
                
                // 5. åˆ›å»ºæ¨¡ç»„å®ä¾‹
                var loadedMod = new LoadedMod
                {
                    Manifest = manifest,
                    Assembly = assembly,
                    Resources = resources,
                    RootPath = modDirectory
                };
                
                // 6. å®ä¾‹åŒ–ä¸»æ¨¡ç»„è¡Œä¸ºç±»ï¼ˆä¸æ˜¯å¯¹è±¡è¡Œä¸ºï¼‰
                if (!string.IsNullOrEmpty(manifest.mainClass) && assembly != null)
                {
                    var mainType = assembly.GetType(manifest.mainClass);
                    if (mainType != null && typeof(IModBehaviour).IsAssignableFrom(mainType))
                    {
                        var behaviour = Activator.CreateInstance(mainType) as IModBehaviour;
                        loadedMod.Behaviours.Add(behaviour);
                    }
                }
                
                loadedMods[manifest.id] = loadedMod;
                logger.Log($"Mod loaded: {manifest.name} v{manifest.version}");
                
                return loadedMod;
            }
            catch (Exception ex)
            {
                logger.LogError($"Failed to load mod from {modDirectory}: {ex.Message}");
                throw;
            }
        }
        
        private async Task<ModResources> LoadResourcesAsync(string modDirectory, ModManifest manifest)
        {
            var resources = new ModResources();
            
            // åŠ è½½å¯¹è±¡å®šä¹‰
            var objectsDir = Path.Combine(modDirectory, "Objects");
            if (Directory.Exists(objectsDir))
            {
                foreach (var objectFile in Directory.GetFiles(objectsDir, "*.json"))
                {
                    try
                    {
                        var objectJson = await File.ReadAllTextAsync(objectFile);
                        var objectDef = JsonConvert.DeserializeObject<ObjectDefinition>(objectJson);
                        resources.ObjectDefinitions[Path.GetFileName(objectFile)] = objectDef;
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Failed to load object definition {objectFile}: {ex.Message}");
                    }
                }
            }
            
            // åŠ è½½é…ç½®æ–‡ä»¶
            var configDir = Path.Combine(modDirectory, "Config");
            if (Directory.Exists(configDir))
            {
                foreach (var configFile in Directory.GetFiles(configDir, "*.json"))
                {
                    try
                    {
                        var configData = await File.ReadAllTextAsync(configFile);
                        resources.Configs[Path.GetFileName(configFile)] = configData;
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Failed to load config {configFile}: {ex.Message}");
                    }
                }
            }
            
            // è®°å½•èµ„æºè·¯å¾„ï¼ˆä¸å®é™…åŠ è½½ï¼‰
            resources.ModelPaths = GetResourcePaths(modDirectory, "Models", "*.gltf", "*.glb");
            resources.TexturePaths = GetResourcePaths(modDirectory, "Resources/Textures", "*.png", "*.jpg");
            resources.AudioPaths = GetResourcePaths(modDirectory, "Resources/Audio", "*.wav", "*.mp3");
            
            return resources;
        }
        
        private Dictionary<string, string> GetResourcePaths(string baseDir, string subDir, params string[] patterns)
        {
            var paths = new Dictionary<string, string>();
            var dir = Path.Combine(baseDir, subDir);
            
            if (Directory.Exists(dir))
            {
                foreach (var pattern in patterns)
                {
                    foreach (var file in Directory.GetFiles(dir, pattern))
                    {
                        paths[Path.GetFileName(file)] = file;
                    }
                }
            }
            
            return paths;
        }
        
        public void UnloadMod(string modId)
        {
            if (loadedMods.TryGetValue(modId, out var mod))
            {
                // é”€æ¯æ‰€æœ‰è¡Œä¸º
                foreach (var behaviour in mod.Behaviours)
                {
                    try
                    {
                        behaviour.OnDestroy();
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Error destroying behaviour: {ex.Message}");
                    }
                }
                
                // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                if (mod.IsTemporary && Directory.Exists(mod.RootPath))
                {
                    try
                    {
                        Directory.Delete(mod.RootPath, true);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError($"Failed to delete temporary files: {ex.Message}");
                    }
                }
                
                loadedMods.Remove(modId);
                logger.Log($"Mod {modId} unloaded");
            }
        }
    }
}
```

#### 5. ObjectFactoryï¼ˆå¯¹è±¡å·¥å‚ç³»ç»Ÿï¼‰ğŸŸ¢

```csharp
// ModSystem.Core/Runtime/ObjectFactory.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    /// <summary>
    /// å¯¹è±¡å®šä¹‰ï¼Œæ›¿ä»£Unityçš„Prefabç³»ç»Ÿ
    /// </summary>
    [Serializable]
    public class ObjectDefinition
    {
        public string objectId { get; set; }
        public string name { get; set; }
        public List<ComponentDefinition> components { get; set; }
    }
    
    [Serializable]
    public class ComponentDefinition
    {
        public string type { get; set; }
        public Dictionary<string, object> properties { get; set; }
        
        public T GetProperty<T>(string key, T defaultValue = default)
        {
            if (properties != null && properties.TryGetValue(key, out var value))
            {
                try
                {
                    if (value is Newtonsoft.Json.Linq.JArray jArray && typeof(T).IsArray)
                    {
                        var elementType = typeof(T).GetElementType();
                        var array = jArray.ToObject(typeof(T));
                        return (T)array;
                    }
                    
                    return (T)Convert.ChangeType(value, typeof(T));
                }
                catch
                {
                    return defaultValue;
                }
            }
            return defaultValue;
        }
    }
    
    /// <summary>
    /// å¹³å°æ— å…³çš„å¯¹è±¡å·¥å‚æ¥å£
    /// </summary>
    public interface IObjectFactory
    {
        Task<IGameObject> CreateObjectAsync(string definitionPath);
        Task<IGameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition);
    }
    
    /// <summary>
    /// æŠ½è±¡å¯¹è±¡å·¥å‚åŸºç±»
    /// </summary>
    public abstract class ObjectFactoryBase : IObjectFactory
    {
        protected readonly Dictionary<string, ObjectDefinition> definitionCache;
        protected readonly string basePath;
        protected readonly ILogger logger;
        
        protected ObjectFactoryBase(string basePath, ILogger logger)
        {
            this.basePath = basePath;
            this.logger = logger;
            definitionCache = new Dictionary<string, ObjectDefinition>();
        }
        
        public async Task<IGameObject> CreateObjectAsync(string definitionPath)
        {
            ObjectDefinition definition;
            
            if (definitionCache.ContainsKey(definitionPath))
            {
                definition = definitionCache[definitionPath];
            }
            else
            {
                var json = await LoadJsonAsync(definitionPath);
                definition = JsonConvert.DeserializeObject<ObjectDefinition>(json);
                definitionCache[definitionPath] = definition;
            }
            
            return await CreateObjectFromDefinitionAsync(definition);
        }
        
        public abstract Task<IGameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition);
        
        protected virtual async Task<string> LoadJsonAsync(string path)
        {
            var fullPath = System.IO.Path.Combine(basePath, path);
            return await System.IO.File.ReadAllTextAsync(fullPath);
        }
        
        /// <summary>
        /// é…ç½®å¯¹è±¡è¡Œä¸ºï¼ˆè€Œä¸æ˜¯æ¨¡ç»„è¡Œä¸ºï¼‰
        /// </summary>
        protected virtual void ConfigureObjectBehaviour(IGameObject obj, ComponentDefinition compDef)
        {
            var behaviourClass = compDef.GetProperty<string>("behaviourClass");
            if (string.IsNullOrEmpty(behaviourClass))
            {
                logger.LogError("ObjectBehaviour requires behaviourClass property");
                return;
            }
            
            var behaviourType = Type.GetType(behaviourClass);
            if (behaviourType != null && typeof(IObjectBehaviour).IsAssignableFrom(behaviourType))
            {
                var behaviour = Activator.CreateInstance(behaviourType) as IObjectBehaviour;
                
                // é™„åŠ åˆ°å¯¹è±¡
                behaviour.OnAttach(obj);
                
                // é…ç½®è¡Œä¸º
                var config = compDef.GetProperty<Dictionary<string, object>>("config");
                if (config != null)
                {
                    behaviour.OnConfigure(config);
                }
                
                // å­˜å‚¨å¼•ç”¨ä»¥ä¾¿åç»­æ¸…ç†
                obj.AddComponent<ObjectBehaviourComponent>().Behaviour = behaviour;
            }
            else
            {
                logger.LogError($"Could not find or instantiate behaviour class: {behaviourClass}");
            }
        }
    }
    
    /// <summary>
    /// ç”¨äºå­˜å‚¨å¯¹è±¡è¡Œä¸ºå¼•ç”¨çš„ç»„ä»¶
    /// </summary>
    public class ObjectBehaviourComponent
    {
        public IObjectBehaviour Behaviour { get; set; }
    }
}
```

### é€šä¿¡ç³»ç»Ÿ

#### 1. äº‹ä»¶æ€»çº¿å®ç° ğŸŸ¢

```csharp
// ModSystem.Core/EventSystem/ModEventBus.cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace ModSystem.Core
{
    public interface IEventLogger
    {
        void LogEvent(IModEvent e);
        void LogSubscription(string eventType, string subscriber);
        void LogError(string message);
    }
    
    public class ModEventBus : IEventBus
    {
        private readonly Dictionary<Type, List<EventHandler>> handlers;
        private readonly object lockObject = new object();
        private readonly IEventLogger logger;
        
        public event Action<IModEvent> OnEventPublished;
        
        private class EventHandler
        {
            public Delegate Handler { get; set; }
            public Predicate<IModEvent> Filter { get; set; }
            public string SubscriberId { get; set; }
            public WeakReference TargetRef { get; set; }
        }
        
        public ModEventBus(IEventLogger logger = null)
        {
            handlers = new Dictionary<Type, List<EventHandler>>();
            this.logger = logger;
        }
        
        public void Subscribe<T>(Action<T> handler) where T : IModEvent
        {
            Subscribe(handler, null);
        }
        
        public void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                {
                    handlers[eventType] = new List<EventHandler>();
                }
                
                handlers[eventType].Add(new EventHandler
                {
                    Handler = handler,
                    Filter = filter != null ? e => filter((T)e) : null,
                    SubscriberId = handler.Target?.GetType().Name ?? "Anonymous",
                    TargetRef = handler.Target != null ? new WeakReference(handler.Target) : null
                });
                
                logger?.LogSubscription(eventType.Name, handler.Target?.GetType().Name);
            }
        }
        
        public void Publish<T>(T eventData) where T : IModEvent
        {
            if (eventData == null) return;
            
            eventData.Timestamp = DateTime.Now;
            logger?.LogEvent(eventData);
            OnEventPublished?.Invoke(eventData);
            
            List<EventHandler> eventHandlers;
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                // æ¸…ç†å·²é‡Šæ”¾çš„å¤„ç†å™¨
                handlers[eventType].RemoveAll(h => 
                    h.TargetRef != null && !h.TargetRef.IsAlive);
                
                eventHandlers = handlers[eventType].ToList();
            }
            
            foreach (var handler in eventHandlers)
            {
                try
                {
                    if (handler.Filter != null && !handler.Filter(eventData))
                        continue;
                    
                    ((Action<T>)handler.Handler)?.Invoke(eventData);
                }
                catch (Exception ex)
                {
                    logger?.LogError($"Handler error for {typeof(T).Name}: {ex.Message}");
                }
            }
        }
        
        public void Unsubscribe<T>(Action<T> handler) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                handlers[eventType].RemoveAll(h => h.Handler.Equals(handler));
                
                if (handlers[eventType].Count == 0)
                    handlers.Remove(eventType);
            }
        }
        
        public void UnsubscribeAll(object subscriber)
        {
            lock (lockObject)
            {
                foreach (var handlerList in handlers.Values)
                {
                    handlerList.RemoveAll(h => 
                        h.TargetRef != null && 
                        h.TargetRef.IsAlive && 
                        h.TargetRef.Target == subscriber);
                }
                
                // æ¸…ç†ç©ºåˆ—è¡¨
                var emptyKeys = handlers.Where(kvp => kvp.Value.Count == 0)
                    .Select(kvp => kvp.Key).ToList();
                foreach (var key in emptyKeys)
                {
                    handlers.Remove(key);
                }
            }
        }
    }
}
```

### æ¨¡æ¿ç¤ºä¾‹ ğŸŸ¡

#### æŒ‰é’®æ¨¡ç»„æ¨¡æ¿

```json
// Templates/BuiltIn/ButtonMod/template.json
{
  "id": "button_mod_template",
  "name": "æŒ‰é’®æ¨¡ç»„æ¨¡æ¿",
  "description": "åˆ›å»ºä¸€ä¸ªå¯äº¤äº’çš„æŒ‰é’®æ¨¡ç»„",
  "version": "1.0.0",
  "variables": [
    {
      "name": "ButtonType",
      "description": "æŒ‰é’®ç±»å‹ (toggle/momentary/hold)",
      "type": "string",
      "defaultValue": "toggle",
      "required": false
    }
  ],
  "files": [
    {
      "template": "Source/ButtonBehaviour.cs.template",
      "output": "Source/{{PascalCase ModId}}Behaviour.cs"
    },
    {
      "template": "Config/config.json.template",
      "output": "Config/config.json"
    },
    {
      "template": "Objects/button.json.template",
      "output": "Objects/{{ModId}}_button.json"
    },
    {
      "template": "manifest.json.template",
      "output": "manifest.json"
    },
    {
      "template": "README.md.template",
      "output": "README.md"
    },
    {
      "template": "ModProject.csproj.template",
      "output": "{{PascalCase ModId}}.csproj"
    }
  ],
  "directories": [
    "Models",
    "Resources/Textures",
    "Resources/Audio"
  ]
}
```

#### æŒ‰é’®è¡Œä¸ºæ¨¡æ¿æ–‡ä»¶

```csharp
// Templates/BuiltIn/ButtonMod/Source/ButtonBehaviour.cs.template
using System;
using System.Collections.Generic;
using ModSystem.Core;

namespace {{PascalCase ModId}}
{
    public class {{PascalCase ModId}}Behaviour : IModBehaviour
    {
        public string BehaviourId => "{{ModId}}_behaviour";
        public string Version => "1.0.0";
        
        private IModContext context;
        private ButtonConfiguration config;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            config = LoadConfiguration();
            
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            context.Log($"{{ModName}} initialized");
        }
        
        private void OnInteraction(InteractionEvent e)
        {
            if (e.TargetId != context.GameObject.Name)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {
                OnButtonClick();
            }
        }
        
        private void OnButtonClick()
        {
            var buttonEvent = new ButtonPressedEvent
            {
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                ButtonType = "{{ButtonType}}",
                Parameters = config.ActionParameters
            };
            
            context.EventBus.Publish(buttonEvent);
            context.Log($"Button {config.ButtonId} clicked");
        }
        
        public void OnUpdate(float deltaTime) { }
        
        public void OnDestroy() 
        {
            context.Log($"{{ModName}} destroyed");
        }
        
        private ButtonConfiguration LoadConfiguration()
        {
            // TODO: ä»é…ç½®æ–‡ä»¶åŠ è½½
            return new ButtonConfiguration
            {
                ButtonId = "{{ModId}}_btn_01",
                ButtonType = ButtonType.{{ButtonType}},
                ActionParameters = new Dictionary<string, object>()
            };
        }
    }
    
    public class ButtonConfiguration
    {
        public string ButtonId { get; set; }
        public ButtonType ButtonType { get; set; }
        public Dictionary<string, object> ActionParameters { get; set; }
    }
    
    public enum ButtonType
    {
        Toggle,
        Momentary,
        Hold
    }
    
    public class ButtonPressedEvent : IModEvent
    {
        public string EventId => "button_pressed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
}
```

### å¼€å‘æµç¨‹ç¤ºä¾‹

#### 1. åˆ›å»ºæ–°æ¨¡ç»„

```bash
# äº¤äº’å¼åˆ›å»º
ModBuilder

# é€‰æ‹©æ¨¡æ¿å¹¶å¡«å†™ä¿¡æ¯
# 1. åˆ›å»ºæ–°æ¨¡ç»„é¡¹ç›®
# é€‰æ‹©æ¨¡æ¿: 1 (æŒ‰é’®æ¨¡ç»„æ¨¡æ¿)
# æ¨¡ç»„ID: my_smart_button
# æ¨¡ç»„åç§°: æ™ºèƒ½æŒ‰é’®
# ä½œè€…åç§°: John Doe
# æŒ‰é’®ç±»å‹: toggle
```

#### 2. ç¼–è¾‘æ¨¡ç»„ä»£ç 

```csharp
// my_smart_button/Source/MySmartButtonBehaviour.cs
using ModSystem.Core;

namespace MySmartButton
{
    public class MySmartButtonBehaviour : IModBehaviour
    {
        // è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç ...
        
        // æ·»åŠ è‡ªå®šä¹‰åŠŸèƒ½
        private void OnButtonClick()
        {
            // æ·»åŠ æ™ºèƒ½é€»è¾‘
            if (IsSmartConditionMet())
            {
                PublishSmartEvent();
            }
            
            base.OnButtonClick();
        }
    }
}
```

#### 3. æ„å»ºå’Œæ‰“åŒ…

```bash
# æ„å»ºæ¨¡ç»„
cd my_smart_button
ModBuilder build

# æ‰“åŒ…ä¸º.modpackæ–‡ä»¶
ModBuilder package

# è¾“å‡º: my_smart_button_v1.0.0.modpack
```

## éƒ¨ç½²å’Œå®‰è£…

### Unityé¡¹ç›®é›†æˆ

#### 1. è®¾ç½®Unityé¡¹ç›®ç»“æ„

```bash
UnityProject/
â”œâ”€â”€ Assets/
â”‚   â””â”€â”€ ModSystem/
â”‚       â”œâ”€â”€ Core/
â”‚       â”‚   â””â”€â”€ Assemblies/
â”‚       â”‚       â”œâ”€â”€ ModSystem.Core.dll     # ä»ç‹¬ç«‹é¡¹ç›®å¤åˆ¶
â”‚       â”‚       â””â”€â”€ Newtonsoft.Json.dll
â”‚       â”œâ”€â”€ Unity/
â”‚       â”‚   â”œâ”€â”€ ModSystemController.cs
â”‚       â”‚   â”œâ”€â”€ ModManager.cs
â”‚       â”‚   â””â”€â”€ UnityImplementations/
â”‚       â””â”€â”€ Editor/
â”‚           â””â”€â”€ ModSystemMenu.cs
â””â”€â”€ StreamingAssets/
    â”œâ”€â”€ ModConfigs/
    â”œâ”€â”€ Mods/                              # å¼€å‘ä¸­çš„æ¨¡ç»„
    â””â”€â”€ ModPackages/                       # å‘å¸ƒçš„æ¨¡ç»„åŒ…
```

#### 2. Unityç¼–è¾‘å™¨èœå• ğŸ”µ

```csharp
// ModSystem.Unity/Editor/ModSystemMenu.cs
using UnityEngine;
using UnityEditor;
using System.IO;

namespace ModSystem.Unity.Editor
{
    public class ModSystemMenu
    {
        [MenuItem("ModSystem/Setup Project")]
        public static void SetupProject()
        {
            Debug.Log("Setting up ModSystem...");
            
            // åˆ›å»ºå¿…è¦çš„ç›®å½•
            CreateDirectories();
            
            // åˆ›å»ºModSystemController
            CreateModSystemController();
            
            // åˆ›å»ºå±‚çº§
            CreateLayers();
            
            Debug.Log("ModSystem setup complete!");
        }
        
        [MenuItem("ModSystem/Import Core DLL")]
        public static void ImportCoreDLL()
        {
            var path = EditorUtility.OpenFilePanel("Select ModSystem.Core.dll", "", "dll");
            if (!string.IsNullOrEmpty(path))
            {
                var destPath = "Assets/ModSystem/Core/Assemblies/ModSystem.Core.dll";
                File.Copy(path, destPath, true);
                AssetDatabase.Refresh();
                Debug.Log("Core DLL imported successfully!");
            }
        }
        
        [MenuItem("ModSystem/Create Test Mod")]
        public static void CreateTestMod()
        {
            var modPath = Path.Combine(Application.streamingAssetsPath, "Mods/TestMod");
            Directory.CreateDirectory(modPath);
            
            // åˆ›å»ºåŸºæœ¬ç»“æ„
            Directory.CreateDirectory(Path.Combine(modPath, "Source"));
            Directory.CreateDirectory(Path.Combine(modPath, "Config"));
            Directory.CreateDirectory(Path.Combine(modPath, "Objects"));
            
            // åˆ›å»ºmanifest.json
            var manifest = @"{
  ""id"": ""test_mod"",
  ""name"": ""Test Mod"",
  ""version"": ""1.0.0"",
  ""author"": ""Developer"",
  ""main_class"": ""TestMod.TestBehaviour"",
  ""permissions"": [""event_publish"", ""event_subscribe""]
}";
            File.WriteAllText(Path.Combine(modPath, "manifest.json"), manifest);
            
            AssetDatabase.Refresh();
            Debug.Log("Test mod created!");
        }
        
        [MenuItem("ModSystem/Open Event Monitor")]
        public static void OpenEventMonitor()
        {
            var monitor = GameObject.FindObjectOfType<Debug.EventMonitor>();
            if (monitor == null)
            {
                var go = new GameObject("EventMonitor");
                monitor = go.AddComponent<Debug.EventMonitor>();
            }
            
            Selection.activeGameObject = monitor.gameObject;
            Debug.Log("Event Monitor opened!");
        }
        
        private static void CreateDirectories()
        {
            var dirs = new[]
            {
                "Assets/ModSystem/Core/Assemblies",
                "Assets/ModSystem/Unity",
                "Assets/ModSystem/Unity/UnityImplementations",
                "Assets/ModSystem/Examples",
                "Assets/StreamingAssets/ModConfigs",
                "Assets/StreamingAssets/Mods",
                "Assets/StreamingAssets/ModPackages"
            };
            
            foreach (var dir in dirs)
            {
                Directory.CreateDirectory(dir);
            }
        }
        
        private static void CreateModSystemController()
        {
            var existing = GameObject.FindObjectOfType<ModSystemController>();
            if (existing == null)
            {
                var go = new GameObject("ModSystemController");
                go.AddComponent<ModSystemController>();
                Debug.Log("ModSystemController created!");
            }
        }
        
        private static void CreateLayers()
        {
            // åˆ›å»ºInteractableå±‚
            CreateLayer("Interactable", 10);
            CreateLayer("ModObjects", 11);
        }
        
        private static void CreateLayer(string name, int layer)
        {
            var tagManager = new SerializedObject(
                AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]
            );
            var layers = tagManager.FindProperty("layers");
            
            if (layers.GetArrayElementAtIndex(layer).stringValue == "")
            {
                layers.GetArrayElementAtIndex(layer).stringValue = name;
                tagManager.ApplyModifiedProperties();
                Debug.Log($"Layer '{name}' created at index {layer}");
            }
        }
    }
}
```

### æ¨¡ç»„å®‰è£…æ–¹å¼

#### 1. å¼€å‘æ¨¡å¼å®‰è£…

```bash
# å°†æ¨¡ç»„æ–‡ä»¶å¤¹å¤åˆ¶åˆ°StreamingAssets/Mods/
UnityProject/Assets/StreamingAssets/Mods/
â”œâ”€â”€ ButtonMod/
â”‚   â”œâ”€â”€ manifest.json
â”‚   â”œâ”€â”€ Source/
â”‚   â””â”€â”€ Config/
â””â”€â”€ RobotMod/
    â”œâ”€â”€ manifest.json
    â”œâ”€â”€ Source/
    â””â”€â”€ Config/
```

#### 2. å‘å¸ƒæ¨¡å¼å®‰è£…

```bash
# å°†.modpackæ–‡ä»¶å¤åˆ¶åˆ°StreamingAssets/ModPackages/
UnityProject/Assets/StreamingAssets/ModPackages/
â”œâ”€â”€ button_mod_v1.0.0.modpack
â”œâ”€â”€ robot_mod_v2.0.0.modpack
â””â”€â”€ sensor_mod_v1.5.0.modpack
```

#### 3. è¿è¡Œæ—¶å®‰è£…

```csharp
// åœ¨æ¸¸æˆè¿è¡Œæ—¶å®‰è£…æ¨¡ç»„
public class ModInstaller : MonoBehaviour
{
    public async void InstallModFromFile(string modpackPath)
    {
        try
        {
            var modManager = GetComponent<ModManager>();
            var success = await modManager.LoadModPackage(modpackPath);
            
            if (success)
            {
                Debug.Log($"Mod installed successfully from {modpackPath}");
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"Failed to install mod: {ex.Message}");
        }
    }
}
```

## è°ƒè¯•å’Œä¼˜åŒ–

### æ€§èƒ½åˆ†æå·¥å…· ğŸ”µ

```csharp
// ModSystem.Unity/Debug/ModPerformanceProfiler.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UnityEngine;

namespace ModSystem.Unity.Debug
{
    public class ModPerformanceProfiler : MonoBehaviour
    {
        private static ModPerformanceProfiler instance;
        private Dictionary<string, ProfileData> profileData = new Dictionary<string, ProfileData>();
        private Dictionary<string, Stopwatch> activeTimers = new Dictionary<string, Stopwatch>();
        
        public static ModPerformanceProfiler Instance
        {
            get
            {
                if (instance == null)
                {
                    var go = new GameObject("ModPerformanceProfiler");
                    instance = go.AddComponent<ModPerformanceProfiler>();
                    DontDestroyOnLoad(go);
                }
                return instance;
            }
        }
        
        public class ProfileData
        {
            public string Name { get; set; }
            public int CallCount { get; set; }
            public double TotalTime { get; set; }
            public double MinTime { get; set; } = double.MaxValue;
            public double MaxTime { get; set; } = double.MinValue;
            public double AverageTime => CallCount > 0 ? TotalTime / CallCount : 0;
            public double LastTime { get; set; }
            public Queue<double> RecentTimes { get; set; } = new Queue<double>();
        }
        
        public void BeginSample(string name)
        {
            if (!profileData.ContainsKey(name))
            {
                profileData[name] = new ProfileData { Name = name };
            }
            
            var sw = Stopwatch.StartNew();
            activeTimers[name] = sw;
        }
        
        public void EndSample(string name)
        {
            if (activeTimers.TryGetValue(name, out var sw))
            {
                sw.Stop();
                var elapsed = sw.Elapsed.TotalMilliseconds;
                
                var data = profileData[name];
                data.CallCount++;
                data.TotalTime += elapsed;
                data.LastTime = elapsed;
                data.MinTime = Math.Min(data.MinTime, elapsed);
                data.MaxTime = Math.Max(data.MaxTime, elapsed);
                
                // ä¿ç•™æœ€è¿‘100æ¬¡çš„æ—¶é—´
                data.RecentTimes.Enqueue(elapsed);
                if (data.RecentTimes.Count > 100)
                    data.RecentTimes.Dequeue();
                
                activeTimers.Remove(name);
            }
        }
        
        public ProfileScope BeginScope(string name)
        {
            return new ProfileScope(this, name);
        }
        
        public class ProfileScope : IDisposable
        {
            private readonly ModPerformanceProfiler profiler;
            private readonly string name;
            
            public ProfileScope(ModPerformanceProfiler profiler, string name)
            {
                this.profiler = profiler;
                this.name = name;
                profiler.BeginSample(name);
            }
            
            public void Dispose()
            {
                profiler.EndSample(name);
            }
        }
        
        // GUIæ˜¾ç¤º
        private bool showWindow = false;
        private Vector2 scrollPosition;
        private SortMode sortMode = SortMode.TotalTime;
        private string filterText = "";
        
        private enum SortMode
        {
            Name,
            CallCount,
            TotalTime,
            AverageTime,
            LastTime
        }
        
        void Update()
        {
            if (Input.GetKeyDown(KeyCode.F10))
            {
                showWindow = !showWindow;
            }
        }
        
        void OnGUI()
        {
            if (!showWindow) return;
            
            var rect = new Rect(10, 10, 800, 600);
            GUI.Window(1, rect, DrawProfilerWindow, "Mod Performance Profiler");
        }
        
        void DrawProfilerWindow(int windowId)
        {
            GUILayout.BeginVertical();
            
            // å·¥å…·æ 
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Button("Clear", GUILayout.Width(60)))
            {
                profileData.Clear();
                activeTimers.Clear();
            }
            
            if (GUILayout.Button("Export", GUILayout.Width(60)))
            {
                ExportReport();
            }
            
            GUILayout.Space(20);
            
            GUILayout.Label("Filter:", GUILayout.Width(50));
            filterText = GUILayout.TextField(filterText, GUILayout.Width(200));
            
            GUILayout.FlexibleSpace();
            
            GUILayout.Label($"Samples: {profileData.Count}");
            
            GUILayout.EndHorizontal();
            
            // æ’åºæŒ‰é’®
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Toggle(sortMode == SortMode.Name, "Name", "Button"))
                sortMode = SortMode.Name;
            
            if (GUILayout.Toggle(sortMode == SortMode.CallCount, "Calls", "Button"))
                sortMode = SortMode.CallCount;
            
            if (GUILayout.Toggle(sortMode == SortMode.TotalTime, "Total (ms)", "Button"))
                sortMode = SortMode.TotalTime;
            
            if (GUILayout.Toggle(sortMode == SortMode.AverageTime, "Avg (ms)", "Button"))
                sortMode = SortMode.AverageTime;
            
            if (GUILayout.Toggle(sortMode == SortMode.LastTime, "Last (ms)", "Button"))
                sortMode = SortMode.LastTime;
            
            GUILayout.EndHorizontal();
            
            // æ•°æ®åˆ—è¡¨
            scrollPosition = GUILayout.BeginScrollView(scrollPosition);
            
            var sortedData = GetSortedData();
            
            foreach (var data in sortedData)
            {
                DrawProfileEntry(data);
            }
            
            GUILayout.EndScrollView();
            
            // ç»Ÿè®¡ä¿¡æ¯
            DrawStatistics();
            
            GUILayout.EndVertical();
            
            GUI.DragWindow();
        }
        
        private IEnumerable<ProfileData> GetSortedData()
        {
            var filtered = profileData.Values.AsEnumerable();
            
            if (!string.IsNullOrEmpty(filterText))
            {
                filtered = filtered.Where(d => d.Name.ToLower().Contains(filterText.ToLower()));
            }
            
            return sortMode switch
            {
                SortMode.Name => filtered.OrderBy(d => d.Name),
                SortMode.CallCount => filtered.OrderByDescending(d => d.CallCount),
                SortMode.TotalTime => filtered.OrderByDescending(d => d.TotalTime),
                SortMode.AverageTime => filtered.OrderByDescending(d => d.AverageTime),
                SortMode.LastTime => filtered.OrderByDescending(d => d.LastTime),
                _ => filtered
            };
        }
        
        private void DrawProfileEntry(ProfileData data)
        {
            GUILayout.BeginHorizontal("box");
            
            // æ€§èƒ½æŒ‡ç¤ºå™¨é¢œè‰²
            var avgTime = data.AverageTime;
            GUI.color = avgTime > 16 ? Color.red :
                       avgTime > 8 ? Color.yellow :
                       Color.green;
            
            GUILayout.Label("â—", GUILayout.Width(20));
            GUI.color = Color.white;
            
            GUILayout.Label(data.Name, GUILayout.Width(300));
            GUILayout.Label(data.CallCount.ToString(), GUILayout.Width(60));
            GUILayout.Label($"{data.TotalTime:F2}", GUILayout.Width(80));
            GUILayout.Label($"{data.AverageTime:F2}", GUILayout.Width(80));
            GUILayout.Label($"{data.MinTime:F2}", GUILayout.Width(60));
            GUILayout.Label($"{data.MaxTime:F2}", GUILayout.Width(60));
            GUILayout.Label($"{data.LastTime:F2}", GUILayout.Width(60));
            
            // è¿·ä½ å›¾
            if (data.RecentTimes.Count > 0)
            {
                DrawMiniGraph(data.RecentTimes.ToArray(), 100, 20);
            }
            
            GUILayout.EndHorizontal();
        }
        
        private void DrawMiniGraph(double[] values, float width, float height)
        {
            var rect = GUILayoutUtility.GetRect(width, height);
            
            if (values.Length < 2) return;
            
            var max = values.Max();
            var min = values.Min();
            var range = max - min;
            
            if (range < 0.001) range = 1;
            
            var points = new Vector3[values.Length];
            for (int i = 0; i < values.Length; i++)
            {
                var x = rect.x + (i / (float)(values.Length - 1)) * rect.width;
                var y = rect.y + rect.height - ((float)((values[i] - min) / range)) * rect.height;
                points[i] = new Vector3(x, y, 0);
            }
            
            // ç®€å•çš„çº¿æ¡ç»˜åˆ¶
            Handles.color = Color.cyan;
            Handles.DrawAAPolyLine(2f, points);
        }
        
        private void DrawStatistics()
        {
            GUILayout.BeginHorizontal("box");
            
            var totalTime = profileData.Values.Sum(d => d.TotalTime);
            var totalCalls = profileData.Values.Sum(d => d.CallCount);
            
            GUILayout.Label($"Total Time: {totalTime:F2} ms");
            GUILayout.Label($"Total Calls: {totalCalls}");
            GUILayout.Label($"Active Timers: {activeTimers.Count}");
            
            GUILayout.EndHorizontal();
        }
        
        private void ExportReport()
        {
            var report = "Mod Performance Report\n";
            report += $"Generated: {DateTime.Now}\n\n";
            report += "Name\tCalls\tTotal(ms)\tAvg(ms)\tMin(ms)\tMax(ms)\n";
            
            foreach (var data in GetSortedData())
            {
                report += $"{data.Name}\t{data.CallCount}\t{data.TotalTime:F2}\t";
                report += $"{data.AverageTime:F2}\t{data.MinTime:F2}\t{data.MaxTime:F2}\n";
            }
            
            var path = Path.Combine(Application.persistentDataPath, 
                $"ModPerformance_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            
            File.WriteAllText(path, report);
            UnityEngine.Debug.Log($"Performance report exported to: {path}");
        }
    }
    
    // ä½¿ç”¨ç¤ºä¾‹
    public static class ProfilerExtensions
    {
        public static void ProfileMethod(this IModBehaviour behaviour, string methodName, Action action)
        {
            using (ModPerformanceProfiler.Instance.BeginScope($"{behaviour.BehaviourId}.{methodName}"))
            {
                action();
            }
        }
        
        public static async Task ProfileMethodAsync(this IModBehaviour behaviour, string methodName, Func<Task> action)
        {
            using (ModPerformanceProfiler.Instance.BeginScope($"{behaviour.BehaviourId}.{methodName}"))
            {
                await action();
            }
        }
    }
}
```

### å†…å­˜ç›‘æ§ ğŸ”µ

```csharp
// ModSystem.Unity/Debug/ModMemoryMonitor.cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Profiling;

namespace ModSystem.Unity.Debug
{
    public class ModMemoryMonitor : MonoBehaviour
    {
        private Dictionary<string, MemoryStats> modMemoryStats = new Dictionary<string, MemoryStats>();
        private float updateInterval = 1f;
        private float lastUpdateTime;
        
        public class MemoryStats
        {
            public long TotalAllocated { get; set; }
            public long CurrentUsage { get; set; }
            public int ObjectCount { get; set; }
            public int TextureMemory { get; set; }
            public int MeshMemory { get; set; }
            public List<float> UsageHistory { get; set; } = new List<float>();
        }
        
        void Start()
        {
            InvokeRepeating(nameof(UpdateMemoryStats), 1f, updateInterval);
        }
        
        void UpdateMemoryStats()
        {
            var modManager = FindObjectOfType<ModManager>();
            if (modManager == null) return;
            
            foreach (var modInstance in modManager.GetLoadedMods())
            {
                var stats = GetOrCreateStats(modInstance.ModId);
                
                // æ›´æ–°å¯¹è±¡è®¡æ•°
                stats.ObjectCount = modInstance.GameObjects.Count;
                
                // è®¡ç®—çº¹ç†å†…å­˜
                stats.TextureMemory = CalculateTextureMemory(modInstance);
                
                // è®¡ç®—ç½‘æ ¼å†…å­˜
                stats.MeshMemory = CalculateMeshMemory(modInstance);
                
                // æ›´æ–°ä½¿ç”¨å†å²
                stats.UsageHistory.Add(stats.CurrentUsage / 1024f / 1024f); // MB
                if (stats.UsageHistory.Count > 60) // ä¿ç•™60ç§’å†å²
                    stats.UsageHistory.RemoveAt(0);
            }
        }
        
        private MemoryStats GetOrCreateStats(string modId)
        {
            if (!modMemoryStats.ContainsKey(modId))
            {
                modMemoryStats[modId] = new MemoryStats();
            }
            return modMemoryStats[modId];
        }
        
        private int CalculateTextureMemory(ModUnityInstance instance)
        {
            int totalMemory = 0;
            
            foreach (var obj in instance.GameObjects)
            {
                if (obj == null) continue;
                
                var renderers = obj.GetComponentsInChildren<Renderer>();
                foreach (var renderer in renderers)
                {
                    if (renderer.sharedMaterial != null && renderer.sharedMaterial.mainTexture != null)
                    {
                        totalMemory += Profiler.GetRuntimeMemorySizeLong(renderer.sharedMaterial.mainTexture);
                    }
                }
            }
            
            return totalMemory;
        }
        
        private int CalculateMeshMemory(ModUnityInstance instance)
        {
            int totalMemory = 0;
            
            foreach (var obj in instance.GameObjects)
            {
                if (obj == null) continue;
                
                var meshFilters = obj.GetComponentsInChildren<MeshFilter>();
                foreach (var meshFilter in meshFilters)
                {
                    if (meshFilter.sharedMesh != null)
                    {
                        totalMemory += Profiler.GetRuntimeMemorySizeLong(meshFilter.sharedMesh);
                    }
                }
            }
            
            return totalMemory;
        }
        
        // GUIæ˜¾ç¤º
        void OnGUI()
        {
            if (!Input.GetKey(KeyCode.LeftShift)) return;
            
            var rect = new Rect(Screen.width - 310, 10, 300, 400);
            GUI.Box(rect, "Mod Memory Usage");
            
            GUILayout.BeginArea(new Rect(rect.x + 10, rect.y + 30, rect.width - 20, rect.height - 40));
            
            foreach (var kvp in modMemoryStats)
            {
                DrawModMemoryInfo(kvp.Key, kvp.Value);
            }
            
            GUILayout.EndArea();
        }
        
        private void DrawModMemoryInfo(string modId, MemoryStats stats)
        {
            GUILayout.BeginVertical("box");
            
            GUILayout.Label($"<b>{modId}</b>", GetRichTextStyle());
            GUILayout.Label($"Objects: {stats.ObjectCount}");
            GUILayout.Label($"Textures: {stats.TextureMemory / 1024 / 1024:F2} MB");
            GUILayout.Label($"Meshes: {stats.MeshMemory / 1024 / 1024:F2} MB");
            
            // ç»˜åˆ¶å†…å­˜ä½¿ç”¨è¶‹åŠ¿
            if (stats.UsageHistory.Count > 1)
            {
                DrawMemoryGraph(stats.UsageHistory, 280, 50);
            }
            
            GUILayout.EndVertical();
        }
        
        private void DrawMemoryGraph(List<float> values, float width, float height)
        {
            // ç®€åŒ–çš„å†…å­˜ä½¿ç”¨å›¾è¡¨ç»˜åˆ¶
            var rect = GUILayoutUtility.GetRect(width, height);
            GUI.Box(rect, "");
            
            if (values.Count < 2) return;
            
            var max = Mathf.Max(values.ToArray());
            if (max < 0.1f) max = 0.1f;
            
            for (int i = 1; i < values.Count; i++)
            {
                var x1 = rect.x + ((i - 1) / (float)(values.Count - 1)) * rect.width;
                var y1 = rect.y + rect.height - (values[i - 1] / max) * rect.height;
                
                var x2 = rect.x + (i / (float)(values.Count - 1)) * rect.width;
                var y2 = rect.y + rect.height - (values[i] / max) * rect.height;
                
                DrawLine(new Vector2(x1, y1), new Vector2(x2, y2), Color.green);
            }
        }
        
        private void DrawLine(Vector2 start, Vector2 end, Color color)
        {
            var originalColor = GUI.color;
            GUI.color = color;
            
            var angle = Mathf.Atan2(end.y - start.y, end.x - start.x) * 180f / Mathf.PI;
            var length = Vector2.Distance(start, end);
            
            GUIUtility.RotateAroundPivot(angle, start);
            GUI.DrawTexture(new Rect(start.x, start.y - 1, length, 2), Texture2D.whiteTexture);
            GUIUtility.RotateAroundPivot(-angle, start);
            
            GUI.color = originalColor;
        }
        
        private GUIStyle GetRichTextStyle()
        {
            var style = new GUIStyle(GUI.skin.label);
            style.richText = true;
            return style;
        }
    }
}
```

### å¸¸è§é—®é¢˜æ’æŸ¥

#### 1. æ¨¡ç»„åŠ è½½å¤±è´¥

```csharp
// è¯Šæ–­å·¥å…·
public class ModDiagnostics
{
    public static void DiagnoseModLoadFailure(string modPath, ILogger logger)
    {
        logger.Log($"=== æ¨¡ç»„åŠ è½½è¯Šæ–­ ===");
        logger.Log($"æ¨¡ç»„è·¯å¾„: {modPath}");
        
        // æ£€æŸ¥è·¯å¾„å­˜åœ¨æ€§
        if (!Directory.Exists(modPath))
        {
            logger.LogError("âœ— æ¨¡ç»„ç›®å½•ä¸å­˜åœ¨");
            return;
        }
        logger.Log("âœ“ æ¨¡ç»„ç›®å½•å­˜åœ¨");
        
        // æ£€æŸ¥manifest.json
        var manifestPath = Path.Combine(modPath, "manifest.json");
        if (!File.Exists(manifestPath))
        {
            logger.LogError("âœ— manifest.json æ–‡ä»¶ä¸å­˜åœ¨");
            return;
        }
        logger.Log("âœ“ manifest.json æ–‡ä»¶å­˜åœ¨");
        
        // éªŒè¯JSONæ ¼å¼
        try
        {
            var json = File.ReadAllText(manifestPath);
            var manifest = JsonSerializer.Deserialize<ModManifest>(json);
            logger.Log("âœ“ manifest.json æ ¼å¼æ­£ç¡®");
            
            // æ£€æŸ¥å¿…è¦å­—æ®µ
            if (string.IsNullOrEmpty(manifest.id))
                logger.LogError("âœ— ç¼ºå°‘æ¨¡ç»„ID");
            if (string.IsNullOrEmpty(manifest.name))
                logger.LogError("âœ— ç¼ºå°‘æ¨¡ç»„åç§°");
            if (string.IsNullOrEmpty(manifest.version))
                logger.LogError("âœ— ç¼ºå°‘ç‰ˆæœ¬å·");
        }
        catch (Exception ex)
        {
            logger.LogError($"âœ— manifest.json è§£æå¤±è´¥: {ex.Message}");
        }
        
        // æ£€æŸ¥DLLæ–‡ä»¶
        var dllPath = Path.Combine(modPath, "Assemblies", "*.dll");
        var dlls = Directory.GetFiles(Path.Combine(modPath, "Assemblies"), "*.dll");
        if (dlls.Length == 0)
        {
            logger.LogWarning("! æ²¡æœ‰æ‰¾åˆ°DLLæ–‡ä»¶");
        }
        else
        {
            logger.Log($"âœ“ æ‰¾åˆ° {dlls.Length} ä¸ªDLLæ–‡ä»¶");
            foreach (var dll in dlls)
            {
                logger.Log($"  - {Path.GetFileName(dll)}");
            }
        }
        
        // æ£€æŸ¥ä¾èµ–
        // ... æ›´å¤šè¯Šæ–­é€»è¾‘
    }
}
```

#### 2. äº‹ä»¶æœªæ¥æ”¶

```csharp
// äº‹ä»¶è°ƒè¯•åŠ©æ‰‹
public static class EventDebugHelper
{
    public static void TraceEvent<T>(this IEventBus eventBus, string tag = "") where T : IModEvent
    {
        eventBus.Subscribe<T>(e =>
        {
            UnityEngine.Debug.Log($"[EventTrace{(string.IsNullOrEmpty(tag) ? "" : $"-{tag}")}] " +
                $"{typeof(T).Name} from {e.SenderId} at {e.Timestamp:HH:mm:ss.fff}");
        });
    }
    
    public static void LogSubscriptions(this ModEventBus eventBus)
    {
        var field = typeof(ModEventBus).GetField("handlers", 
            System.Reflection.BindingFlags.NonPublic | 
            System.Reflection.BindingFlags.Instance);
        
        if (field != null)
        {
            var handlers = field.GetValue(eventBus) as Dictionary<Type, object>;
            UnityEngine.Debug.Log("=== Current Event Subscriptions ===");
            foreach (var kvp in handlers)
            {
                UnityEngine.Debug.Log($"{kvp.Key.Name}: {(kvp.Value as IList)?.Count ?? 0} handlers");
            }
        }
    }
}
```

#### 3. æ€§èƒ½é—®é¢˜

```csharp
// æ€§èƒ½ä¼˜åŒ–å»ºè®®
public class PerformanceOptimizer
{
    public static void OptimizeModPerformance(IModBehaviour behaviour, IModContext context)
    {
        // 1. äº‹ä»¶èŠ‚æµ
        var throttledPublish = CreateThrottledAction<IModEvent>(
            e => context.EventBus.Publish(e),
            TimeSpan.FromMilliseconds(100)
        );
        
        // 2. å¯¹è±¡æ± 
        var objectPool = new ModObjectPool<GameObject>(
            () => new GameObject("PooledObject"),
            obj => obj.transform.position = Vector3.zero,
            maxSize: 50
        );
        
        // 3. æ‰¹å¤„ç†
        var batchProcessor = new BatchEventProcessor(context.EventBus);
        
        // 4. LODç³»ç»Ÿ
        EnableLODSystem(behaviour, context);
    }
    
    private static Action<T> CreateThrottledAction<T>(Action<T> action, TimeSpan delay)
    {
        var lastCall = DateTime.MinValue;
        return arg =>
        {
            var now = DateTime.Now;
            if (now - lastCall >= delay)
            {
                action(arg);
                lastCall = now;
            }
        };
    }
    
    private static void EnableLODSystem(IModBehaviour behaviour, IModContext context)
    {
        // åŸºäºè·ç¦»çš„ç»†èŠ‚çº§åˆ«è°ƒæ•´
        var camera = Camera.main;
        if (camera != null)
        {
            var distance = Vector3.Distance(
                camera.transform.position, 
                context.GameObject.Transform.Position
            );
            
            if (distance > 50)
            {
                // é™ä½æ›´æ–°é¢‘ç‡
                behaviour.SetUpdateRate(0.1f); // 10 FPS
            }
            else if (distance > 20)
            {
                behaviour.SetUpdateRate(0.033f); // 30 FPS
            }
            else
            {
                behaviour.SetUpdateRate(0.016f); // 60 FPS
            }
        }
    }
}
```

## æœ€ä½³å®è·µ

### 1. æ¨¡ç»„å¼€å‘è§„èŒƒ

#### å‘½åçº¦å®š

```csharp
// âœ“ å¥½çš„å‘½å
namespace MyCompany.MyModName
{
    public class MyModBehaviour : IModBehaviour { }
    public class MyModButtonPressedEvent : IModEvent { }
    public interface IMyModService : IModService { }
}

// âœ— é¿å…çš„å‘½å
namespace Mod1
{
    public class Behaviour : IModBehaviour { }  // å¤ªé€šç”¨
    public class Event1 : IModEvent { }         // æ— æ„ä¹‰
    public interface Service : IModService { }   // å¤ªé€šç”¨
}
```

#### èµ„æºç®¡ç†

```csharp
public class ResourceAwareModBehaviour : IModBehaviour
{
    private readonly List<IDisposable> disposables = new List<IDisposable>();
    private readonly List<Coroutine> coroutines = new List<Coroutine>();
    
    public void OnInitialize(IModContext context)
    {
        // è·Ÿè¸ªæ‰€æœ‰éœ€è¦æ¸…ç†çš„èµ„æº
        var timer = new Timer(Callback, null, 1000, 1000);
        disposables.Add(timer);
        
        // è·Ÿè¸ªåç¨‹
        var coroutine = context.API.Utilities.StartCoroutine(UpdateCoroutine());
        coroutines.Add(coroutine);
    }
    
    public void OnDestroy()
    {
        // æ¸…ç†æ‰€æœ‰èµ„æº
        foreach (var disposable in disposables)
        {
            disposable?.Dispose();
        }
        disposables.Clear();
        
        // åœæ­¢æ‰€æœ‰åç¨‹
        foreach (var coroutine in coroutines)
        {
            if (coroutine != null)
                context.API.Utilities.StopCoroutine(coroutine);
        }
        coroutines.Clear();
        
        // å–æ¶ˆæ‰€æœ‰äº‹ä»¶è®¢é˜…
        context.EventBus.UnsubscribeAll(this);
    }
}
```

#### é”™è¯¯å¤„ç†

```csharp
public class RobustModBehaviour : IModBehaviour
{
    private IModContext context;
    
    public void OnInitialize(IModContext context)
    {
        this.context = context;
        
        try
        {
            InitializeComponents();
        }
        catch (Exception ex)
        {
            context.LogError($"Failed to initialize components: {ex.Message}");
            // è¿›å…¥å®‰å…¨æ¨¡å¼
            EnterSafeMode();
        }
    }
    
    private void HandleEvent(ButtonPressedEvent e)
    {
        try
        {
            ProcessButtonPress(e);
        }
        catch (Exception ex)
        {
            context.LogError($"Error handling button press: {ex.Message}");
            
            // å‘é€é”™è¯¯äº‹ä»¶
            context.EventBus.Publish(new ModErrorEvent
            {
                SenderId = BehaviourId,
                ErrorType = "EventHandlingError",
                Message = ex.Message,
                StackTrace = ex.StackTrace
            });
        }
    }
    
    private void EnterSafeMode()
    {
        context.Log("Entering safe mode due to initialization failure");
        // ç¦ç”¨éå…³é”®åŠŸèƒ½
        // åªä¿ç•™åŸºæœ¬åŠŸèƒ½
    }
}
```

### 2. é€šä¿¡æ¨¡å¼é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæ¨¡å¼ | ç¤ºä¾‹ä»£ç  |
|------|----------|----------|
| ç®€å•é€šçŸ¥ | äº‹ä»¶æ¨¡å¼ | `eventBus.Publish(new StatusChangedEvent())` |
| éœ€è¦ç¡®è®¤ | è¯·æ±‚-å“åº” | `var response = await SendRequestAsync<Request, Response>()` |
| APIè°ƒç”¨ | æœåŠ¡æ¨¡å¼ | `service.ExecuteAction(parameters)` |
| å¤æ‚æµç¨‹ | é…ç½®é©±åŠ¨ | é€šè¿‡JSONé…ç½®å®šä¹‰è¡Œä¸º |

### 3. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

#### ä½¿ç”¨å¯¹è±¡æ± 

```csharp
public class PooledEffectSystem
{
    private readonly Dictionary<string, Queue<GameObject>> pools;
    private readonly Transform poolContainer;
    
    public GameObject GetEffect(string effectName)
    {
        if (!pools.ContainsKey(effectName))
        {
            pools[effectName] = new Queue<GameObject>();
        }
        
        var pool = pools[effectName];
        
        if (pool.Count > 0)
        {
            var effect = pool.Dequeue();
            effect.SetActive(true);
            return effect;
        }
        else
        {
            return CreateNewEffect(effectName);
        }
    }
    
    public void ReturnEffect(string effectName, GameObject effect)
    {
        effect.SetActive(false);
        effect.transform.SetParent(poolContainer);
        
        if (pools[effectName].Count < MaxPoolSize)
        {
            pools[effectName].Enqueue(effect);
        }
        else
        {
            GameObject.Destroy(effect);
        }
    }
}
```

#### äº‹ä»¶æ‰¹å¤„ç†

```csharp
public class BatchedEventPublisher
{
    private readonly IEventBus eventBus;
    private readonly Dictionary<Type, List<IModEvent>> pendingEvents;
    private float batchInterval = 0.1f;
    private float lastBatchTime;
    
    public void PublishBatched<T>(T eventData) where T : IModEvent
    {
        var type = typeof(T);
        if (!pendingEvents.ContainsKey(type))
        {
            pendingEvents[type] = new List<IModEvent>();
        }
        
        pendingEvents[type].Add(eventData);
    }
    
    public void ProcessBatches()
    {
        if (Time.time - lastBatchTime < batchInterval)
            return;
        
        foreach (var kvp in pendingEvents)
        {
            if (kvp.Value.Count > 0)
            {
                // å‘é€æ‰¹é‡äº‹ä»¶
                eventBus.Publish(new BatchedEvent
                {
                    EventType = kvp.Key.Name,
                    Events = kvp.Value.ToList()
                });
                
                kvp.Value.Clear();
            }
        }
        
        lastBatchTime = Time.time;
    }
}
```

### 4. å®‰å…¨ç¼–ç å®è·µ

```csharp
public class SecureModBehaviour : IModBehaviour
{
    private readonly HashSet<string> allowedCommands = new HashSet<string>
    {
        "move", "rotate", "scale", "activate", "deactivate"
    };
    
    public void ExecuteCommand(string command, Dictionary<string, object> parameters)
    {
        // éªŒè¯å‘½ä»¤
        if (!allowedCommands.Contains(command.ToLower()))
        {
            context.LogError($"Unauthorized command: {command}");
            return;
        }
        
        // éªŒè¯å‚æ•°
        if (!ValidateParameters(command, parameters))
        {
            context.LogError($"Invalid parameters for command: {command}");
            return;
        }
        
        // æ£€æŸ¥æƒé™
        if (!context.SecurityContext.HasPermission($"execute_{command}"))
        {
            context.LogError($"No permission to execute: {command}");
            return;
        }
        
        // æ‰§è¡Œå‘½ä»¤
        try
        {
            ExecuteSecureCommand(command, parameters);
        }
        catch (Exception ex)
        {
            context.LogError($"Command execution failed: {ex.Message}");
            LogSecurityEvent(command, parameters, ex);
        }
    }
    
    private bool ValidateParameters(string command, Dictionary<string, object> parameters)
    {
        // å®ç°å‚æ•°éªŒè¯é€»è¾‘
        switch (command)
        {
            case "move":
                return parameters.ContainsKey("position") && 
                       parameters["position"] is Vector3;
            case "rotate":
                return parameters.ContainsKey("rotation") && 
                       parameters["rotation"] is Quaternion;
            default:
                return true;
        }
    }
}
```

## å¸¸è§é—®é¢˜è§£ç­”

### å¼€å‘ç›¸å…³

**Q: æˆ‘éœ€è¦å®‰è£…Unityæ¥å¼€å‘æ¨¡ç»„å—ï¼Ÿ**  
A: ä¸éœ€è¦ã€‚ä½¿ç”¨ModSDKå¯ä»¥åœ¨Visual Studioä¸­ç‹¬ç«‹å¼€å‘æ¨¡ç»„ï¼Œåªéœ€è¦.NET SDKã€‚

**Q: æ”¯æŒå“ªäº›.NETç‰ˆæœ¬ï¼Ÿ**  
A: æ¨èä½¿ç”¨.NET Standard 2.1ï¼Œè¿™ä¸Unity 2021.3+å…¼å®¹ã€‚

**Q: å¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“å—ï¼Ÿ**  
A: å¯ä»¥ï¼Œä½†éœ€è¦ç¡®ä¿ï¼š
- åº“å…¼å®¹.NET Standard 2.1
- ä¸ä¾èµ–Unityç‰¹å®šåŠŸèƒ½
- åŒ…å«åœ¨æ¨¡ç»„åŒ…ä¸­
- ä¸ä¸å®‰å…¨ç­–ç•¥å†²çª

**Q: å¦‚ä½•è°ƒè¯•æ¨¡ç»„ï¼Ÿ**  
A: æœ‰å¤šç§æ–¹å¼ï¼š
1. ä½¿ç”¨Visual Studioé™„åŠ åˆ°Unityè¿›ç¨‹
2. ä½¿ç”¨å†…ç½®çš„EventMonitorå’Œæ€§èƒ½åˆ†æå™¨
3. åœ¨æ¨¡ç»„ä»£ç ä¸­æ·»åŠ æ—¥å¿—è¾“å‡º
4. ä½¿ç”¨æ¡ä»¶æ–­ç‚¹

### æ¶æ„ç›¸å…³

**Q: Coreå±‚å’ŒUnityå±‚çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**  
A: 
- **Coreå±‚**ï¼šå¹³å°æ— å…³çš„çº¯C#ä»£ç ï¼Œå¯åœ¨ä»»ä½•.NETç¯å¢ƒè¿è¡Œ
- **Unityå±‚**ï¼šä¾èµ–Unity APIçš„ä»£ç ï¼Œåªèƒ½åœ¨Unityä¸­è¿è¡Œ

**Q: ä¸ºä»€ä¹ˆè¦åˆ†ç¦»IModBehaviourå’ŒIObjectBehaviourï¼Ÿ**  
A: 
- **IModBehaviour**ï¼šä¸»æ¨¡ç»„é€»è¾‘ï¼Œç”±ModManagerç®¡ç†ç”Ÿå‘½å‘¨æœŸ
- **IObjectBehaviour**ï¼šé™„åŠ åˆ°æ¸¸æˆå¯¹è±¡çš„è¡Œä¸ºï¼Œç”±ObjectFactoryåˆ›å»º

**Q: äº‹ä»¶æ€»çº¿æ˜¯çº¿ç¨‹å®‰å…¨çš„å—ï¼Ÿ**  
A: æ˜¯çš„ï¼ŒModEventBusä½¿ç”¨é”æœºåˆ¶ç¡®ä¿çº¿ç¨‹å®‰å…¨ï¼Œä½†å»ºè®®ä¸»è¦åœ¨ä¸»çº¿ç¨‹ä½¿ç”¨ã€‚

### æ€§èƒ½ç›¸å…³

**Q: æ¨¡ç»„ä¼šå½±å“æ¸¸æˆæ€§èƒ½å—ï¼Ÿ**  
A: ä¼šæœ‰å½±å“ï¼Œä½†å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æœ€å°åŒ–ï¼š
- ä½¿ç”¨å¯¹è±¡æ± 
- æ‰¹å¤„ç†äº‹ä»¶
- åˆç†çš„æ›´æ–°é¢‘ç‡
- LODç³»ç»Ÿ
- èµ„æºé™åˆ¶

**Q: å¦‚ä½•å¤„ç†å¤§é‡äº‹ä»¶ï¼Ÿ**  
A: 
- ä½¿ç”¨äº‹ä»¶è¿‡æ»¤å‡å°‘ä¸å¿…è¦çš„å¤„ç†
- æ‰¹é‡å¤„ç†ç›¸ä¼¼äº‹ä»¶
- ä½¿ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—
- è€ƒè™‘ä½¿ç”¨ä¸“é—¨çš„é«˜æ€§èƒ½æ¶ˆæ¯ç³»ç»Ÿ

### å®‰å…¨ç›¸å…³

**Q: æ¨¡ç»„å¯ä»¥è®¿é—®æ–‡ä»¶ç³»ç»Ÿå—ï¼Ÿ**  
A: é»˜è®¤ä¸å…è®¸ã€‚éœ€è¦åœ¨manifestä¸­å£°æ˜file_accessæƒé™ï¼Œå¹¶ä¸”åªèƒ½è®¿é—®æŒ‡å®šç›®å½•ã€‚

**Q: å¦‚ä½•é˜²æ­¢æ¶æ„æ¨¡ç»„ï¼Ÿ**  
A: ç³»ç»Ÿæä¾›å¤šå±‚ä¿æŠ¤ï¼š
- ä»£ç ç­¾åéªŒè¯
- æƒé™ç³»ç»Ÿ
- APIé»‘åå•
- èµ„æºé™åˆ¶
- æ²™ç®±æ‰§è¡Œç¯å¢ƒ

### éƒ¨ç½²ç›¸å…³

**Q: .modpackæ–‡ä»¶æ˜¯ä»€ä¹ˆæ ¼å¼ï¼Ÿ**  
A: æ˜¯æ ‡å‡†çš„ZIPæ–‡ä»¶ï¼ŒåŒ…å«ï¼š
- manifest.json
- ç¼–è¯‘çš„DLLæ–‡ä»¶
- èµ„æºæ–‡ä»¶
- é…ç½®æ–‡ä»¶

**Q: æ¨¡ç»„å¯ä»¥è‡ªåŠ¨æ›´æ–°å—ï¼Ÿ**  
A: ç³»ç»Ÿä¸æä¾›è‡ªåŠ¨æ›´æ–°ï¼Œä½†å¯ä»¥ï¼š
- æ£€æŸ¥ç‰ˆæœ¬å·
- ä¸‹è½½æ–°ç‰ˆæœ¬
- æç¤ºç”¨æˆ·æ‰‹åŠ¨æ›´æ–°

**Q: æ”¯æŒæ¨¡ç»„ä¾èµ–ç®¡ç†å—ï¼Ÿ**  
A: æ˜¯çš„ï¼Œåœ¨manifest.jsonä¸­å£°æ˜ä¾èµ–ï¼Œç³»ç»Ÿä¼šæ£€æŸ¥å¹¶æŒ‰é¡ºåºåŠ è½½ã€‚

## æ€»ç»“

Unityæ¨¡ç»„é€šä¿¡ç³»ç»Ÿv4æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„æ¨¡ç»„åŒ–å¼€å‘æ¡†æ¶ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### æ ¸å¿ƒä¼˜åŠ¿

1. **çœŸæ­£çš„å¹³å°æ— å…³æ€§**ï¼šCoreå±‚ä¸ä¾èµ–Unityï¼Œå¯ç”¨äºä»»ä½•.NETé¡¹ç›®
2. **çµæ´»çš„é€šä¿¡æœºåˆ¶**ï¼šæ”¯æŒäº‹ä»¶ã€è¯·æ±‚-å“åº”ã€æœåŠ¡ã€é…ç½®é©±åŠ¨ç­‰å¤šç§æ¨¡å¼
3. **å®Œæ•´çš„å·¥å…·é“¾**ï¼šä»å¼€å‘åˆ°éƒ¨ç½²çš„å…¨æµç¨‹å·¥å…·æ”¯æŒ
4. **å¼ºå¤§çš„è°ƒè¯•èƒ½åŠ›**ï¼šå†…ç½®äº‹ä»¶ç›‘æ§ã€æ€§èƒ½åˆ†æã€å†…å­˜ç›‘æ§å·¥å…·
5. **å®‰å…¨å¯é **ï¼šå®Œå–„çš„æƒé™ç³»ç»Ÿå’Œå®‰å…¨æ£€æŸ¥æœºåˆ¶
6. **æ˜“äºæ‰©å±•**ï¼šæ¨¡æ¿ç³»ç»Ÿæ”¯æŒè‡ªå®šä¹‰æ¨¡ç»„ç±»å‹

### é€‚ç”¨åœºæ™¯

- æ¸¸æˆæ¨¡ç»„ç³»ç»Ÿ
- æ’ä»¶åŒ–åº”ç”¨æ¶æ„
- å¾®æœåŠ¡é£æ ¼çš„Unityåº”ç”¨
- åŠ¨æ€å†…å®¹åŠ è½½ç³»ç»Ÿ
- å¯æ‰©å±•çš„ç¼–è¾‘å™¨å·¥å…·

### åç»­å‘å±•

- æ”¯æŒæ›´å¤šç¼–ç¨‹è¯­è¨€ï¼ˆé€šè¿‡.NETäº’æ“ä½œï¼‰
- å¯è§†åŒ–æ¨¡ç»„ç¼–è¾‘å™¨
- äº‘ç«¯æ¨¡ç»„ä»“åº“
- çƒ­é‡è½½æ”¯æŒ
- æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†æ”¹è¿›

é€šè¿‡æœ¬ç³»ç»Ÿï¼Œå¼€å‘è€…å¯ä»¥è½»æ¾åˆ›å»ºã€åˆ†å‘å’Œç®¡ç†æ¨¡ç»„ï¼Œä¸ºUnityåº”ç”¨æ·»åŠ æ— é™çš„æ‰©å±•å¯èƒ½ã€‚

```csharp
// ModSystem.Core/Communication/RequestResponse.cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace ModSystem.Core
{
    public abstract class ModRequest : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; } = Guid.NewGuid().ToString();
    }
    
    public abstract class ModResponse : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; }
        public bool Success { get; set; }
        public string Message { get; set; }
        public object Result { get; set; }
    }
    
    public interface IRequestResponseManager
    {
        Task<TResponse> SendRequestAsync<TRequest, TResponse>(
            TRequest request, 
            TimeSpan? timeout = null) 
            where TRequest : ModRequest 
            where TResponse : ModResponse;
    }
    
    public class RequestResponseManager : IRequestResponseManager
    {
        private readonly IEventBus eventBus;
        private readonly Dictionary<string, PendingRequest> pendingRequests;
        private readonly Timer cleanupTimer;
        
        private class PendingRequest
        {
            public TaskCompletionSource<ModResponse> CompletionSource { get; set; }
            public Type ResponseType { get; set; }
            public DateTime CreatedAt { get; set; }
            public CancellationTokenSource CancellationTokenSource { get; set; }
        }
        
        public RequestResponseManager(IEventBus eventBus)
        {
            this.eventBus = eventBus;
            this.pendingRequests = new Dictionary<string, PendingRequest>();
            
            // å®šæœŸæ¸…ç†è¶…æ—¶è¯·æ±‚
            cleanupTimer = new Timer(CleanupTimeoutRequests, null, 
                TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        }
        
        public async Task<TResponse> SendRequestAsync<TRequest, TResponse>(
            TRequest request, 
            TimeSpan? timeout = null) 
            where TRequest : ModRequest 
            where TResponse : ModResponse
        {
            var actualTimeout = timeout ?? TimeSpan.FromSeconds(30);
            var cts = new CancellationTokenSource(actualTimeout);
            var tcs = new TaskCompletionSource<ModResponse>();
            
            // æ³¨å†Œå–æ¶ˆå›è°ƒ
            cts.Token.Register(() =>
            {
                tcs.TrySetCanceled();
                CleanupRequest(request.RequestId);
            });
            
            pendingRequests[request.RequestId] = new PendingRequest
            {
                CompletionSource = tcs,
                ResponseType = typeof(TResponse),
                CreatedAt = DateTime.Now,
                CancellationTokenSource = cts
            };
            
            Action<TResponse> responseHandler = null;
            responseHandler = (response) =>
            {
                if (response.RequestId == request.RequestId)
                {
                    if (pendingRequests.TryGetValue(request.RequestId, out var pending))
                    {
                        pending.CompletionSource.TrySetResult(response);
                        CleanupRequest(request.RequestId);
                    }
                    eventBus.Unsubscribe(responseHandler);
                }
            };
            
            eventBus.Subscribe(responseHandler);
            eventBus.Publish(request);
            
            try
            {
                var result = await tcs.Task;
                return (TResponse)result;
            }
            catch (TaskCanceledException)
            {
                throw new TimeoutException($"Request {request.RequestId} timed out after {actualTimeout}");
            }
        }
        
        private void CleanupRequest(string requestId)
        {
            if (pendingRequests.TryGetValue(requestId, out var pending))
            {
                pending.CancellationTokenSource?.Dispose();
                pendingRequests.Remove(requestId);
            }
        }
        
        private void CleanupTimeoutRequests(object state)
        {
            var now = DateTime.Now;
            var timeoutRequests = pendingRequests
                .Where(kvp => (now - kvp.Value.CreatedAt) > TimeSpan.FromMinutes(5))
                .Select(kvp => kvp.Key)
                .ToList();
            
            foreach (var requestId in timeoutRequests)
            {
                if (pendingRequests.TryGetValue(requestId, out var pending))
                {
                    pending.CompletionSource.TrySetException(
                        new TimeoutException("Request timed out during cleanup")
                    );
                    CleanupRequest(requestId);
                }
            }
        }
        
        public void Dispose()
        {
            cleanupTimer?.Dispose();
            
            // å–æ¶ˆæ‰€æœ‰å¾…å¤„ç†è¯·æ±‚
            foreach (var requestId in pendingRequests.Keys.ToList())
            {
                CleanupRequest(requestId);
            }
        }
    }
}
```

#### 3. æœåŠ¡æ³¨å†Œç³»ç»Ÿ ğŸŸ¢

```csharp
// ModSystem.Core/Services/ServiceRegistry.cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace ModSystem.Core
{
    public interface IModService
    {
        string ServiceId { get; }
        string ProviderId { get; }
        string Version { get; }
    }
    
    public interface IServiceRegistry
    {
        void RegisterService<T>(T service) where T : class, IModService;
        T GetService<T>() where T : class, IModService;
        T GetService<T>(string serviceId) where T : class, IModService;
        IEnumerable<T> GetServices<T>() where T : class, IModService;
        bool UnregisterService<T>(string serviceId) where T : class, IModService;
        bool IsServiceRegistered<T>() where T : class, IModService;
        bool IsServiceRegistered<T>(string serviceId) where T : class, IModService;
    }
    
    public class ModServiceRegistry : IServiceRegistry
    {
        private readonly Dictionary<Type, Dictionary<string, IModService>> services;
        private readonly IEventBus eventBus;
        private readonly ILogger logger;
        private readonly object lockObject = new object();
        
        public ModServiceRegistry(IEventBus eventBus, ILogger logger = null)
        {
            this.services = new Dictionary<Type, Dictionary<string, IModService>>();
            this.eventBus = eventBus;
            this.logger = logger;
        }
        
        public void RegisterService<T>(T service) where T : class, IModService
        {
            if (service == null)
                throw new ArgumentNullException(nameof(service));
            
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (!services.ContainsKey(serviceType))
                {
                    services[serviceType] = new Dictionary<string, IModService>();
                }
                
                if (services[serviceType].ContainsKey(service.ServiceId))
                {
                    logger?.LogWarning($"Service {service.ServiceId} is already registered, replacing...");
                }
                
                services[serviceType][service.ServiceId] = service;
            }
            
            eventBus?.Publish(new ServiceRegisteredEvent
            {
                ServiceType = serviceType.Name,
                ServiceId = service.ServiceId,
                ProviderId = service.ProviderId,
                Version = service.Version
            });
            
            logger?.Log($"Service registered: {serviceType.Name} - {service.ServiceId}");
        }
        
        public T GetService<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType) && services[serviceType].Count > 0)
                {
                    return services[serviceType].Values.First() as T;
                }
            }
            
            return null;
        }
        
        public T GetService<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType) && 
                    services[serviceType].TryGetValue(serviceId, out var service))
                {
                    return service as T;
                }
            }
            
            return null;
        }
        
        public IEnumerable<T> GetServices<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType))
                {
                    return services[serviceType].Values.Cast<T>().ToList();
                }
            }
            
            return Enumerable.Empty<T>();
        }
        
        public bool UnregisterService<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            IModService removedService = null;
            
            lock (lockObject)
            {
                if (services.ContainsKey(serviceType) && 
                    services[serviceType].TryGetValue(serviceId, out removedService))
                {
                    services[serviceType].Remove(serviceId);
                    
                    if (services[serviceType].Count == 0)
                    {
                        services.Remove(serviceType);
                    }
                }
            }
            
            if (removedService != null)
            {
                eventBus?.Publish(new ServiceUnregisteredEvent
                {
                    ServiceType = serviceType.Name,
                    ServiceId = serviceId,
                    ProviderId = removedService.ProviderId
                });
                
                logger?.Log($"Service unregistered: {serviceType.Name} - {serviceId}");
                return true;
            }
            
            return false;
        }
        
        public bool IsServiceRegistered<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                return services.ContainsKey(serviceType) && services[serviceType].Count > 0;
            }
        }
        
        public bool IsServiceRegistered<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            lock (lockObject)
            {
                return services.ContainsKey(serviceType) && 
                       services[serviceType].ContainsKey(serviceId);
            }
        }
    }
    
    public class ServiceRegisteredEvent : IModEvent
    {
        public string EventId => "service_registered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
        public string Version { get; set; }
    }
    
    public class ServiceUnregisteredEvent : IModEvent
    {
        public string EventId => "service_unregistered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
    }
}
```

#### 4. é…ç½®é©±åŠ¨è·¯ç”± ğŸŸ¢

```csharp
// ModSystem.Core/Communication/CommunicationRouter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Reflection;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    public class CommunicationConfig
    {
        public List<RouteConfig> Routes { get; set; } = new List<RouteConfig>();
        public List<WorkflowConfig> Workflows { get; set; } = new List<WorkflowConfig>();
        public RouterSettings Settings { get; set; } = new RouterSettings();
    }
    
    public class RouteConfig
    {
        public string Name { get; set; }
        public string SourceEvent { get; set; }
        public List<ConditionConfig> Conditions { get; set; } = new List<ConditionConfig>();
        public List<ActionConfig> Actions { get; set; } = new List<ActionConfig>();
        public bool Enabled { get; set; } = true;
        public int Priority { get; set; } = 0;
    }
    
    public class RouterSettings
    {
        public bool EnableDebugLogging { get; set; } = false;
        public int MaxConcurrentActions { get; set; } = 10;
        public int DefaultActionTimeout { get; set; } = 5000;
    }
    
    public class CommunicationRouter
    {
        private readonly IEventBus eventBus;
        private readonly ILogger logger;
        private readonly CommunicationConfig config;
        private readonly Dictionary<string, List<RouteConfig>> routeMap;
        private readonly Dictionary<Type, MethodInfo> subscribeMethodCache;
        private readonly SemaphoreSlim actionSemaphore;
        
        public CommunicationRouter(IEventBus eventBus, string configJson, ILogger logger = null)
        {
            this.eventBus = eventBus;
            this.logger = logger;
            this.config = JsonConvert.DeserializeObject<CommunicationConfig>(configJson);
            this.routeMap = BuildRouteMap();
            this.subscribeMethodCache = new Dictionary<Type, MethodInfo>();
            this.actionSemaphore = new SemaphoreSlim(config.Settings.MaxConcurrentActions);
            
            SubscribeToEvents();
        }
        
        private Dictionary<string, List<RouteConfig>> BuildRouteMap()
        {
            var map = new Dictionary<string, List<RouteConfig>>();
            
            foreach (var route in config.Routes.Where(r => r.Enabled))
            {
                if (!map.ContainsKey(route.SourceEvent))
                {
                    map[route.SourceEvent] = new List<RouteConfig>();
                }
                map[route.SourceEvent].Add(route);
            }
            
            // æŒ‰ä¼˜å…ˆçº§æ’åº
            foreach (var routes in map.Values)
            {
                routes.Sort((a, b) => b.Priority.CompareTo(a.Priority));
            }
            
            return map;
        }
        
        private void SubscribeToEvents()
        {
            foreach (var eventTypeName in routeMap.Keys)
            {
                try
                {
                    var eventType = GetTypeFromName(eventTypeName);
                    if (eventType == null)
                    {
                        logger?.LogError($"Event type not found: {eventTypeName}");
                        continue;
                    }
                    
                    var subscribeMethod = GetSubscribeMethod(eventType);
                    var handlerType = typeof(Action<>).MakeGenericType(eventType);
                    var handleMethod = GetType().GetMethod(nameof(HandleEvent), 
                        BindingFlags.NonPublic | BindingFlags.Instance);
                    var genericHandleMethod = handleMethod.MakeGenericMethod(eventType);
                    
                    var handler = Delegate.CreateDelegate(handlerType, this, genericHandleMethod);
                    
                    subscribeMethod.Invoke(eventBus, new[] { handler });
                    
                    logger?.Log($"Router subscribed to {eventTypeName}");
                }
                catch (Exception ex)
                {
                    logger?.LogError($"Failed to subscribe to {eventTypeName}: {ex.Message}");
                }
            }
        }
        
        private MethodInfo GetSubscribeMethod(Type eventType)
        {
            if (!subscribeMethodCache.TryGetValue(eventType, out var method))
            {
                method = eventBus.GetType()
                    .GetMethod("Subscribe")
                    .MakeGenericMethod(eventType);
                subscribeMethodCache[eventType] = method;
            }
            return method;
        }
        
        private Type GetTypeFromName(string typeName)
        {
            // é¦–å…ˆå°è¯•åœ¨æ‰€æœ‰å·²åŠ è½½çš„ç¨‹åºé›†ä¸­æŸ¥æ‰¾
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                var type = assembly.GetType(typeName);
                if (type != null) return type;
            }
            
            // å°è¯•Type.GetTypeï¼ˆæ”¯æŒç¨‹åºé›†é™å®šåï¼‰
            return Type.GetType(typeName);
        }
        
        private async void HandleEvent<T>(T eventData) where T : IModEvent
        {
            var eventTypeName = typeof(T).FullName ?? typeof(T).Name;
            
            if (config.Settings.EnableDebugLogging)
            {
                logger?.Log($"Router handling event: {eventTypeName}");
            }
            
            if (routeMap.TryGetValue(eventTypeName, out var routes))
            {
                var tasks = new List<Task>();
                
                foreach (var route in routes)
                {
                    if (EvaluateConditions(route.Conditions, eventData))
                    {
                        tasks.Add(ExecuteActionsAsync(route, eventData));
                    }
                }
                
                if (tasks.Count > 0)
                {
                    try
                    {
                        await Task.WhenAll(tasks);
                    }
                    catch (Exception ex)
                    {
                        logger?.LogError($"Error executing route actions: {ex.Message}");
                    }
                }
            }
        }
        
        private bool EvaluateConditions<T>(List<ConditionConfig> conditions, T eventData)
        {
            if (conditions == null || conditions.Count == 0)
                return true;
            
            foreach (var condition in conditions)
            {
                var value = GetPropertyValue(eventData, condition.Property);
                
                if (!EvaluateCondition(value, condition.Operator, condition.Value))
                {
                    if (config.Settings.EnableDebugLogging)
                    {
                        logger?.Log($"Condition failed: {condition.Property} {condition.Operator} {condition.Value}");
                    }
                    return false;
                }
            }
            
            return true;
        }
        
        private async Task ExecuteActionsAsync<T>(RouteConfig route, T sourceEvent)
        {
            foreach (var action in route.Actions)
            {
                await actionSemaphore.WaitAsync();
                
                try
                {
                    if (action.Delay > 0)
                    {
                        await Task.Delay(action.Delay);
                    }
                    
                    var parameters = PrepareParameters(action.Parameters, sourceEvent);
                    var targetEvent = CreateEvent(action.EventType, parameters);
                    
                    if (targetEvent != null)
                    {
                        eventBus.Publish(targetEvent);
                        
                        if (config.Settings.EnableDebugLogging)
                        {
                            logger?.Log($"Route {route.Name} published {action.EventType}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    logger?.LogError($"Failed to execute action in route {route.Name}: {ex.Message}");
                }
                finally
                {
                    actionSemaphore.Release();
                }
            }
        }
    }
}
```

### å®‰å…¨ç³»ç»Ÿ

#### SecurityManagerï¼ˆå®‰å…¨ç®¡ç†å™¨ï¼‰ğŸŸ¢

```csharp
// ModSystem.Core/Security/SecurityManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Reflection;

namespace ModSystem.Core
{
    public class SecurityManager
    {
        private readonly SecurityConfig config;
        private readonly ILogger logger;
        private readonly HashSet<string> whitelistedPaths;
        private readonly HashSet<string> blacklistedAPIs;
        
        public SecurityManager(SecurityConfig config, ILogger logger)
        {
            this.config = config;
            this.logger = logger;
            this.whitelistedPaths = new HashSet<string>();
            this.blacklistedAPIs = InitializeBlacklistedAPIs();
        }
        
        public bool ValidateMod(string modPath)
        {
            try
            {
                // 1. æ£€æŸ¥è·¯å¾„å®‰å…¨æ€§
                if (!IsPathSafe(modPath))
                {
                    logger.LogError($"Mod path is not safe: {modPath}");
                    return false;
                }
                
                // 2. éªŒè¯æ•°å­—ç­¾åï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (config.RequireSignedMods)
                {
                    if (!VerifySignature(modPath))
                    {
                        logger.LogError($"Mod signature verification failed: {modPath}");
                        return false;
                    }
                }
                
                // 3. æ‰«ææ¶æ„ä»£ç 
                if (!ScanForMaliciousCode(modPath))
                {
                    logger.LogError($"Mod contains suspicious code: {modPath}");
                    return false;
                }
                
                // 4. éªŒè¯æƒé™
                if (!ValidatePermissions(modPath))
                {
                    logger.LogError($"Mod requests unauthorized permissions: {modPath}");
                    return false;
                }
                
                logger.Log($"Mod validation passed: {modPath}");
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Security validation error: {ex.Message}");
                return false;
            }
        }
        
        private bool IsPathSafe(string path)
        {
            try
            {
                var fullPath = Path.GetFullPath(path);
                var allowedPaths = config.AllowedModPaths ?? new List<string> { config.ModDirectory };
                
                // æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„è·¯å¾„å†…
                bool isInAllowedPath = false;
                foreach (var allowedPath in allowedPaths)
                {
                    var fullAllowedPath = Path.GetFullPath(allowedPath);
                    if (fullPath.StartsWith(fullAllowedPath, StringComparison.OrdinalIgnoreCase))
                    {
                        isInAllowedPath = true;
                        break;
                    }
                }
                
                if (!isInAllowedPath)
                {
                    logger.LogError($"Path {fullPath} is not in allowed directories");
                    return false;
                }
                
                // æ£€æŸ¥è·¯å¾„éå†æ”»å‡»
                if (path.Contains("..") || path.Contains("~"))
                {
                    logger.LogError("Path contains traversal characters");
                    return false;
                }
                
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Path validation error: {ex.Message}");
                return false;
            }
        }
        
        private bool VerifySignature(string modPath)
        {
            var signaturePath = Path.Combine(modPath, "signature.sig");
            if (!File.Exists(signaturePath))
            {
                logger.LogWarning($"Signature file not found: {signaturePath}");
                return false;
            }
            
            try
            {
                using (var rsa = new RSACryptoServiceProvider())
                {
                    // åŠ è½½å…¬é’¥
                    if (!File.Exists(config.PublicKeyPath))
                    {
                        logger.LogError("Public key file not found");
                        return false;
                    }
                    
                    var publicKey = File.ReadAllText(config.PublicKeyPath);
                    rsa.FromXmlString(publicKey);
                    
                    // è®¡ç®—æ¸…å•æ–‡ä»¶å“ˆå¸Œ
                    var manifestPath = Path.Combine(modPath, "manifest.json");
                    if (!File.Exists(manifestPath))
                    {
                        logger.LogError("Manifest file not found for signature verification");
                        return false;
                    }
                    
                    var manifestData = File.ReadAllBytes(manifestPath);
                    using (var sha256 = SHA256.Create())
                    {
                        var hash = sha256.ComputeHash(manifestData);
                        var signature = File.ReadAllBytes(signaturePath);
                        
                        return rsa.VerifyHash(hash, CryptoConfig.MapNameToOID("SHA256"), signature);
                    }
                }
            }
            catch (Exception ex)
            {
                logger.LogError($"Signature verification error: {ex.Message}");
                return false;
            }
        }
        
        private bool ScanForMaliciousCode(string modPath)
        {
            var dllFiles = Directory.GetFiles(modPath, "*.dll", SearchOption.AllDirectories);
            
            foreach (var dll in dllFiles)
            {
                if (!ScanAssembly(dll))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        private bool ScanAssembly(string assemblyPath)
        {
            try
            {
                // ä½¿ç”¨ReflectionOnlyLoadé¿å…æ‰§è¡Œä»£ç 
                var assemblyName = AssemblyName.GetAssemblyName(assemblyPath);
                var assembly = Assembly.ReflectionOnlyLoad(assemblyName.FullName);
                
                foreach (var type in assembly.GetTypes())
                {
                    // æ£€æŸ¥å±é™©çš„åŸºç±»
                    if (IsDangerousType(type))
                    {
                        logger.LogError($"Dangerous type detected: {type.FullName}");
                        return false;
                    }
                    
                    // æ£€æŸ¥æ–¹æ³•è°ƒç”¨
                    foreach (var method in type.GetMethods(
                        BindingFlags.Public | BindingFlags.NonPublic | 
                        BindingFlags.Instance | BindingFlags.Static))
                    {
                        if (IsDangerousMethod(method))
                        {
                            logger.LogError($"Dangerous method detected: {method.Name} in {type.FullName}");
                            return false;
                        }
                    }
                }
                
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Assembly scan error: {ex.Message}");
                return false;
            }
        }
        
        private bool IsDangerousType(Type type)
        {
            var dangerousTypes = new[]
            {
                "System.Diagnostics.Process",
                "System.IO.FileSystemWatcher",
                "System.Net.WebClient",
                "System.Net.Http.HttpClient",
                "Microsoft.Win32.Registry"
            };
            
            return dangerousTypes.Any(dt => 
                type.FullName == dt || 
                (type.BaseType != null && type.BaseType.FullName == dt));
        }
        
        private bool IsDangerousMethod(MethodInfo method)
        {
            var dangerousPatterns = new[]
            {
                "Process.Start",
                "File.Delete",
                "Directory.Delete",
                "Registry.",
                "Assembly.Load",
                "AppDomain.CreateDomain",
                "Marshal.GetDelegateForFunctionPointer"
            };
            
            var methodFullName = $"{method.DeclaringType?.Name}.{method.Name}";
            
            return dangerousPatterns.Any(pattern => 
                methodFullName.Contains(pattern));
        }
        
        private bool ValidatePermissions(string modPath)
        {
            var manifestPath = Path.Combine(modPath, "manifest.json");
            if (!File.Exists(manifestPath))
            {
                logger.LogError("Manifest file not found for permission validation");
                return false;
            }
            
            try
            {
                var manifestJson = File.ReadAllText(manifestPath);
                var manifest = JsonConvert.DeserializeObject<ModManifest>(manifestJson);
                
                if (manifest.permissions == null || manifest.permissions.Length == 0)
                {
                    return true; // æ²¡æœ‰è¯·æ±‚ç‰¹æ®Šæƒé™
                }
                
                // æ£€æŸ¥æ¯ä¸ªè¯·æ±‚çš„æƒé™
                foreach (var permission in manifest.permissions)
                {
                    if (!config.AllowedPermissions.Contains(permission))
                    {
                        logger.LogError($"Unauthorized permission requested: {permission}");
                        return false;
                    }
                }
                
                return true;
            }
            catch (Exception ex)
            {
                logger.LogError($"Permission validation error: {ex.Message}");
                return false;
            }
        }
        
        private HashSet<string> InitializeBlacklistedAPIs()
        {
            return new HashSet<string>
            {
                "System.IO.File.Delete",
                "System.IO.Directory.Delete",
                "System.Diagnostics.Process.Start",
                "System.Net.WebClient",
                "System.Net.Http.HttpClient",
                "System.Reflection.Assembly.Load",
                "System.Reflection.Assembly.LoadFrom",
                "System.Reflection.Assembly.LoadFile",
                "System.AppDomain.CreateDomain",
                "System.Runtime.InteropServices.Marshal",
                "Microsoft.Win32.Registry",
                "System.Security.Cryptography",
                "System.Threading.Thread.Abort",
                "System.Environment.Exit"
            };
        }
        
        public SecurityContext CreateContext(string modId, string[] requestedPermissions)
        {
            var grantedPermissions = new HashSet<string>();
            
            // æ£€æŸ¥æ¨¡ç»„æ˜¯å¦åœ¨ä¿¡ä»»åˆ—è¡¨ä¸­
            if (config.TrustedMods?.Contains(modId) == true)
            {
                // ä¿¡ä»»çš„æ¨¡ç»„è·å¾—æ‰€æœ‰è¯·æ±‚çš„æƒé™
                grantedPermissions = new HashSet<string>(requestedPermissions);
            }
            else if (config.ModPermissions?.TryGetValue(modId, out var allowedPermissions) == true)
            {
                // åªæˆäºˆé…ç½®ä¸­å…è®¸çš„æƒé™
                foreach (var permission in requestedPermissions)
                {
                    if (allowedPermissions.Contains(permission))
                    {
                        grantedPermissions.Add(permission);
                    }
                }
            }
            else
            {
                // ä½¿ç”¨é»˜è®¤æƒé™é›†
                foreach (var permission in requestedPermissions)
                {
                    if (config.DefaultPermissions?.Contains(permission) == true)
                    {
                        grantedPermissions.Add(permission);
                    }
                }
            }
            
            var resourceLimits = config.ModResourceLimits?.GetValueOrDefault(modId) ?? 
                                config.ModResourceLimits?.GetValueOrDefault("default") ?? 
                                new ResourceLimits();
            
            return new SecurityContext
            {
                ModId = modId,
                Permissions = grantedPermissions,
                ResourceLimits = resourceLimits
            };
        }
    }
    
    public class SecurityContext
    {
        public string ModId { get; set; }
        public HashSet<string> Permissions { get; set; }
        public ResourceLimits ResourceLimits { get; set; }
        
        public bool HasPermission(string permission)
        {
            return Permissions?.Contains(permission) ?? false;
        }
    }
    
    public class SecurityConfig
    {
        public bool RequireSignedMods { get; set; } = true;
        public string PublicKeyPath { get; set; }
        public string ModDirectory { get; set; } = "Mods";
        public List<string> AllowedModPaths { get; set; }
        public HashSet<string> AllowedPermissions { get; set; } = new HashSet<string>
        {
            "event_publish",
            "event_subscribe", 
            "service_register",
            "object_create",
            "config_read",
            "audio_play",
            "ui_create"
        };
        public HashSet<string> DefaultPermissions { get; set; } = new HashSet<string>
        {
            "event_publish",
            "event_subscribe",
            "config_read"
        };
        public Dictionary<string, List<string>> ModPermissions { get; set; }
        public Dictionary<string, ResourceLimits> ModResourceLimits { get; set; }
        public List<string> TrustedMods { get; set; }
    }
    
    public class ResourceLimits
    {
        public int MaxMemoryMB { get; set; } = 100;
        public int MaxCpuTimeMs { get; set; } = 10;
        public int MaxObjects { get; set; } = 50;
        public int MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
        public int MaxEventRate { get; set; } = 100; // æ¯ç§’æœ€å¤šäº‹ä»¶æ•°
        public int MaxServiceCalls { get; set; } = 1000; // æ¯åˆ†é’Ÿæœ€å¤šæœåŠ¡è°ƒç”¨
    }
}
```

## é€šä¿¡æ¨¡å¼è¯¦è§£

### 1. äº‹ä»¶æ¨¡å¼ï¼ˆEvent Patternï¼‰

é€‚ç”¨äºå•å‘é€šçŸ¥ã€çŠ¶æ€å˜åŒ–å¹¿æ’­ç­‰åœºæ™¯ã€‚

```csharp
// å®šä¹‰äº‹ä»¶
public class ButtonPressedEvent : IModEvent
{
    public string EventId => "button_pressed";
    public string SenderId { get; set; }
    public DateTime Timestamp { get; set; }
    
    public string ButtonId { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
}

// å‘å¸ƒäº‹ä»¶
context.EventBus.Publish(new ButtonPressedEvent 
{ 
    ButtonId = "btn_1",
    Parameters = new Dictionary<string, object> { ["action"] = "rotate" }
});

// è®¢é˜…äº‹ä»¶
context.EventBus.Subscribe<ButtonPressedEvent>(e => 
{
    Console.WriteLine($"Button {e.ButtonId} was pressed");
});

// å¸¦æ¡ä»¶è®¢é˜…
context.EventBus.Subscribe<ButtonPressedEvent>(
    e => HandleButtonPress(e),
    e => e.ButtonId == "btn_1" // åªå¤„ç†ç‰¹å®šæŒ‰é’®
);
```

### 2. è¯·æ±‚-å“åº”æ¨¡å¼ï¼ˆRequest-Response Patternï¼‰

é€‚ç”¨äºéœ€è¦è¿”å›ç»“æœçš„æ“ä½œã€å‘½ä»¤ç¡®è®¤ç­‰åœºæ™¯ã€‚

```csharp
// å®šä¹‰è¯·æ±‚å’Œå“åº”
public class MoveRobotRequest : ModRequest
{
    public Vector3 TargetPosition { get; set; }
    public float Speed { get; set; }
}

public class MoveRobotResponse : ModResponse
{
    public float ActualDistance { get; set; }
    public float TimeTaken { get; set; }
}

// å‘é€è¯·æ±‚
var response = await context.API.RequestResponse.SendRequestAsync<MoveRobotRequest, MoveRobotResponse>(
    new MoveRobotRequest 
    { 
        TargetPosition = new Vector3(1, 2, 3),
        Speed = 5.0f
    },
    TimeSpan.FromSeconds(10)
);

if (response.Success)
{
    Console.WriteLine($"Robot moved {response.ActualDistance} units in {response.TimeTaken} seconds");
}

// å¤„ç†è¯·æ±‚
context.EventBus.Subscribe<MoveRobotRequest>(async request =>
{
    // æ‰§è¡Œç§»åŠ¨é€»è¾‘
    var result = await MoveRobot(request.TargetPosition, request.Speed);
    
    // å‘é€å“åº”
    context.EventBus.Publish(new MoveRobotResponse
    {
        RequestId = request.RequestId,
        Success = result.Success,
        ActualDistance = result.Distance,
        TimeTaken = result.Time
    });
});
```

### 3. æœåŠ¡æ¨¡å¼ï¼ˆService Patternï¼‰

é€‚ç”¨äºæ¨¡ç»„é—´ç´§å¯†åä½œã€APIå¼è°ƒç”¨ç­‰åœºæ™¯ã€‚

```csharp
// å®šä¹‰æœåŠ¡æ¥å£
public interface IRobotService : IModService
{
    Task<bool> MoveToPosition(Vector3 position);
    Task<RobotStatus> GetStatus();
    void EmergencyStop();
}

// å®ç°æœåŠ¡
public class RobotService : IRobotService
{
    public string ServiceId => "robot_service_01";
    public string ProviderId => "RobotMod";
    public string Version => "1.0.0";
    
    public async Task<bool> MoveToPosition(Vector3 position)
    {
        // å®ç°ç§»åŠ¨é€»è¾‘
        return true;
    }
    
    // å…¶ä»–æ–¹æ³•å®ç°...
}

// æ³¨å†ŒæœåŠ¡
context.Services.RegisterService<IRobotService>(new RobotService());

// ä½¿ç”¨æœåŠ¡
var robotService = context.Services.GetService<IRobotService>();
if (robotService != null)
{
    await robotService.MoveToPosition(new Vector3(5, 0, 5));
}

// ç­‰å¾…æœåŠ¡å¯ç”¨
if (!context.Services.IsServiceRegistered<IRobotService>())
{
    context.EventBus.Subscribe<ServiceRegisteredEvent>(e =>
    {
        if (e.ServiceType == nameof(IRobotService))
        {
            // æœåŠ¡ç°åœ¨å¯ç”¨
            var service = context.Services.GetService<IRobotService>();
            // ä½¿ç”¨æœåŠ¡...
        }
    });
}
```

### 4. é…ç½®é©±åŠ¨æ¨¡å¼ï¼ˆConfiguration-Driven Patternï¼‰

é€šè¿‡JSONé…ç½®æ–‡ä»¶å®šä¹‰äº‹ä»¶è·¯ç”±å’Œè¡Œä¸ºã€‚

```json
{
  "routes": [
    {
      "name": "button_to_robot_movement",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "move_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.MoveCommand",
          "parameters": {
            "direction": "forward",
            "distance": 1.0
          },
          "delay": 100
        }
      ]
    },
    {
      "name": "sensor_triggers_alarm",
      "sourceEvent": "SensorMod.ProximityEvent",
      "conditions": [
        {
          "property": "Distance",
          "operator": "<",
          "value": 0.5
        }
      ],
      "actions": [
        {
          "eventType": "AlarmMod.TriggerAlarm",
          "parameters": {
            "level": "warning",
            "message": "Object too close"
          }
        }
      ]
    }
  ],
  "settings": {
    "enableDebugLogging": true,
    "maxConcurrentActions": 5
  }
}
```

## æ¨¡ç»„å¼€å‘

### åˆ›å»ºç®€å•çš„æŒ‰é’®æ¨¡ç»„ ğŸŸ¢

```csharp
// ButtonMod/ButtonBehaviour.cs
using System;
using System.Collections.Generic;
using ModSystem.Core;

namespace ButtonMod
{
    public class ButtonBehaviour : IModBehaviour
    {
        public string BehaviourId => "simple_button";
        public string Version => "1.0.0";
        
        private IModContext context;
        private ButtonConfig config;
        private float lastPressTime;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            
            // åŠ è½½é…ç½®
            config = LoadConfig();
            
            // è®¢é˜…äº¤äº’äº‹ä»¶
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            
            context.Log($"Button {config.ButtonId} initialized");
        }
        
        private void OnInteraction(InteractionEvent e)
        {
            // æ£€æŸ¥æ˜¯å¦æ˜¯é’ˆå¯¹æ­¤æŒ‰é’®çš„äº¤äº’
            if (e.TargetId != context.GameObject.Name)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {
                OnButtonClick();
            }
        }
        
        private void OnButtonClick()
        {
            // æ£€æŸ¥å†·å´æ—¶é—´
            var currentTime = DateTime.Now.Ticks / TimeSpan.TicksPerSecond;
            if (currentTime - lastPressTime < config.CooldownTime)
                return;
            
            lastPressTime = currentTime;
            
            // å‘å¸ƒæŒ‰é’®äº‹ä»¶
            context.EventBus.Publish(new ButtonPressedEvent
            {
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                ButtonType = config.ButtonType,
                Parameters = config.ActionParameters
            });
            
            context.Log($"Button {config.ButtonId} clicked");
        }
        
        public void OnUpdate(float deltaTime)
        {
            // æŒ‰é’®é€šå¸¸ä¸éœ€è¦æ¯å¸§æ›´æ–°
        }
        
        public void OnDestroy()
        {
            context.Log($"Button {config.ButtonId} destroyed");
        }
        
        private ButtonConfig LoadConfig()
        {
            // ä»é…ç½®æ–‡ä»¶åŠ è½½æˆ–ä½¿ç”¨é»˜è®¤å€¼
            return new ButtonConfig
            {
                ButtonId = "btn_01",
                ButtonType = "toggle",
                CooldownTime = 0.5f,
                ActionParameters = new Dictionary<string, object>
                {
                    ["action"] = "default_action"
                }
            };
        }
    }
    
    public class ButtonConfig
    {
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public float CooldownTime { get; set; }
        public Dictionary<string, object> ActionParameters { get; set; }
    }
    
    public class ButtonPressedEvent : IModEvent
    {
        public string EventId => "button_pressed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
}
```

### åˆ›å»ºæœºå™¨äººæœåŠ¡æ¨¡ç»„ ğŸŸ¢

```csharp
// RobotMod/RobotArmBehaviour.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ModSystem.Core;

namespace RobotMod
{
    public class RobotArmBehaviour : IModBehaviour, IRobotService
    {
        public string BehaviourId => "robot_arm_controller";
        public string Version => "2.0.0";
        
        // IModService implementation
        public string ServiceId => "robot_arm_01";
        public string ProviderId => "RobotMod";
        string IModService.Version => Version;
        
        private IModContext context;
        private RobotConfiguration config;
        private Dictionary<string, JointState> joints;
        private bool emergencyStop = false;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            
            // åŠ è½½é…ç½®
            config = LoadConfiguration();
            
            // åˆå§‹åŒ–å…³èŠ‚
            joints = InitializeJoints();
            
            // æ³¨å†ŒæœåŠ¡
            context.Services.RegisterService<IRobotService>(this);
            
            // è®¢é˜…äº‹ä»¶
            SubscribeToEvents();
            
            context.Log($"Robot arm {ServiceId} initialized with {joints.Count} joints");
        }
        
        private void SubscribeToEvents()
        {
            // è®¢é˜…æŒ‰é’®äº‹ä»¶
            context.EventBus.Subscribe<ButtonPressedEvent>(OnButtonPressed);
            
            // è®¢é˜…ç´§æ€¥åœæ­¢äº‹ä»¶
            context.EventBus.Subscribe<EmergencyStopEvent>(e => EmergencyStop());
            
            // è®¢é˜…æ§åˆ¶è¯·æ±‚
            context.EventBus.Subscribe<RobotControlRequest>(HandleControlRequest);
        }
        
        private void OnButtonPressed(ButtonPressedEvent e)
        {
            if (emergencyStop) return;
            
            // æ ¹æ®æŒ‰é’®å‚æ•°æ‰§è¡ŒåŠ¨ä½œ
            if (e.Parameters?.TryGetValue("action", out var action) == true)
            {
                switch (action.ToString())
                {
                    case "move_forward":
                        _ = MoveToPosition(new Vector3(1, 0, 0));
                        break;
                    case "rotate_base":
                        _ = RotateJoint("base", 45);
                        break;
                    case "home_position":
                        _ = MoveToHomePosition();
                        break;
                }
            }
        }
        
        private async void HandleControlRequest(RobotControlRequest request)
        {
            var response = new RobotControlResponse
            {
                RequestId = request.RequestId,
                SenderId = ServiceId
            };
            
            try
            {
                switch (request.Command)
                {
                    case "move_joint":
                        var jointName = request.Parameters["joint"].ToString();
                        var angle = Convert.ToSingle(request.Parameters["angle"]);
                        response.Success = await RotateJoint(jointName, angle);
                        break;
                        
                    case "get_status":
                        response.Result = await GetStatus();
                        response.Success = true;
                        break;
                        
                    default:
                        response.Success = false;
                        response.Message = $"Unknown command: {request.Command}";
                        break;
                }
            }
            catch (Exception ex)
            {
                response.Success = false;
                response.Message = ex.Message;
            }
            
            context.EventBus.Publish(response);
        }
        
        // IRobotService implementation
        public async Task<bool> MoveToPosition(Vector3 position)
        {
            if (emergencyStop) return false;
            
            context.Log($"Moving to position: {position}");
            
            // è®¡ç®—é€†è¿åŠ¨å­¦
            var jointAngles = CalculateInverseKinematics(position);
            
            // ç§»åŠ¨æ‰€æœ‰å…³èŠ‚
            var tasks = new List<Task<bool>>();
            foreach (var kvp in jointAngles)
            {
                tasks.Add(RotateJoint(kvp.Key, kvp.Value));
            }
            
            var results = await Task.WhenAll(tasks);
            return Array.TrueForAll(results, r => r);
        }
        
        public async Task<RobotStatus> GetStatus()
        {
            return await Task.FromResult(new RobotStatus
            {
                IsMoving = IsAnyJointMoving(),
                CurrentPosition = GetEndEffectorPosition(),
                JointStates = new Dictionary<string, float>(
                    joints.ToDictionary(j => j.Key, j => j.Value.CurrentAngle)
                ),
                IsEmergencyStopped = emergencyStop
            });
        }
        
        public void EmergencyStop()
        {
            emergencyStop = true;
            
            // åœæ­¢æ‰€æœ‰å…³èŠ‚
            foreach (var joint in joints.Values)
            {
                joint.TargetAngle = joint.CurrentAngle;
                joint.IsMoving = false;
            }
            
            // å‘å¸ƒç´§æ€¥åœæ­¢äº‹ä»¶
            context.EventBus.Publish(new RobotStateChangedEvent
            {
                SenderId = ServiceId,
                State = "emergency_stopped"
            });
            
            context.Log("Emergency stop activated!");
        }
        
        public void OnUpdate(float deltaTime)
        {
            if (emergencyStop) return;
            
            // æ›´æ–°å…³èŠ‚ä½ç½®
            foreach (var joint in joints.Values)
            {
                if (joint.IsMoving)
                {
                    UpdateJoint(joint, deltaTime);
                }
            }
            
            // æ£€æŸ¥ç¢°æ’ç­‰
            if (config.EnableCollisionDetection)
            {
                CheckCollisions();
            }
        }
        
        public void OnDestroy()
        {
            // æ³¨é”€æœåŠ¡
            context.Services.UnregisterService<IRobotService>(ServiceId);
            
            context.Log($"Robot arm {ServiceId} destroyed");
        }
        
        // è¾…åŠ©æ–¹æ³•
        private async Task<bool> RotateJoint(string jointName, float angle)
        {
            if (!joints.TryGetValue(jointName, out var joint))
            {
                context.LogError($"Joint {jointName} not found");
                return false;
            }
            
            joint.TargetAngle = Math.Clamp(angle, joint.MinAngle, joint.MaxAngle);
            joint.IsMoving = true;
            
            // å‘å¸ƒçŠ¶æ€å˜åŒ–äº‹ä»¶
            context.EventBus.Publish(new JointMovementEvent
            {
                SenderId = ServiceId,
                JointName = jointName,
                TargetAngle = joint.TargetAngle
            });
            
            // æ¨¡æ‹Ÿå¼‚æ­¥ç§»åŠ¨
            while (Math.Abs(joint.CurrentAngle - joint.TargetAngle) > 0.1f)
            {
                await Task.Delay(10);
            }
            
            return true;
        }
        
        private void UpdateJoint(JointState joint, float deltaTime)
        {
            var diff = joint.TargetAngle - joint.CurrentAngle;
            var moveAmount = Math.Sign(diff) * Math.Min(
                Math.Abs(diff), 
                joint.MaxSpeed * deltaTime
            );
            
            joint.CurrentAngle += moveAmount;
            
            if (Math.Abs(joint.CurrentAngle - joint.TargetAngle) < 0.1f)
            {
                joint.CurrentAngle = joint.TargetAngle;
                joint.IsMoving = false;
            }
        }
        
        // å…¶ä»–è¾…åŠ©æ–¹æ³•å®ç°...
    }
}
```

## å®Œæ•´ä»£ç å®ç°

### Unityå±‚å®ç° ğŸ”µ

#### UnityLogger

```csharp
// ModSystem.Unity/UnityImplementations/UnityLogger.cs
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity
{
    public class UnityLogger : ILogger
    {
        private readonly string prefix;
        
        public UnityLogger(string prefix = "[ModSystem]")
        {
            this.prefix = prefix;
        }
        
        public void Log(string message)
        {
            Debug.Log($"{prefix} {message}");
        }
        
        public void LogWarning(string message)
        {
            Debug.LogWarning($"{prefix} {message}");
        }
        
        public void LogError(string message)
        {
            Debug.LogError($"{prefix} {message}");
        }
    }
}
```

#### UnityPathProvider

```csharp
// ModSystem.Unity/UnityImplementations/UnityPathProvider.cs
using UnityEngine;
using System.IO;
using ModSystem.Core;

namespace ModSystem.Unity
{
    public class UnityPathProvider : IPathProvider
    {
        public string GetModsPath()
        {
            return Path.Combine(Application.streamingAssetsPath, "Mods");
        }
        
        public string GetConfigPath()
        {
            return Path.Combine(Application.streamingAssetsPath, "ModConfigs");
        }
        
        public string GetTempPath()
        {
            return Path.Combine(Application.temporaryCachePath, "ModTemp");
        }
        
        public string GetPersistentDataPath()
        {
            return Application.persistentDataPath;
        }
    }
}
```

#### UnityObjectFactory

```csharp
// ModSystem.Unity/UnityImplementations/UnityObjectFactory.cs
using UnityEngine;
using System.Threading.Tasks;
using ModSystem.Core;
using System.Collections.Generic;

namespace ModSystem.Unity
{
    public class UnityObjectFactory : ObjectFactoryBase
    {
        public UnityObjectFactory() : base(Application.streamingAssetsPath, new UnityLogger())
        {
        }
        
        public override async Task<IGameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition)
        {
            var gameObject = new GameObject(definition.name);
            var wrapper = new UnityGameObjectWrapper(gameObject);
            
            foreach (var compDef in definition.components)
            {
                await AddComponentAsync(wrapper, compDef);
            }
            
            return wrapper;
        }
        
        private async Task AddComponentAsync(UnityGameObjectWrapper wrapper, ComponentDefinition compDef)
        {
            switch (compDef.type)
            {
                case "Transform":
                    ConfigureTransform(wrapper.GameObject.transform, compDef);
                    break;
                    
                case "MeshRenderer":
                    await ConfigureMeshRenderer(wrapper.GameObject, compDef);
                    break;
                    
                case "BoxCollider":
                    ConfigureBoxCollider(wrapper.GameObject, compDef);
                    break;
                    
                case "SphereCollider":
                    ConfigureSphereCollider(wrapper.GameObject, compDef);
                    break;
                    
                case "RigidBody":
                    ConfigureRigidBody(wrapper.GameObject, compDef);
                    break;
                    
                case "Light":
                    ConfigureLight(wrapper.GameObject, compDef);
                    break;
                    
                case "Camera":
                    ConfigureCamera(wrapper.GameObject, compDef);
                    break;
                    
                case "AudioSource":
                    ConfigureAudioSource(wrapper.GameObject, compDef);
                    break;
                    
                case "ObjectBehaviour":
                    ConfigureObjectBehaviour(wrapper, compDef);
                    break;
                    
                default:
                    logger.LogWarning($"Unknown component type: {compDef.type}");
                    break;
            }
        }
        
        private void ConfigureTransform(Transform transform, ComponentDefinition compDef)
        {
            var position = compDef.GetProperty<float[]>("position", new float[] { 0, 0, 0 });
            var rotation = compDef.GetProperty<float[]>("rotation", new float[] { 0, 0, 0 });
            var scale = compDef.GetProperty<float[]>("scale", new float[] { 1, 1, 1 });
            
            transform.position = new Vector3(position[0], position[1], position[2]);
            transform.rotation = Quaternion.Euler(rotation[0], rotation[1], rotation[2]);
            transform.localScale = new Vector3(scale[0], scale[1], scale[2]);
        }
        
        private async Task ConfigureMeshRenderer(GameObject obj, ComponentDefinition compDef)
        {
            var renderer = obj.AddComponent<MeshRenderer>();
            var meshFilter = obj.AddComponent<MeshFilter>();
            
            // è®¾ç½®ç½‘æ ¼
            var meshType = compDef.GetProperty<string>("meshType", "cube");
            meshFilter.mesh = GetPrimitiveMesh(meshType);
            
            // è®¾ç½®æè´¨
            var material = new Material(Shader.Find("Standard"));
            var color = compDef.GetProperty<float[]>("color", new float[] { 1, 1, 1, 1 });
            material.color = new Color(color[0], color[1], color[2], color[3]);
            
            var metallic = compDef.GetProperty<float>("metallic", 0f);
            material.SetFloat("_Metallic", metallic);
            
            var smoothness = compDef.GetProperty<float>("smoothness", 0.5f);
            material.SetFloat("_Glossiness", smoothness);
            
            renderer.material = material;
            
            // å¦‚æœæŒ‡å®šäº†æ¨¡å‹æ–‡ä»¶ï¼Œå°è¯•åŠ è½½
            var modelPath = compDef.GetProperty<string>("model");
            if (!string.IsNullOrEmpty(modelPath))
            {
                await LoadGLTFModel(obj, modelPath);
            }
        }
        
        private Mesh GetPrimitiveMesh(string meshType)
        {
            var primitiveType = meshType.ToLower() switch
            {
                "cube" => PrimitiveType.Cube,
                "sphere" => PrimitiveType.Sphere,
                "cylinder" => PrimitiveType.Cylinder,
                "capsule" => PrimitiveType.Capsule,
                "plane" => PrimitiveType.Plane,
                "quad" => PrimitiveType.Quad,
                _ => PrimitiveType.Cube
            };
            
            var tempObj = GameObject.CreatePrimitive(primitiveType);
            var mesh = tempObj.GetComponent<MeshFilter>().sharedMesh;
            GameObject.Destroy(tempObj);
            return mesh;
        }
        
        private void ConfigureBoxCollider(GameObject obj, ComponentDefinition compDef)
        {
            var collider = obj.AddComponent<BoxCollider>();
            
            var center = compDef.GetProperty<float[]>("center", new float[] { 0, 0, 0 });
            var size = compDef.GetProperty<float[]>("size", new float[] { 1, 1, 1 });
            var isTrigger = compDef.GetProperty<bool>("isTrigger", false);
            
            collider.center = new Vector3(center[0], center[1], center[2]);
            collider.size = new Vector3(size[0], size[1], size[2]);
            collider.isTrigger = isTrigger;
        }
        
        private void ConfigureSphereCollider(GameObject obj, ComponentDefinition compDef)
        {
            var collider = obj.AddComponent<SphereCollider>();
            
            var center = compDef.GetProperty<float[]>("center", new float[] { 0, 0, 0 });
            var radius = compDef.GetProperty<float>("radius", 0.5f);
            var isTrigger = compDef.GetProperty<bool>("isTrigger", false);
            
            collider.center = new Vector3(center[0], center[1], center[2]);
            collider.radius = radius;
            collider.isTrigger = isTrigger;
        }
        
        private void ConfigureRigidBody(GameObject obj, ComponentDefinition compDef)
        {
            var rb = obj.AddComponent<Rigidbody>();
            
            rb.mass = compDef.GetProperty<float>("mass", 1f);
            rb.drag = compDef.GetProperty<float>("drag", 0f);
            rb.angularDrag = compDef.GetProperty<float>("angularDrag", 0.05f);
            rb.useGravity = compDef.GetProperty<bool>("useGravity", true);
            rb.isKinematic = compDef.GetProperty<bool>("isKinematic", false);
            
            var constraints = compDef.GetProperty<string[]>("constraints");
            if (constraints != null)
            {
                RigidbodyConstraints rbConstraints = RigidbodyConstraints.None;
                foreach (var constraint in constraints)
                {
                    if (System.Enum.TryParse<RigidbodyConstraints>(constraint, out var c))
                    {
                        rbConstraints |= c;
                    }
                }
                rb.constraints = rbConstraints;
            }
        }
        
        private void ConfigureLight(GameObject obj, ComponentDefinition compDef)
        {
            var light = obj.AddComponent<Light>();
            
            var lightType = compDef.GetProperty<string>("lightType", "Directional");
            if (System.Enum.TryParse<LightType>(lightType, out var type))
            {
                light.type = type;
            }
            
            var color = compDef.GetProperty<float[]>("color", new float[] { 1, 1, 1, 1 });
            light.color = new Color(color[0], color[1], color[2], color[3]);
            
            light.intensity = compDef.GetProperty<float>("intensity", 1f);
            light.range = compDef.GetProperty<float>("range", 10f);
            light.spotAngle = compDef.GetProperty<float>("spotAngle", 30f);
            light.shadows = compDef.GetProperty<bool>("shadows", false) ? 
                LightShadows.Soft : LightShadows.None;
        }
        
        private void ConfigureCamera(GameObject obj, ComponentDefinition compDef)
        {
            var camera = obj.AddComponent<Camera>();
            
            camera.fieldOfView = compDef.GetProperty<float>("fieldOfView", 60f);
            camera.nearClipPlane = compDef.GetProperty<float>("nearClipPlane", 0.3f);
            camera.farClipPlane = compDef.GetProperty<float>("farClipPlane", 1000f);
            camera.depth = compDef.GetProperty<float>("depth", 0f);
            
            var clearFlags = compDef.GetProperty<string>("clearFlags", "Skybox");
            if (System.Enum.TryParse<CameraClearFlags>(clearFlags, out var flags))
            {
                camera.clearFlags = flags;
            }
            
            var backgroundColor = compDef.GetProperty<float[]>("backgroundColor", 
                new float[] { 0.19f, 0.3f, 0.47f, 1f });
            camera.backgroundColor = new Color(
                backgroundColor[0], 
                backgroundColor[1], 
                backgroundColor[2], 
                backgroundColor[3]
            );
        }
        
        private void ConfigureAudioSource(GameObject obj, ComponentDefinition compDef)
        {
            var audioSource = obj.AddComponent<AudioSource>();
            
            audioSource.volume = compDef.GetProperty<float>("volume", 1f);
            audioSource.pitch = compDef.GetProperty<float>("pitch", 1f);
            audioSource.loop = compDef.GetProperty<bool>("loop", false);
            audioSource.playOnAwake = compDef.GetProperty<bool>("playOnAwake", false);
            audioSource.spatialBlend = compDef.GetProperty<float>("spatialBlend", 1f);
            audioSource.minDistance = compDef.GetProperty<float>("minDistance", 1f);
            audioSource.maxDistance = compDef.GetProperty<float>("maxDistance", 500f);
        }
        
        private async Task LoadGLTFModel(GameObject obj, string modelPath)
        {
            // è¿™é‡Œåº”è¯¥ä½¿ç”¨å®é™…çš„glTFåŠ è½½åº“
            logger.Log($"Would load glTF model from: {modelPath}");
            await Task.Delay(100); // æ¨¡æ‹Ÿå¼‚æ­¥åŠ è½½
        }
    }
    
    /// <summary>
    /// Unity GameObjectçš„åŒ…è£…å™¨ï¼Œå®ç°IGameObjectæ¥å£
    /// </summary>
    public class UnityGameObjectWrapper : IGameObject
    {
        public GameObject GameObject { get; }
        
        public UnityGameObjectWrapper(GameObject gameObject)
        {
            GameObject = gameObject;
        }
        
        public string Name
        {
            get => GameObject.name;
            set => GameObject.name = value;
        }
        
        public bool IsActive
        {
            get => GameObject.activeSelf;
            set => GameObject.SetActive(value);
        }
        
        public ITransform Transform => new UnityTransformWrapper(GameObject.transform);
        
        public T GetComponent<T>() where T : class
        {
            if (typeof(T) == typeof(ObjectBehaviourComponent))
            {
                var comp = GameObject.GetComponent<UnityObjectBehaviourComponent>();
                return comp as T;
            }
            
            var component = GameObject.GetComponent(typeof(T));
            return component as T;
        }
        
        public T AddComponent<T>() where T : class
        {
            if (typeof(T) == typeof(ObjectBehaviourComponent))
            {
                var comp = GameObject.AddComponent<UnityObjectBehaviourComponent>();
                return comp as T;
            }
            
            var component = GameObject.AddComponent(typeof(T) as System.Type);
            return component as T;
        }
    }
    
    /// <summary>
    /// Unity Transformçš„åŒ…è£…å™¨
    /// </summary>
    public class UnityTransformWrapper : ITransform
    {
        private readonly Transform transform;
        
        public UnityTransformWrapper(Transform transform)
        {
            this.transform = transform;
        }
        
        public Vector3 Position
        {
            get => transform.position;
            set => transform.position = value;
        }
        
        public Quaternion Rotation
        {
            get => transform.rotation;
            set => transform.rotation = value;
        }
        
        public Vector3 Scale
        {
            get => transform.localScale;
            set => transform.localScale = value;
        }
        
        public ITransform Parent
        {
            get => transform.parent != null ? new UnityTransformWrapper(transform.parent) : null;
            set
            {
                if (value is UnityTransformWrapper wrapper)
                {
                    transform.parent = wrapper.transform;
                }
            }
        }
    }
    
    /// <summary>
    /// Unityä¸­çš„ObjectBehaviourç»„ä»¶
    /// </summary>
    public class UnityObjectBehaviourComponent : MonoBehaviour, ObjectBehaviourComponent
    {
        public IObjectBehaviour Behaviour { get; set; }
        
        void OnDestroy()
        {
            Behaviour?.OnDetach();
        }
    }
}
```

#### ModBehaviourUpdater

```csharp
// ModSystem.Unity/ModBehaviourUpdater.cs
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity
{
    /// <summary>
    /// Unityç»„ä»¶ï¼Œè´Ÿè´£è°ƒç”¨æ¨¡ç»„è¡Œä¸ºçš„Updateæ–¹æ³•
    /// </summary>
    public class ModBehaviourUpdater : MonoBehaviour
    {
        private IModBehaviour behaviour;
        private float lastUpdateTime;
        
        public void Initialize(IModBehaviour behaviour)
        {
            this.behaviour = behaviour;
            lastUpdateTime = Time.time;
        }
        
        void Update()
        {
            if (behaviour != null)
            {
                float deltaTime = Time.time - lastUpdateTime;
                behaviour.OnUpdate(deltaTime);
                lastUpdateTime = Time.time;
            }
        }
        
        void OnDestroy()
        {
            behaviour?.OnDestroy();
        }
        
        void OnEnable()
        {
            // å¯ä»¥æ·»åŠ æ¢å¤é€»è¾‘
        }
        
        void OnDisable()
        {
            // å¯ä»¥æ·»åŠ æš‚åœé€»è¾‘
        }
    }
}
```

### äº‹ä»¶ç›‘æ§å’Œè°ƒè¯•å·¥å…· ğŸ”µ

```csharp
// ModSystem.Unity/Debug/EventMonitor.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity.Debug
{
    public class EventMonitor : MonoBehaviour, IEventLogger
    {
        [SerializeField] private bool showUI = true;
        [SerializeField] private int maxEventHistory = 100;
        [SerializeField] private Vector2 windowPosition = new Vector2(10, 10);
        [SerializeField] private Vector2 windowSize = new Vector2(600, 400);
        
        private List<EventLogEntry> eventHistory = new List<EventLogEntry>();
        private Vector2 scrollPosition;
        private bool isWindowMinimized = false;
        private Dictionary<string, int> eventCounts = new Dictionary<string, int>();
        private string filterText = "";
        private bool showOnlyErrors = false;
        private HashSet<string> mutedEventTypes = new HashSet<string>();
        private bool isPaused = false;
        
        // æ€§èƒ½ç»Ÿè®¡
        private Dictionary<string, EventStats> eventStats = new Dictionary<string, EventStats>();
        
        public class EventLogEntry
        {
            public DateTime Timestamp { get; set; }
            public string EventType { get; set; }
            public string SenderId { get; set; }
            public string Details { get; set; }
            public LogLevel Level { get; set; }
            public Color Color { get; set; }
        }
        
        public class EventStats
        {
            public int Count { get; set; }
            public float TotalProcessingTime { get; set; }
            public float AverageProcessingTime => Count > 0 ? TotalProcessingTime / Count : 0;
            public float MaxProcessingTime { get; set; }
            public DateTime LastOccurrence { get; set; }
        }
        
        public enum LogLevel
        {
            Info,
            Warning,
            Error
        }
        
        void Awake()
        {
            DontDestroyOnLoad(gameObject);
        }
        
        void Start()
        {
            var controller = FindObjectOfType<ModSystemController>();
            if (controller != null && controller.EventBus is ModEventBus eventBus)
            {
                eventBus.OnEventPublished += OnEventPublished;
            }
        }
        
        private void OnEventPublished(IModEvent e)
        {
            if (isPaused) return;
            
            if (!mutedEventTypes.Contains(e.GetType().Name))
            {
                LogEvent(e);
            }
        }
        
        public void LogEvent(IModEvent e)
        {
            var entry = new EventLogEntry
            {
                Timestamp = e.Timestamp,
                EventType = e.GetType().Name,
                SenderId = e.SenderId ?? "Unknown",
                Details = SerializeEventDetails(e),
                Level = LogLevel.Info,
                Color = GetEventColor(e)
            };
            
            AddLogEntry(entry);
            UpdateStats(e.GetType().Name);
        }
        
        private void UpdateStats(string eventType)
        {
            if (!eventStats.ContainsKey(eventType))
            {
                eventStats[eventType] = new EventStats();
            }
            
            var stats = eventStats[eventType];
            stats.Count++;
            stats.LastOccurrence = DateTime.Now;
            
            // æ›´æ–°äº‹ä»¶è®¡æ•°
            if (!eventCounts.ContainsKey(eventType))
                eventCounts[eventType] = 0;
            eventCounts[eventType]++;
        }
        
        void OnGUI()
        {
            if (!showUI) return;
            
            // ä½¿ç”¨æ›´ç°ä»£çš„GUIæ ·å¼
            GUI.skin.window = CreateWindowStyle();
            GUI.skin.button = CreateButtonStyle();
            
            var windowRect = new Rect(windowPosition, windowSize);
            windowRect = GUI.Window(0, windowRect, DrawWindow, "Event Monitor");
            windowPosition = windowRect.position;
        }
        
        private GUIStyle CreateWindowStyle()
        {
            var style = new GUIStyle(GUI.skin.window);
            style.normal.background = CreateTexture(new Color(0.2f, 0.2f, 0.2f, 0.95f));
            style.normal.textColor = Color.white;
            style.fontSize = 14;
            style.fontStyle = FontStyle.Bold;
            return style;
        }
        
        private GUIStyle CreateButtonStyle()
        {
            var style = new GUIStyle(GUI.skin.button);
            style.normal.background = CreateTexture(new Color(0.3f, 0.3f, 0.3f, 1f));
            style.hover.background = CreateTexture(new Color(0.4f, 0.4f, 0.4f, 1f));
            style.active.background = CreateTexture(new Color(0.5f, 0.5f, 0.5f, 1f));
            style.normal.textColor = Color.white;
            return style;
        }
        
        private Texture2D CreateTexture(Color color)
        {
            var texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            return texture;
        }
        
        void DrawWindow(int windowId)
        {
            GUILayout.BeginVertical();
            
            // æ ‡é¢˜æ 
            DrawTitleBar();
            
            if (!isWindowMinimized)
            {
                // å·¥å…·æ 
                DrawToolbar();
                
                // é€‰é¡¹å¡
                DrawTabs();
                
                // å†…å®¹åŒºåŸŸ
                DrawContent();
            }
            
            GUILayout.EndVertical();
            
            GUI.DragWindow();
        }
        
        private enum Tab
        {
            Events,
            Statistics,
            Settings
        }
        
        private Tab currentTab = Tab.Events;
        
        void DrawTabs()
        {
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Toggle(currentTab == Tab.Events, "Events", "Button"))
                currentTab = Tab.Events;
            
            if (GUILayout.Toggle(currentTab == Tab.Statistics, "Statistics", "Button"))
                currentTab = Tab.Statistics;
            
            if (GUILayout.Toggle(currentTab == Tab.Settings, "Settings", "Button"))
                currentTab = Tab.Settings;
            
            GUILayout.EndHorizontal();
        }
        
        void DrawContent()
        {
            switch (currentTab)
            {
                case Tab.Events:
                    DrawEventList();
                    break;
                case Tab.Statistics:
                    DrawStatistics();
                    break;
                case Tab.Settings:
                    DrawSettings();
                    break;
            }
        }
        
        void DrawStatistics()
        {
            GUILayout.BeginVertical("box");
            
            GUILayout.Label("Event Statistics", "BoldLabel");
            
            // æ’åºç»Ÿè®¡æ•°æ®
            var sortedStats = eventStats.OrderByDescending(kvp => kvp.Value.Count).ToList();
            
            scrollPosition = GUILayout.BeginScrollView(scrollPosition);
            
            foreach (var kvp in sortedStats)
            {
                GUILayout.BeginHorizontal("box");
                
                GUILayout.Label(kvp.Key, GUILayout.Width(200));
                GUILayout.Label($"Count: {kvp.Value.Count}", GUILayout.Width(100));
                GUILayout.Label($"Avg: {kvp.Value.AverageProcessingTime:F2}ms", GUILayout.Width(100));
                GUILayout.Label($"Max: {kvp.Value.MaxProcessingTime:F2}ms", GUILayout.Width(100));
                GUILayout.Label($"Last: {kvp.Value.LastOccurrence:HH:mm:ss}", GUILayout.Width(100));
                
                if (GUILayout.Button("Mute", GUILayout.Width(50)))
                {
                    if (mutedEventTypes.Contains(kvp.Key))
                        mutedEventTypes.Remove(kvp.Key);
                    else
                        mutedEventTypes.Add(kvp.Key);
                }
                
                GUILayout.EndHorizontal();
            }
            
            GUILayout.EndScrollView();
            GUILayout.EndVertical();
        }
        
        void DrawSettings()
        {
            GUILayout.BeginVertical("box");
            
            GUILayout.Label("Monitor Settings", "BoldLabel");
            
            maxEventHistory = (int)GUILayout.HorizontalSlider(maxEventHistory, 10, 1000);
            GUILayout.Label($"Max Event History: {maxEventHistory}");
            
            showOnlyErrors = GUILayout.Toggle(showOnlyErrors, "Show Only Errors");
            
            GUILayout.Space(20);
            
            GUILayout.Label("Muted Events:");
            foreach (var eventType in mutedEventTypes.ToList())
            {
                GUILayout.BeginHorizontal();
                GUILayout.Label(eventType);
                if (GUILayout.Button("Unmute", GUILayout.Width(60)))
                {
                    mutedEventTypes.Remove(eventType);
                }
                GUILayout.EndHorizontal();
            }
            
            GUILayout.EndVertical();
        }
        
        // å…¶ä»–GUIæ–¹æ³•å®ç°...
        
        void Update()
        {
            // å¿«æ·é”®
            if (Input.GetKeyDown(KeyCode.F12))
            {
                showUI = !showUI;
            }
            
            if (Input.GetKeyDown(KeyCode.F11))
            {
                isPaused = !isPaused;
            }
        }
        
        // IEventLoggerå®ç°
        public void LogSubscription(string eventType, string subscriber)
        {
            var entry = new EventLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = "Subscription",
                SenderId = subscriber ?? "Unknown",
                Details = $"Subscribed to {eventType}",
                Level = LogLevel.Info,
                Color = Color.cyan
            };
            
            AddLogEntry(entry);
        }
        
        public void LogError(string message)
        {
            var entry = new EventLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = "Error",
                SenderId = "System",
                Details = message,
                Level = LogLevel.Error,
                Color = Color.red
            };
            
            AddLogEntry(entry);
        }
        
        private void AddLogEntry(EventLogEntry entry)
        {
            eventHistory.Add(entry);
            
            // ä¿æŒå†å²è®°å½•åœ¨é™åˆ¶èŒƒå›´å†…
            while (eventHistory.Count > maxEventHistory)
            {
                eventHistory.RemoveAt(0);
            }
        }
        
        private string SerializeEventDetails(IModEvent e)
        {
            var properties = e.GetType().GetProperties()
                .Where(p => p.Name != "EventId" && p.Name != "SenderId" && p.Name != "Timestamp")
                .Select(p => 
                {
                    try
                    {
                        var value = p.GetValue(e);
                        return $"{p.Name}: {value ?? "null"}";
                    }
                    catch
                    {
                        return $"{p.Name}: <error>";
                    }
                })
                .ToList();
            
            return string.Join(", ", properties);
        }
        
        private Color GetEventColor(IModEvent e)
        {
            // æ ¹æ®äº‹ä»¶ç±»å‹è¿”å›ä¸åŒé¢œè‰²
            var typeName = e.GetType().Name;
            
            if (typeName.Contains("Error") || typeName.Contains("Exception"))
                return Color.red;
            if (typeName.Contains("Warning"))
                return Color.yellow;
            if (typeName.Contains("Success") || typeName.Contains("Complete"))
                return Color.green;
            if (typeName.Contains("Button"))
                return new Color(0.5f, 1f, 0.5f);
            if (typeName.Contains("Robot"))
                return new Color(0.5f, 0.5f, 1f);
            if (typeName.Contains("Service"))
                return Color.yellow;
            
            return Color.white;
        }
    }
}
```

## é…ç½®ç³»ç»Ÿ

### æ¨¡ç»„æ¸…å•ï¼ˆmanifest.jsonï¼‰ğŸŸ¡

```json
{
  "id": "button_robot_controller",
  "name": "æŒ‰é’®æœºå™¨äººæ§åˆ¶å™¨",
  "version": "1.0.0",
  "author": "Your Name",
  "description": "é€šè¿‡æŒ‰é’®æ§åˆ¶æœºå™¨äººæ‰‹è‡‚çš„æ¨¡ç»„",
  "unity_version": "2021.3",
  "sdk_version": "1.0.0",
  "main_class": "ButtonRobotController.MainBehaviour",
  "dependencies": [
    {
      "id": "mod_system_core",
      "version": ">=1.0.0",
      "optional": false
    }
  ],
  "services": [
    {
      "interface": "IRobotService",
      "implementation": "ButtonRobotController.RobotServiceImpl"
    }
  ],
  "permissions": [
    "event_publish",
    "event_subscribe",
    "service_register",
    "object_create",
    "config_read"
  ],
  "resources": {
    "models": ["Models/button.gltf", "Models/robot_arm.gltf"],
    "objects": ["Objects/interactive_button.json", "Objects/robot_controller.json"],
    "configs": ["Config/main_config.json"],
    "textures": ["Resources/Textures/button_texture.png"],
    "audio": ["Resources/Audio/button_click.wav"]
  },
  "metadata": {
    "tags": ["control", "robot", "button"],
    "category": "interaction",
    "homepage": "https://example.com/mods/button-robot"
  }
}
```

### å¯¹è±¡å®šä¹‰ç¤ºä¾‹ ğŸŸ¡

```json
{
  "objectId": "interactive_button_advanced",
  "name": "é«˜çº§äº¤äº’æŒ‰é’®",
  "components": [
    {
      "type": "Transform",
      "properties": {
        "position": [0, 1, 0],
        "rotation": [0, 0, 0],
        "scale": [1, 0.2, 1]
      }
    },
    {
      "type": "MeshRenderer",
      "properties": {
        "meshType": "cube",
        "color": [0.2, 0.8, 0.2, 1],
        "metallic": 0.5,
        "smoothness": 0.8,
        "model": "Models/button.gltf"
      }
    },
    {
      "type": "BoxCollider",
      "properties": {
        "center": [0, 0, 0],
        "size": [1, 0.2, 1],
        "isTrigger": false
      }
    },
    {
      "type": "RigidBody",
      "properties": {
        "mass": 0.5,
        "drag": 1,
        "angularDrag": 1,
        "useGravity": false,
        "isKinematic": true
      }
    },
    {
      "type": "AudioSource",
      "properties": {
        "clip": "audio/button_click.wav",
        "volume": 0.8,
        "pitch": 1,
        "playOnAwake": false,
        "spatialBlend": 1
      }
    },
    {
      "type": "Light",
      "properties": {
        "lightType": "Point",
        "color": [0, 1, 0, 1],
        "intensity": 2,
        "range": 5,
        "shadows": true
      }
    },
    {
      "type": "ObjectBehaviour",
      "properties": {
        "behaviourClass": "ButtonMod.InteractiveButtonBehaviour",
        "config": {
          "buttonId": "advanced_btn_01",
          "buttonType": "toggle",
          "clickSound": "button_click",
          "glowOnHover": true,
          "pressDepth": 0.05,
          "cooldownTime": 0.3
        }
      }
    }
  ]
}
```

### é€šä¿¡é…ç½® ğŸŸ¡

```json
{
  "routes": [
    {
      "name": "button_controls_robot",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "robot_control_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.MoveJointEvent",
          "parameters": {
            "jointName": "base_rotation",
            "angle": 45,
            "speed": 30
          },
          "delay": 0
        }
      ],
      "enabled": true,
      "priority": 10
    },
    {
      "name": "emergency_stop_all",
      "sourceEvent": "SafetyMod.EmergencyButtonEvent",
      "conditions": [],
      "actions": [
        {
          "eventType": "ModSystem.Core.EmergencyStopEvent",
          "parameters": {
            "reason": "Emergency button pressed"
          }
        }
      ],
      "enabled": true,
      "priority": 100
    }
  ],
  "workflows": [
    {
      "name": "robot_startup_sequence",
      "trigger": {
        "event": "SystemMod.StartupEvent"
      },
      "steps": [
        {
          "action": "publish_event",
          "event": "RobotMod.InitializeEvent",
          "delay": 1000
        },
        {
          "action": "wait_for_event",
          "event": "RobotMod.InitializedEvent",
          "timeout": 5000
        },
        {
          "action": "publish_event",
          "event": "RobotMod.HomePositionEvent"
        }
      ]
    }
  ],
  "settings": {
    "enableDebugLogging": true,
    "maxConcurrentActions": 10,
    "defaultActionTimeout": 5000
  }
}
```

## ç‹¬ç«‹å¼€å‘SDK

### ModBuilder 2.0ï¼ˆåŸºäºæ¨¡æ¿ç³»ç»Ÿï¼‰ğŸŸ¢

```csharp
// ModBuilder/Program.cs
using System;
using System.IO;
using System.Text.Json;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace ModBuilder
{
    class Program
    {
        private static readonly string SDKPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "SDK");
        private static readonly string TemplatesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Templates");
        private static readonly string UserTemplatesPath = Path.Combine(TemplatesPath, "UserTemplates");
        
        static void Main(string[] args)
        {
            Console.WriteLine("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            Console.WriteLine("â•‘     Mod Builder v2.0.0       â•‘");
            Console.WriteLine("â•‘   Unityæ¨¡ç»„ç‹¬ç«‹å¼€å‘å·¥å…·       â•‘");
            Console.WriteLine("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
            
            if (args.Length == 0)
            {
                ShowInteractiveMenu();
            }
            else
            {
                ProcessCommand(args);
            }
        }
        
        static void ShowInteractiveMenu()
        {
            while (true)
            {
                Console.WriteLine("\nè¯·é€‰æ‹©æ“ä½œ:");
                Console.WriteLine("1. åˆ›å»ºæ–°æ¨¡ç»„é¡¹ç›®");
                Console.WriteLine("2. æ„å»ºç°æœ‰æ¨¡ç»„");
                Console.WriteLine("3. æµ‹è¯•æ¨¡ç»„");
                Console.WriteLine("4. æ‰“åŒ…æ¨¡ç»„");
                Console.WriteLine("5. ç®¡ç†æ¨¡æ¿");
                Console.WriteLine("6. æŸ¥çœ‹å¸®åŠ©");
                Console.WriteLine("7. é€€å‡º");
                Console.Write("\nè¯·è¾“å…¥é€‰é¡¹ (1-7): ");
                
                var choice = Console.ReadLine();
                Console.WriteLine();
                
                switch (choice)
                {
                    case "1":
                        CreateNewMod();
                        break;
                    case "2":
                        BuildMod();
                        break;
                    case "3":
                        TestMod();
                        break;
                    case "4":
                        PackageMod();
                        break;
                    case "5":
                        ManageTemplates();
                        break;
                    case "6":
                        ShowHelp();
                        break;
                    case "7":
                        return;
                    default:
                        Console.WriteLine("æ— æ•ˆé€‰é¡¹ï¼Œè¯·é‡è¯•ã€‚");
                        break;
                }
            }
        }
        
        static void CreateNewMod()
        {
            Console.WriteLine("=== åˆ›å»ºæ–°æ¨¡ç»„ ===\n");
            
            // è·å–å¯ç”¨æ¨¡æ¿
            var templates = GetAvailableTemplates();
            if (templates.Count == 0)
            {
                Console.WriteLine("é”™è¯¯ï¼šæ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„æ¨¡æ¿ã€‚");
                return;
            }
            
            // æ˜¾ç¤ºæ¨¡æ¿åˆ—è¡¨
            Console.WriteLine("å¯ç”¨æ¨¡æ¿:");
            for (int i = 0; i < templates.Count; i++)
            {
                Console.WriteLine($"{i + 1}. {templates[i].Name} - {templates[i].Description}");
            }
            
            Console.Write("\né€‰æ‹©æ¨¡æ¿ (è¾“å…¥ç¼–å·): ");
            if (!int.TryParse(Console.ReadLine(), out int templateIndex) || 
                templateIndex < 1 || templateIndex > templates.Count)
            {
                Console.WriteLine("æ— æ•ˆçš„é€‰æ‹©ã€‚");
                return;
            }
            
            var selectedTemplate = templates[templateIndex - 1];
            
            // æ”¶é›†å˜é‡å€¼
            var variables = new Dictionary<string, string>();
            
            Console.Write("\næ¨¡ç»„ID (ä¾‹å¦‚: my_custom_mod): ");
            variables["ModId"] = Console.ReadLine()?.ToLower().Replace(" ", "_");
            
            Console.Write("æ¨¡ç»„åç§°: ");
            variables["ModName"] = Console.ReadLine();
            
            Console.Write("ä½œè€…åç§°: ");
            variables["Author"] = Console.ReadLine();
            
            // æ”¶é›†æ¨¡æ¿ç‰¹å®šå˜é‡
            foreach (var varDef in selectedTemplate.Variables)
            {
                if (!variables.ContainsKey(varDef.Name))
                {
                    Console.Write($"{varDef.Description}: ");
                    variables[varDef.Name] = Console.ReadLine();
                }
            }
            
            // æ·»åŠ è¡ç”Ÿå˜é‡
            variables["PascalCaseModId"] = ToPascalCase(variables["ModId"]);
            variables["Year"] = DateTime.Now.Year.ToString();
            variables["Date"] = DateTime.Now.ToString("yyyy-MM-dd");
            
            // åˆ›å»ºé¡¹ç›®
            var projectPath = Path.Combine(Directory.GetCurrentDirectory(), variables["ModId"]);
            
            try
            {
                CreateProjectFromTemplate(projectPath, selectedTemplate, variables);
                Console.WriteLine($"\nâœ“ æ¨¡ç»„é¡¹ç›®åˆ›å»ºæˆåŠŸ!");
                Console.WriteLine($"  ä½ç½®: {projectPath}");
                Console.WriteLine($"\nä¸‹ä¸€æ­¥:");
                Console.WriteLine($"  1. cd {variables["ModId"]}");
                Console.WriteLine($"  2. ç¼–è¾‘æºä»£ç å’Œé…ç½®æ–‡ä»¶");
                Console.WriteLine($"  3. è¿è¡Œ ModBuilder build æ„å»ºæ¨¡ç»„");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\nâœ— åˆ›å»ºå¤±è´¥: {ex.Message}");
            }
        }
        
        static List<ModTemplate> GetAvailableTemplates()
        {
            var templates = new List<ModTemplate>();
            
            // åŠ è½½å†…ç½®æ¨¡æ¿
            LoadTemplatesFromDirectory(Path.Combine(TemplatesPath, "BuiltIn"), templates);
            
            // åŠ è½½ç”¨æˆ·æ¨¡æ¿
            if (Directory.Exists(UserTemplatesPath))
            {
                LoadTemplatesFromDirectory(UserTemplatesPath, templates);
            }
            
            return templates;
        }
        
        static void LoadTemplatesFromDirectory(string directory, List<ModTemplate> templates)
        {
            if (!Directory.Exists(directory))
                return;
            
            foreach (var templateDir in Directory.GetDirectories(directory))
            {
                var templateFile = Path.Combine(templateDir, "template.json");
                if (File.Exists(templateFile))
                {
                    try
                    {
                        var json = File.ReadAllText(templateFile);
                        var template = JsonSerializer.Deserialize<ModTemplate>(json);
                        template.Path = templateDir;
                        templates.Add(template);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"è­¦å‘Šï¼šæ— æ³•åŠ è½½æ¨¡æ¿ {templateDir}: {ex.Message}");
                    }
                }
            }
        }
        
        static void CreateProjectFromTemplate(string projectPath, ModTemplate template, Dictionary<string, string> variables)
        {
            // åˆ›å»ºé¡¹ç›®ç›®å½•
            Directory.CreateDirectory(projectPath);
            
            // å¤„ç†æ¯ä¸ªæ–‡ä»¶è§„åˆ™
            foreach (var fileRule in template.Files)
            {
                var sourcePath = Path.Combine(template.Path, fileRule.Template);
                var destPath = Path.Combine(projectPath, ProcessTemplate(fileRule.Output, variables));
                
                // åˆ›å»ºç›®æ ‡ç›®å½•
                var destDir = Path.GetDirectoryName(destPath);
                if (!string.IsNullOrEmpty(destDir))
                {
                    Directory.CreateDirectory(destDir);
                }
                
                // å¤„ç†æ–‡ä»¶
                if (fileRule.IsBinary)
                {
                    // äºŒè¿›åˆ¶æ–‡ä»¶ç›´æ¥å¤åˆ¶
                    File.Copy(sourcePath, destPath);
                }
                else
                {
                    // æ–‡æœ¬æ–‡ä»¶è¿›è¡Œæ¨¡æ¿å¤„ç†
                    var content = File.ReadAllText(sourcePath);
                    content = ProcessTemplate(content, variables);
                    File.WriteAllText(destPath, content);
                }
            }
            
            // å¤åˆ¶SDK
            var sdkDestPath = Path.Combine(projectPath, "SDK");
            CopyDirectory(SDKPath, sdkDestPath);
            
            // åˆ›å»ºé¢å¤–çš„ç›®å½•ç»“æ„
            foreach (var dir in template.Directories ?? new List<string>())
            {
                var dirPath = Path.Combine(projectPath, ProcessTemplate(dir, variables));
                Directory.CreateDirectory(dirPath);
            }
            
            // æ‰§è¡Œåå¤„ç†è„šæœ¬
            if (!string.IsNullOrEmpty(template.PostCreateScript))
            {
                ExecutePostCreateScript(projectPath, template.PostCreateScript, variables);
            }
        }
        
        static string ProcessTemplate(string template, Dictionary<string, string> variables)
        {
            var result = template;
            
            // æ›¿æ¢å˜é‡
            foreach (var kvp in variables)
            {
                result = result.Replace($"{{{{{kvp.Key}}}}}", kvp.Value);
            }
            
            // å¤„ç†å†…ç½®å‡½æ•°
            result = Regex.Replace(result, @"{{PascalCase\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? ToPascalCase(variables[varName]) : m.Value;
            });
            
            result = Regex.Replace(result, @"{{CamelCase\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? ToCamelCase(variables[varName]) : m.Value;
            });
            
            result = Regex.Replace(result, @"{{Upper\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? variables[varName].ToUpper() : m.Value;
            });
            
            result = Regex.Replace(result, @"{{Lower\s+(\w+)}}", m =>
            {
                var varName = m.Groups[1].Value;
                return variables.ContainsKey(varName) ? variables[varName].ToLower() : m.Value;
            });
            
            return result;
        }
        
        static void ManageTemplates()
        {
            Console.WriteLine("=== æ¨¡æ¿ç®¡ç† ===\n");
            Console.WriteLine("1. åˆ—å‡ºæ‰€æœ‰æ¨¡æ¿");
            Console.WriteLine("2. å®‰è£…æ–°æ¨¡æ¿");
            Console.WriteLine("3. åˆ›å»ºè‡ªå®šä¹‰æ¨¡æ¿");
            Console.WriteLine("4. åˆ é™¤æ¨¡æ¿");
            Console.WriteLine("5. è¿”å›");
            
            Console.Write("\nè¯·é€‰æ‹©: ");
            var choice = Console.ReadLine();
            
            switch (choice)
            {
                case "1":
                    ListTemplates();
                    break;
                case "2":
                    InstallTemplate();
                    break;
                case "3":
                    CreateCustomTemplate();
                    break;
                case "4":
                    DeleteTemplate();
                    break;
            }
        }
        
        static void CreateCustomTemplate()
        {
            Console.WriteLine("\n=== åˆ›å»ºè‡ªå®šä¹‰æ¨¡æ¿ ===\n");
            
            Console.Write("æ¨¡æ¿ID: ");
            var templateId = Console.ReadLine();
            
            Console.Write("æ¨¡æ¿åç§°: ");
            var templateName = Console.ReadLine();
            
            Console.Write("æ¨¡æ¿æè¿°: ");
            var description = Console.ReadLine();
            
            Console.Write("åŸºäºç°æœ‰é¡¹ç›®åˆ›å»º? (y/n): ");
            var useExisting = Console.ReadLine()?.ToLower() == "y";
            
            if (useExisting)
            {
                Console.Write("é¡¹ç›®è·¯å¾„: ");
                var projectPath = Console.ReadLine();
                
                if (!Directory.Exists(projectPath))
                {
                    Console.WriteLine("é”™è¯¯ï¼šé¡¹ç›®è·¯å¾„ä¸å­˜åœ¨ã€‚");
                    return;
                }
                
                CreateTemplateFromProject(templateId, templateName, description, projectPath);
            }
            else
            {
                CreateEmptyTemplate(templateId, templateName, description);
            }
        }
        
        // å…¶ä»–æ–¹æ³•å®ç°...
        
        static string ToPascalCase(string text)
        {
            return string.Join("", text.Split('_')
                .Select(word => char.ToUpper(word[0]) + word.Substring(1).ToLower()));
        }
        
        static string ToCamelCase(string text)
        {
            var pascal = ToPascalCase(text);
            return char.ToLower(pascal[0]) + pascal.Substring(1);
        }
    }
    
    // æ¨¡æ¿æ•°æ®ç»“æ„
    public class ModTemplate
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public string Version { get; set; }
        public List<TemplateVariable> Variables { get; set; }
        public List<FileRule> Files { get; set; }
        public List<string> Directories { get; set; }
        public string PostCreateScript { get; set; }
        public string Path { get; set; } // è¿è¡Œæ—¶è®¾ç½®
    }
    
    public class TemplateVariable
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public string Type { get; set; }
        public string DefaultValue { get; set; }
        public bool Required { get; set; }
    }
    
    public class FileRule
    {
        public string Template { get; set; }
        public string Output { get; set; }
        public bool IsBinary { get; set; }
    }
}
            