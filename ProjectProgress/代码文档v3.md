# Unity模组通信系统 - 完整实现与文档 v3

## 目录
1. [系统概述](#系统概述)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [通信模式](#通信模式)
5. [完整代码实现](#完整代码实现)
6. [使用示例](#使用示例)
7. [配置说明](#配置说明)
8. [独立模组开发（无需Unity）](#独立模组开发)
9. [最佳实践](#最佳实践)
10. [安装和部署](#安装和部署)
11. [支持系统实现](#支持系统实现)
12. [调试和故障排除](#调试和故障排除)

## 系统概述

本通信系统提供了多种模组间通信方式，以满足不同场景的需求：

- **事件系统**：适用于简单的单向通知
- **请求-响应模式**：适用于需要返回结果的操作
- **服务注册模式**：适用于模组间的紧密协作
- **配置驱动**：通过配置文件定义通信关系

## 项目结构

本系统分为两个主要部分：
1. **Unity主项目** - 包含模组系统核心和运行时
2. **独立开发SDK** - 用于无Unity编辑器的模组开发

### 完整的项目目录结构

```
UnityProject/                              # Unity主项目
├── Assets/
│   ├── ModSystem/                          # 模组系统核心
│   │   ├── Core/                          # 核心框架（所有模组共享）
│   │   │   ├── Interfaces/                # 接口定义
│   │   │   │   ├── IModEvent.cs
│   │   │   │   ├── IModBehaviour.cs
│   │   │   │   ├── IModContext.cs
│   │   │   │   ├── IEventBus.cs
│   │   │   │   ├── IModService.cs
│   │   │   │   └── IServiceRegistry.cs
│   │   │   │
│   │   │   ├── EventSystem/               # 事件系统实现
│   │   │   │   ├── ModEventBus.cs
│   │   │   │   ├── EventLogger.cs
│   │   │   │   └── EventMonitor.cs
│   │   │   │
│   │   │   ├── Communication/             # 通信系统
│   │   │   │   ├── RequestResponse.cs
│   │   │   │   ├── RequestResponseManager.cs
│   │   │   │   ├── CommunicationRouter.cs
│   │   │   │   └── CommunicationConfig.cs
│   │   │   │
│   │   │   ├── Services/                  # 服务系统
│   │   │   │   ├── ModServiceRegistry.cs
│   │   │   │   └── ServiceEvents.cs
│   │   │   │
│   │   │   ├── Runtime/                   # 运行时组件
│   │   │   │   ├── ModManager.cs
│   │   │   │   ├── ModLoader.cs
│   │   │   │   ├── ModContext.cs
│   │   │   │   ├── ModAPI.cs
│   │   │   │   └── ObjectFactory.cs      # 对象工厂（替代prefab）
│   │   │   │
│   │   │   └── ModSystem.Core.asmdef      # 程序集定义文件
│   │   │
│   │   └── Examples/                      # 示例项目
│   │       ├── ButtonMod/
│   │       ├── RobotMod/
│   │       └── SensorMod/
│   │
│   ├── StreamingAssets/                   # 运行时加载的资源
│   │   ├── ModConfigs/                    # 模组配置文件
│   │   │   └── communication_config.json  # 通信配置
│   │   │
│   │   ├── Mods/                          # 开发中的模组（可选）
│   │   │   ├── ButtonMod/
│   │   │   └── RobotMod/
│   │   │
│   │   └── ModPackages/                   # 打包的模组文件
│   │       ├── button_mod_v1.0.modpack
│   │       └── robot_mod_v2.0.modpack
│   │
│   └── Scenes/
│       ├── ModSystemDemo.unity            # 演示场景
│       └── ModTestEnvironment.unity       # 测试环境
│
├── Packages/                              # Unity包管理器
│   └── manifest.json                      # 包依赖配置
│
└── ProjectSettings/                       # Unity项目设置

ModSDK/                                    # 独立开发SDK（不在Unity项目中）
├── SDK/
│   ├── ModSDK.Core.dll                   # 核心接口库
│   ├── ModSDK.Runtime.dll                # 运行时支持库
│   ├── UnityEngine.CoreModule.dll        # Unity运行时（精简版）
│   └── Newtonsoft.Json.dll               # JSON支持
│
├── Tools/
│   ├── ModBuilder.exe                    # 命令行构建工具
│   ├── ModEditor.exe                     # 可视化编辑器
│   └── ModPackager.exe                   # 打包工具
│
├── Templates/                             # 项目模板
│   ├── ButtonMod/
│   ├── RobotMod/
│   └── EmptyMod/
│
└── Documentation/                         # SDK文档

用户模组项目/                              # 用户创建的模组（独立目录）
├── Source/                                # C#源代码
├── Objects/                               # 对象定义（JSON）
├── Models/                                # 3D模型（glTF）
├── Config/                                # 配置文件
├── Resources/                             # 其他资源
├── SDK/                                   # SDK副本
├── [ModName].csproj                      # 项目文件
└── manifest.json                          # 模组清单
```

### 文件组织说明

#### 1. 核心系统文件（ModSystem/Core/）

这是所有模组共享的核心框架，应该编译成独立的DLL供模组引用。

#### 2. 模组文件（Mods/）

每个模组都是独立的文件夹，包含自己的代码、资源和配置：

**按钮模组（ButtonMod/）**
```
ButtonMod/
├── Scripts/
│   ├── ButtonBehaviour.cs        # 主行为脚本
│   ├── ButtonConfiguration.cs    # 配置数据结构
│   └── ButtonEvents.cs          # 按钮相关事件定义
├── Objects/                     # 对象定义（替代prefab）
│   ├── interactive_button.json
│   └── toggle_button.json
├── Models/                      # 3D模型文件
│   └── button.gltf
├── Config/                      # 配置文件
│   └── config.json
├── Resources/                   # 其他资源
│   ├── Textures/
│   └── Audio/
├── ButtonMod.asmdef            # 程序集定义
└── manifest.json               # 模组清单
```

## 核心组件

### 1. 基础接口定义

```csharp
// ModSystem.Core/Interfaces/IModEvent.cs
namespace ModSystem.Core
{
    /// <summary>
    /// 模组事件基础接口
    /// </summary>
    public interface IModEvent
    {
        string EventId { get; }
        string SenderId { get; set; }
        DateTime Timestamp { get; set; }
    }
    
    /// <summary>
    /// 事件总线接口
    /// </summary>
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler) where T : IModEvent;
        void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent;
        void Publish<T>(T eventData) where T : IModEvent;
        void Unsubscribe<T>(Action<T> handler) where T : IModEvent;
    }
    
    /// <summary>
    /// 模组行为接口
    /// </summary>
    public interface IModBehaviour
    {
        string BehaviourId { get; }
        string Version { get; }
        void OnInitialize(IModContext context);
        void OnUpdate(float deltaTime);
        void OnDestroy();
    }
    
    /// <summary>
    /// 模组上下文接口
    /// </summary>
    public interface IModContext
    {
        string ModId { get; }
        GameObject GameObject { get; }
        IEventBus EventBus { get; }
        IModAPI API { get; }
        IServiceRegistry Services { get; }
        T GetComponent<T>() where T : Component;
        void Log(string message);
        void LogError(string message);
    }
}
```

### 2. 事件总线实现

```csharp
// ModSystem.Core/EventSystem/ModEventBus.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace ModSystem.Core
{
    public interface IEventLogger
    {
        void LogEvent(IModEvent e);
        void LogSubscription(string eventType, string subscriber);
        void LogError(string message);
    }
    
    public class ModEventBus : IEventBus
    {
        private readonly Dictionary<Type, List<EventHandler>> handlers;
        private readonly object lockObject = new object();
        private readonly IEventLogger logger;
        
        public event Action<IModEvent> OnEventPublished;
        
        private class EventHandler
        {
            public Delegate Handler { get; set; }
            public Predicate<IModEvent> Filter { get; set; }
            public string SubscriberId { get; set; }
        }
        
        public ModEventBus(IEventLogger logger = null)
        {
            handlers = new Dictionary<Type, List<EventHandler>>();
            this.logger = logger;
        }
        
        public void Subscribe<T>(Action<T> handler) where T : IModEvent
        {
            Subscribe(handler, null);
        }
        
        public void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                {
                    handlers[eventType] = new List<EventHandler>();
                }
                
                handlers[eventType].Add(new EventHandler
                {
                    Handler = handler,
                    Filter = filter != null ? e => filter((T)e) : null,
                    SubscriberId = handler.Target?.GetType().Name ?? "Anonymous"
                });
                
                logger?.LogSubscription(eventType.Name, handler.Target?.GetType().Name);
            }
        }
        
        public void Publish<T>(T eventData) where T : IModEvent
        {
            if (eventData == null) return;
            
            eventData.Timestamp = DateTime.Now;
            logger?.LogEvent(eventData);
            OnEventPublished?.Invoke(eventData);
            
            List<EventHandler> eventHandlers;
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                eventHandlers = handlers[eventType].ToList();
            }
            
            foreach (var handler in eventHandlers)
            {
                try
                {
                    if (handler.Filter != null && !handler.Filter(eventData))
                        continue;
                    
                    ((Action<T>)handler.Handler)?.Invoke(eventData);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Error in event handler: {ex.Message}");
                    logger?.LogError($"Handler error for {typeof(T).Name}: {ex.Message}");
                }
            }
        }
        
        public void Unsubscribe<T>(Action<T> handler) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                handlers[eventType].RemoveAll(h => h.Handler.Equals(handler));
                
                if (handlers[eventType].Count == 0)
                    handlers.Remove(eventType);
            }
        }
    }
}
```

### 3. 请求-响应模式实现

```csharp
// ModSystem.Core/Communication/RequestResponse.cs
namespace ModSystem.Core
{
    public abstract class ModRequest : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; } = Guid.NewGuid().ToString();
    }
    
    public abstract class ModResponse : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; }
        public bool Success { get; set; }
        public string Message { get; set; }
        public object Result { get; set; }
    }
    
    public class RequestResponseManager
    {
        private readonly IEventBus eventBus;
        private readonly Dictionary<string, PendingRequest> pendingRequests;
        
        private class PendingRequest
        {
            public TaskCompletionSource<ModResponse> CompletionSource { get; set; }
            public Type ResponseType { get; set; }
            public DateTime CreatedAt { get; set; }
        }
        
        public RequestResponseManager(IEventBus eventBus)
        {
            this.eventBus = eventBus;
            this.pendingRequests = new Dictionary<string, PendingRequest>();
            CleanupTimeoutRequests();
        }
        
        public async Task<TResponse> SendRequestAsync<TRequest, TResponse>(
            TRequest request, 
            TimeSpan? timeout = null) 
            where TRequest : ModRequest 
            where TResponse : ModResponse
        {
            var actualTimeout = timeout ?? TimeSpan.FromSeconds(30);
            var tcs = new TaskCompletionSource<ModResponse>();
            
            pendingRequests[request.RequestId] = new PendingRequest
            {
                CompletionSource = tcs,
                ResponseType = typeof(TResponse),
                CreatedAt = DateTime.Now
            };
            
            Action<TResponse> responseHandler = null;
            responseHandler = (response) =>
            {
                if (response.RequestId == request.RequestId)
                {
                    if (pendingRequests.TryGetValue(request.RequestId, out var pending))
                    {
                        pending.CompletionSource.TrySetResult(response);
                        pendingRequests.Remove(request.RequestId);
                    }
                    eventBus.Unsubscribe(responseHandler);
                }
            };
            
            eventBus.Subscribe(responseHandler);
            eventBus.Publish(request);
            
            using (var cts = new CancellationTokenSource(actualTimeout))
            {
                try
                {
                    var completedTask = await Task.WhenAny(
                        tcs.Task,
                        Task.Delay(actualTimeout, cts.Token)
                    );
                    
                    if (completedTask == tcs.Task)
                    {
                        return (TResponse)await tcs.Task;
                    }
                    else
                    {
                        eventBus.Unsubscribe(responseHandler);
                        pendingRequests.Remove(request.RequestId);
                        throw new TimeoutException($"Request {request.RequestId} timed out");
                    }
                }
                catch (TaskCanceledException)
                {
                    throw new TimeoutException($"Request {request.RequestId} was cancelled");
                }
            }
        }
        
        private async void CleanupTimeoutRequests()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(1));
                
                var now = DateTime.Now;
                var timeoutRequests = pendingRequests
                    .Where(kvp => (now - kvp.Value.CreatedAt) > TimeSpan.FromMinutes(5))
                    .Select(kvp => kvp.Key)
                    .ToList();
                
                foreach (var requestId in timeoutRequests)
                {
                    if (pendingRequests.TryGetValue(requestId, out var pending))
                    {
                        pending.CompletionSource.TrySetException(
                            new TimeoutException("Request timed out during cleanup")
                        );
                        pendingRequests.Remove(requestId);
                    }
                }
            }
        }
    }
}
```

### 4. 服务注册系统

```csharp
// ModSystem.Core/Services/ServiceRegistry.cs
namespace ModSystem.Core
{
    public interface IModService
    {
        string ServiceId { get; }
        string ProviderId { get; }
        string Version { get; }
    }
    
    public interface IServiceRegistry
    {
        void RegisterService<T>(T service) where T : class, IModService;
        T GetService<T>() where T : class, IModService;
        IEnumerable<T> GetServices<T>() where T : class, IModService;
        bool UnregisterService<T>(string serviceId) where T : class, IModService;
    }
    
    public class ModServiceRegistry : IServiceRegistry
    {
        private readonly Dictionary<Type, Dictionary<string, IModService>> services;
        private readonly IEventBus eventBus;
        
        public ModServiceRegistry(IEventBus eventBus)
        {
            this.services = new Dictionary<Type, Dictionary<string, IModService>>();
            this.eventBus = eventBus;
        }
        
        public void RegisterService<T>(T service) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (!services.ContainsKey(serviceType))
            {
                services[serviceType] = new Dictionary<string, IModService>();
            }
            
            services[serviceType][service.ServiceId] = service;
            
            eventBus?.Publish(new ServiceRegisteredEvent
            {
                ServiceType = serviceType.Name,
                ServiceId = service.ServiceId,
                ProviderId = service.ProviderId,
                Version = service.Version
            });
            
            Debug.Log($"Service registered: {serviceType.Name} - {service.ServiceId}");
        }
        
        public T GetService<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (services.ContainsKey(serviceType) && services[serviceType].Count > 0)
            {
                return services[serviceType].Values.First() as T;
            }
            
            return null;
        }
        
        public IEnumerable<T> GetServices<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (services.ContainsKey(serviceType))
            {
                return services[serviceType].Values.Cast<T>();
            }
            
            return Enumerable.Empty<T>();
        }
        
        public bool UnregisterService<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (services.ContainsKey(serviceType) && 
                services[serviceType].ContainsKey(serviceId))
            {
                var service = services[serviceType][serviceId];
                services[serviceType].Remove(serviceId);
                
                eventBus?.Publish(new ServiceUnregisteredEvent
                {
                    ServiceType = serviceType.Name,
                    ServiceId = serviceId,
                    ProviderId = service.ProviderId
                });
                
                return true;
            }
            
            return false;
        }
    }
    
    public class ServiceRegisteredEvent : IModEvent
    {
        public string EventId => "service_registered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
        public string Version { get; set; }
    }
    
    public class ServiceUnregisteredEvent : IModEvent
    {
        public string EventId => "service_unregistered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
    }
}
```

## 通信模式

### 1. 事件模式（Event Pattern）

适用场景：
- 单向通知
- 广播消息
- 状态变化通知

```csharp
// 发布者
eventBus.Publish(new ButtonPressedEvent { ButtonId = "btn_1" });

// 订阅者
eventBus.Subscribe<ButtonPressedEvent>(e => {
    Debug.Log($"Button {e.ButtonId} was pressed");
});
```

### 2. 请求-响应模式（Request-Response Pattern）

适用场景：
- 需要返回结果的操作
- 需要确认的命令
- 查询操作

```csharp
// 发送请求并等待响应
var response = await requestManager.SendRequestAsync<MoveRobotRequest, MoveRobotResponse>(
    new MoveRobotRequest { TargetPosition = new Vector3(1, 2, 3) },
    TimeSpan.FromSeconds(5)
);

if (response.Success) {
    Debug.Log("Robot moved successfully");
}
```

### 3. 服务模式（Service Pattern）

适用场景：
- 模组间紧密协作
- 需要调用具体功能
- API式的交互

```csharp
// 注册服务
services.RegisterService<IRobotService>(new RobotService());

// 使用服务
var robotService = services.GetService<IRobotService>();
if (robotService != null) {
    await robotService.MoveToPosition(new Vector3(1, 2, 3));
}
```

### 4. 配置驱动模式（Configuration-Driven Pattern）

适用场景：
- 灵活的系统行为配置
- 无需修改代码的功能调整
- 复杂的事件路由

配置文件示例：
```json
{
  "routes": [
    {
      "name": "button_to_robot",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "control_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.MoveJointEvent",
          "parameters": {
            "jointName": "base_rotation",
            "angle": 45
          }
        }
      ]
    }
  ]
}
```

## 完整代码实现

### 1. 基础事件和数据结构

```csharp
// ModSystem.Core/Common/CommonEvents.cs
using UnityEngine;
using System;

namespace ModSystem.Core
{
    public class InteractionEvent : IModEvent
    {
        public string EventId => "interaction";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        
        public GameObject TargetObject { get; set; }
        public InteractionType InteractionType { get; set; }
        public Vector3 InteractionPoint { get; set; }
    }
    
    public enum InteractionType
    {
        Click,
        Press,
        Release,
        Hover,
        Exit
    }
    
    public class EmergencyStopEvent : IModEvent
    {
        public string EventId => "emergency_stop";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string Reason { get; set; }
    }
    
    public interface IModAPI
    {
        IRequestResponseManager RequestResponse { get; }
        IAudioAPI Audio { get; }
        IUtilityAPI Utilities { get; }
        IObjectFactory ObjectFactory { get; }
    }
    
    public interface IObjectFactory
    {
        Task<GameObject> CreateObjectAsync(string definitionPath);
        Task<GameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition);
    }
}
```

### 2. 按钮模组实现

```csharp
// ButtonMod/ButtonBehaviour.cs
using UnityEngine;
using ModSystem.Core;
using System;
using System.Collections.Generic;

namespace ButtonMod
{
    public class ButtonPressedEvent : IModEvent
    {
        public string EventId => "button_pressed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
    
    public class ButtonBehaviour : IModBehaviour
    {
        public string BehaviourId => "interactive_button";
        public string Version => "1.0.0";
        
        private IModContext context;
        private ButtonConfiguration config;
        private ButtonState state;
        private float lastPressTime;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            config = LoadConfiguration();
            state = new ButtonState();
            
            SetupInteraction();
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            
            if (config.UseServiceMode)
            {
                context.EventBus.Subscribe<ServiceRegisteredEvent>(OnServiceRegistered);
            }
            
            context.Log($"Button {config.ButtonId} initialized");
        }
        
        private void SetupInteraction()
        {
            var collider = context.GameObject.GetComponent<Collider>();
            if (collider == null)
            {
                collider = context.GameObject.AddComponent<BoxCollider>();
            }
            
            context.GameObject.layer = LayerMask.NameToLayer("Interactable");
            
            var renderer = context.GetComponent<Renderer>();
            if (renderer != null)
            {
                renderer.material.color = config.NormalColor;
            }
        }
        
        private void OnInteraction(InteractionEvent e)
        {
            if (e.TargetObject != context.GameObject)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {
                OnButtonPress();
            }
            else if (e.InteractionType == InteractionType.Release)
            {
                OnButtonRelease();
            }
        }
        
        private void OnButtonPress()
        {
            if (Time.time - lastPressTime < config.CooldownTime)
                return;
            
            lastPressTime = Time.time;
            state.IsPressed = true;
            
            AnimatePress();
            
            switch (config.CommunicationMode)
            {
                case CommunicationMode.Event:
                    PublishButtonEvent();
                    break;
                    
                case CommunicationMode.RequestResponse:
                    SendButtonRequest();
                    break;
                    
                case CommunicationMode.Service:
                    CallButtonService();
                    break;
                    
                case CommunicationMode.Configured:
                    ExecuteConfiguredActions();
                    break;
            }
            
            if (!string.IsNullOrEmpty(config.ClickSound))
            {
                context.API.Audio.PlaySound(config.ClickSound);
            }
        }
        
        private void PublishButtonEvent()
        {
            var buttonEvent = new ButtonPressedEvent
            {
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                ButtonType = config.ButtonType.ToString(),
                Parameters = config.EventParameters
            };
            
            context.EventBus.Publish(buttonEvent);
            context.Log($"Published button event: {config.ButtonId}");
        }
        
        private async void SendButtonRequest()
        {
            try
            {
                var request = new ButtonActionRequest
                {
                    SenderId = BehaviourId,
                    ButtonId = config.ButtonId,
                    Action = config.RequestAction,
                    Parameters = config.EventParameters
                };
                
                var response = await context.API.RequestResponse.SendRequestAsync<
                    ButtonActionRequest, 
                    ButtonActionResponse>(request, TimeSpan.FromSeconds(5));
                
                if (response.Success)
                {
                    ShowSuccessFeedback();
                    context.Log($"Button action successful: {response.Message}");
                }
                else
                {
                    ShowErrorFeedback();
                    context.LogError($"Button action failed: {response.Message}");
                }
            }
            catch (TimeoutException)
            {
                ShowTimeoutFeedback();
                context.LogError("Button action timed out");
            }
        }
        
        public void OnUpdate(float deltaTime)
        {
            if (state.IsPressed && config.ButtonType == ButtonType.Momentary)
            {
                state.PressedTime += deltaTime;
                if (state.PressedTime >= config.MomentaryDuration)
                {
                    OnButtonRelease();
                }
            }
        }
        
        public void OnDestroy()
        {
            context.Log($"Button {config.ButtonId} destroyed");
        }
        
        // 辅助方法实现
        private ButtonConfiguration LoadConfiguration()
        {
            var configJson = context.API.Utilities.LoadConfigFile("button_config.json");
            if (!string.IsNullOrEmpty(configJson))
            {
                return JsonUtility.FromJson<ButtonConfiguration>(configJson);
            }
            return new ButtonConfiguration();
        }
        
        private void AnimatePress()
        {
            var transform = context.GameObject.transform;
            var renderer = context.GetComponent<Renderer>();
            
            transform.localPosition += Vector3.down * config.PressDepth;
            
            if (renderer != null)
            {
                renderer.material.color = config.PressedColor;
            }
        }
        
        private void OnButtonRelease()
        {
            state.IsPressed = false;
            state.PressedTime = 0;
            AnimateRelease();
        }
        
        private void AnimateRelease()
        {
            var transform = context.GameObject.transform;
            var renderer = context.GetComponent<Renderer>();
            
            transform.localPosition -= Vector3.down * config.PressDepth;
            
            if (renderer != null)
            {
                renderer.material.color = config.NormalColor;
            }
        }
        
        private void CallButtonService()
        {
            var targetService = context.Services.GetService<ITargetService>();
            if (targetService != null)
            {
                targetService.ExecuteAction(config.ServiceAction, config.EventParameters);
                ShowSuccessFeedback();
            }
            else
            {
                context.LogError($"Target service {config.TargetServiceType} not found");
                ShowErrorFeedback();
            }
        }
        
        private void ExecuteConfiguredActions()
        {
            // 配置驱动的动作执行
            var actions = config.ConfiguredActions;
            foreach (var action in actions)
            {
                context.API.Utilities.DelayCall(action.Delay, () =>
                {
                    PublishConfiguredEvent(action);
                });
            }
        }
        
        private void PublishConfiguredEvent(ConfiguredAction action)
        {
            var eventData = new Dictionary<string, object>(action.Parameters);
            eventData["_eventType"] = action.EventType;
            eventData["_senderId"] = BehaviourId;
            
            context.EventBus.Publish(new GenericModEvent
            {
                EventId = action.EventType,
                SenderId = BehaviourId,
                Data = eventData
            });
        }
        
        private void ShowSuccessFeedback()
        {
            var renderer = context.GetComponent<Renderer>();
            if (renderer != null)
            {
                context.API.Utilities.DelayCall(0.2f, () =>
                {
                    renderer.material.color = Color.green;
                    context.API.Utilities.DelayCall(0.5f, () =>
                    {
                        renderer.material.color = config.NormalColor;
                    });
                });
            }
        }
        
        private void ShowErrorFeedback()
        {
            var renderer = context.GetComponent<Renderer>();
            if (renderer != null)
            {
                context.API.Utilities.DelayCall(0.2f, () =>
                {
                    renderer.material.color = Color.red;
                    context.API.Utilities.DelayCall(0.5f, () =>
                    {
                        renderer.material.color = config.NormalColor;
                    });
                });
            }
        }
        
        private void ShowTimeoutFeedback()
        {
            var renderer = context.GetComponent<Renderer>();
            if (renderer != null)
            {
                context.API.Utilities.DelayCall(0.2f, () =>
                {
                    renderer.material.color = Color.yellow;
                    context.API.Utilities.DelayCall(0.5f, () =>
                    {
                        renderer.material.color = config.NormalColor;
                    });
                });
            }
        }
        
        private void OnServiceRegistered(ServiceRegisteredEvent e)
        {
            if (e.ServiceType == config.TargetServiceType)
            {
                context.Log($"Target service {e.ServiceType} registered");
                // 可以在这里自动重试之前失败的操作
            }
        }
    }
    
    [System.Serializable]
    public class ButtonConfiguration
    {
        public string ButtonId = "button_01";
        public ButtonType ButtonType = ButtonType.Momentary;
        public CommunicationMode CommunicationMode = CommunicationMode.Event;
        
        public Color NormalColor = Color.white;
        public Color PressedColor = Color.green;
        public float PressDepth = 0.02f;
        
        public float CooldownTime = 0.5f;
        public float MomentaryDuration = 0.2f;
        
        public Dictionary<string, object> EventParameters = new Dictionary<string, object>();
        public string RequestAction = "button_action";
        public bool UseServiceMode = false;
        public string TargetServiceType = "IRobotService";
        public string ServiceAction = "execute";
        
        public string ClickSound = "button_click";
        
        public List<ConfiguredAction> ConfiguredActions = new List<ConfiguredAction>();
    }
    
    public enum ButtonType
    {
        Momentary,
        Toggle,
        Hold
    }
    
    public enum CommunicationMode
    {
        Event,
        RequestResponse,
        Service,
        Configured
    }
    
    public class ButtonState
    {
        public bool IsPressed { get; set; }
        public float PressedTime { get; set; }
        public int ClickCount { get; set; }
    }
    
    [Serializable]
    public class ConfiguredAction
    {
        public string EventType;
        public Dictionary<string, object> Parameters;
        public float Delay;
    }
    
    public class ButtonActionRequest : ModRequest
    {
        public string ButtonId { get; set; }
        public string Action { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
    
    public class ButtonActionResponse : ModResponse
    {
        public string ActionResult { get; set; }
    }
    
    public interface ITargetService : IModService
    {
        void ExecuteAction(string action, Dictionary<string, object> parameters);
    }
    
    public class GenericModEvent : IModEvent
    {
        public string EventId { get; set; }
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public Dictionary<string, object> Data { get; set; }
    }
}
```

### 3. 机器人模组实现

```csharp
// RobotMod/RobotArmBehaviour.cs
using UnityEngine;
using ModSystem.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace RobotMod
{
    public interface IRobotService : IModService
    {
        Task<bool> MoveJoint(string jointName, float angle, float speed = 30f);
        Task<bool> MoveToPosition(Vector3 position);
        Task<Vector3> GetEndEffectorPosition();
        Task<RobotStatus> GetStatus();
        void EmergencyStop();
    }
    
    public class RobotStatus
    {
        public Dictionary<string, float> JointAngles { get; set; }
        public Vector3 EndEffectorPosition { get; set; }
        public bool IsMoving { get; set; }
        public string CurrentState { get; set; }
    }
    
    public class RobotArmBehaviour : IModBehaviour, IRobotService
    {
        public string BehaviourId => "robot_arm_controller";
        public string Version => "2.0.0";
        
        public string ServiceId => "robot_arm_service";
        public string ProviderId => "RobotMod";
        string IModService.Version => Version;
        
        private IModContext context;
        private RobotConfiguration config;
        private Dictionary<string, JointController> joints;
        private KinematicsController kinematics;
        private bool emergencyStop = false;
        private Queue<RobotCommand> commandQueue;
        private bool isProcessingCommand = false;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            
            config = LoadConfiguration();
            commandQueue = new Queue<RobotCommand>();
            InitializeJoints();
            kinematics = new KinematicsController(joints, config);
            
            context.Services.RegisterService<IRobotService>(this);
            SubscribeToEvents();
            
            context.Log($"Robot arm {ServiceId} initialized with {joints.Count} joints");
        }
        
        private void InitializeJoints()
        {
            joints = new Dictionary<string, JointController>();
            
            foreach (var jointConfig in config.Joints)
            {
                var jointTransform = context.GameObject.transform.Find(jointConfig.Name);
                if (jointTransform != null)
                {
                    var controller = new JointController(jointTransform, jointConfig);
                    joints[jointConfig.Name] = controller;
                }
                else
                {
                    context.LogError($"Joint {jointConfig.Name} not found in model");
                }
            }
        }
        
        private void SubscribeToEvents()
        {
            context.EventBus.Subscribe<ButtonPressedEvent>(OnButtonPressed);
            context.EventBus.Subscribe<RobotControlRequest>(OnControlRequest);
            context.EventBus.Subscribe<EmergencyStopEvent>(e => EmergencyStop());
        }
        
        private void OnButtonPressed(ButtonPressedEvent e)
        {
            if (emergencyStop) return;
            
            if (e.Parameters == null) return;
            
            if (e.Parameters.TryGetValue("action", out var action))
            {
                switch (action.ToString())
                {
                    case "rotate_joint":
                        HandleRotateJoint(e.Parameters);
                        break;
                        
                    case "move_home":
                        MoveToHomePosition();
                        break;
                        
                    case "execute_sequence":
                        ExecuteSequence(e.Parameters);
                        break;
                }
            }
        }
        
        private async void OnControlRequest(RobotControlRequest request)
        {
            var response = new RobotControlResponse
            {
                RequestId = request.RequestId,
                SenderId = ServiceId
            };
            
            try
            {
                switch (request.Command)
                {
                    case "move_joint":
                        var jointName = request.Parameters["jointName"].ToString();
                        var angle = Convert.ToSingle(request.Parameters["angle"]);
                        response.Success = await MoveJoint(jointName, angle);
                        break;
                        
                    case "get_status":
                        response.Status = await GetStatus();
                        response.Success = true;
                        break;
                        
                    default:
                        response.Success = false;
                        response.Message = $"Unknown command: {request.Command}";
                        break;
                }
            }
            catch (Exception ex)
            {
                response.Success = false;
                response.Message = ex.Message;
            }
            
            context.EventBus.Publish(response);
        }
        
        public async Task<bool> MoveJoint(string jointName, float angle, float speed = 30f)
        {
            if (emergencyStop) return false;
            
            if (joints.TryGetValue(jointName, out var joint))
            {
                PublishStateChange(jointName, "moving", angle);
                
                await joint.MoveToAngle(angle, speed);
                
                PublishStateChange(jointName, "idle", angle);
                
                return true;
            }
            
            return false;
        }
        
        public async Task<bool> MoveToPosition(Vector3 position)
        {
            if (emergencyStop) return false;
            
            var jointAngles = kinematics.CalculateInverseKinematics(position);
            
            if (jointAngles != null)
            {
                var tasks = new List<Task<bool>>();
                foreach (var kvp in jointAngles)
                {
                    tasks.Add(MoveJoint(kvp.Key, kvp.Value));
                }
                
                var results = await Task.WhenAll(tasks);
                return results.All(r => r);
            }
            
            return false;
        }
        
        public async Task<Vector3> GetEndEffectorPosition()
        {
            return await Task.Run(() => kinematics.GetEndEffectorPosition());
        }
        
        public async Task<RobotStatus> GetStatus()
        {
            return await Task.Run(() =>
            {
                var status = new RobotStatus
                {
                    JointAngles = new Dictionary<string, float>(),
                    EndEffectorPosition = kinematics.GetEndEffectorPosition(),
                    IsMoving = joints.Values.Any(j => j.IsMoving),
                    CurrentState = emergencyStop ? "emergency_stop" : "operational"
                };
                
                foreach (var kvp in joints)
                {
                    status.JointAngles[kvp.Key] = kvp.Value.CurrentAngle;
                }
                
                return status;
            });
        }
        
        public void EmergencyStop()
        {
            emergencyStop = true;
            
            foreach (var joint in joints.Values)
            {
                joint.Stop();
            }
            
            commandQueue.Clear();
            isProcessingCommand = false;
            
            context.EventBus.Publish(new RobotStateChangedEvent
            {
                SenderId = ServiceId,
                Status = "emergency_stop"
            });
            
            context.Log("Emergency stop activated");
        }
        
        private void PublishStateChange(string jointName, string status, float angle)
        {
            context.EventBus.Publish(new RobotStateChangedEvent
            {
                SenderId = ServiceId,
                JointName = jointName,
                Status = status,
                NewAngle = angle,
                Timestamp = DateTime.Now
            });
        }
        
        public void OnUpdate(float deltaTime)
        {
            if (emergencyStop) return;
            
            foreach (var joint in joints.Values)
            {
                joint.Update(deltaTime);
            }
            
            if (config.EnableCollisionDetection)
            {
                CheckCollisions();
            }
            
            ProcessCommandQueue();
        }
        
        public void OnDestroy()
        {
            context.Services.UnregisterService<IRobotService>(ServiceId);
            
            foreach (var joint in joints.Values)
            {
                joint.Dispose();
            }
            
            context.Log($"Robot arm {ServiceId} destroyed");
        }
        
        private RobotConfiguration LoadConfiguration()
        {
            var configJson = context.API.Utilities.LoadConfigFile("robot_config.json");
            if (!string.IsNullOrEmpty(configJson))
            {
                return JsonUtility.FromJson<RobotConfiguration>(configJson);
            }
            
            return new RobotConfiguration
            {
                Joints = new List<JointConfiguration>
                {
                    new JointConfiguration { Name = "base_rotation", RotationAxis = Vector3.up },
                    new JointConfiguration { Name = "shoulder_pitch", RotationAxis = Vector3.right },
                    new JointConfiguration { Name = "elbow_pitch", RotationAxis = Vector3.right }
                }
            };
        }
        
        private void HandleRotateJoint(Dictionary<string, object> parameters)
        {
            if (parameters.TryGetValue("jointName", out var jointName) &&
                parameters.TryGetValue("angle", out var angle))
            {
                string joint = jointName.ToString();
                float targetAngle = Convert.ToSingle(angle);
                
                commandQueue.Enqueue(new RobotCommand
                {
                    Type = CommandType.MoveJoint,
                    JointName = joint,
                    TargetAngle = targetAngle
                });
            }
        }
        
        private async void MoveToHomePosition()
        {
            commandQueue.Enqueue(new RobotCommand
            {
                Type = CommandType.MoveHome
            });
        }
        
        private async void ExecuteSequence(Dictionary<string, object> parameters)
        {
            if (parameters.TryGetValue("sequence", out var sequence))
            {
                var commands = sequence as List<RobotCommand>;
                if (commands != null)
                {
                    foreach (var cmd in commands)
                    {
                        commandQueue.Enqueue(cmd);
                    }
                }
            }
        }
        
        private async void ProcessCommandQueue()
        {
            if (isProcessingCommand || commandQueue.Count == 0) return;
            
            isProcessingCommand = true;
            var command = commandQueue.Dequeue();
            
            switch (command.Type)
            {
                case CommandType.MoveJoint:
                    await MoveJoint(command.JointName, command.TargetAngle, command.Speed);
                    break;
                    
                case CommandType.MoveToPosition:
                    await MoveToPosition(command.TargetPosition);
                    break;
                    
                case CommandType.MoveHome:
                    var tasks = new List<Task<bool>>();
                    foreach (var joint in joints)
                    {
                        tasks.Add(MoveJoint(joint.Key, 0));
                    }
                    await Task.WhenAll(tasks);
                    break;
            }
            
            isProcessingCommand = false;
        }
        
        private void CheckCollisions()
        {
            // 简化的碰撞检测
            foreach (var joint in joints.Values)
            {
                var colliders = Physics.OverlapSphere(
                    joint.Transform.position, 
                    config.CollisionCheckRadius
                );
                
                foreach (var collider in colliders)
                {
                    if (collider.gameObject != context.GameObject && 
                        collider.gameObject.layer == LayerMask.NameToLayer("Obstacle"))
                    {
                        EmergencyStop();
                        context.LogError($"Collision detected near {joint.Name}!");
                        return;
                    }
                }
            }
        }
    }
    
    public class JointController
    {
        private readonly Transform transform;
        private readonly JointConfiguration config;
        private float currentAngle;
        private float targetAngle;
        private float velocity;
        private float integralError;
        private float lastError;
        
        public bool IsMoving => Math.Abs(targetAngle - currentAngle) > 0.1f;
        public float CurrentAngle => currentAngle;
        public Transform Transform => transform;
        public string Name => config.Name;
        
        public JointController(Transform transform, JointConfiguration config)
        {
            this.transform = transform;
            this.config = config;
            this.currentAngle = config.InitialAngle;
            this.targetAngle = config.InitialAngle;
        }
        
        public async Task MoveToAngle(float angle, float speed)
        {
            targetAngle = Mathf.Clamp(angle, config.MinAngle, config.MaxAngle);
            
            while (IsMoving)
            {
                await Task.Delay(10);
            }
        }
        
        public void Update(float deltaTime)
        {
            if (!IsMoving) return;
            
            // PID控制
            float error = targetAngle - currentAngle;
            integralError += error * deltaTime;
            integralError = Mathf.Clamp(integralError, -config.MaxIntegral, config.MaxIntegral);
            
            float derivative = (error - lastError) / deltaTime;
            lastError = error;
            
            velocity = error * config.Kp + integralError * config.Ki + derivative * config.Kd;
            velocity = Mathf.Clamp(velocity, -config.MaxVelocity, config.MaxVelocity);
            
            currentAngle += velocity * deltaTime;
            
            transform.localRotation = Quaternion.AngleAxis(
                currentAngle,
                config.RotationAxis
            );
        }
        
        public void Stop()
        {
            targetAngle = currentAngle;
            velocity = 0;
            integralError = 0;
            lastError = 0;
        }
        
        public void Dispose()
        {
            // 清理资源
            Stop();
        }
    }
    
    [Serializable]
    public class RobotConfiguration
    {
        public string RobotId = "robot_01";
        public List<JointConfiguration> Joints = new List<JointConfiguration>();
        public bool EnableCollisionDetection = true;
        public bool EnableIK = true;
        public float DefaultSpeed = 30f;
        public float CollisionCheckRadius = 0.1f;
    }
    
    [Serializable]
    public class JointConfiguration
    {
        public string Name;
        public Vector3 RotationAxis = Vector3.up;
        public float MinAngle = -180f;
        public float MaxAngle = 180f;
        public float InitialAngle = 0f;
        public float MaxVelocity = 60f;
        public float Kp = 5f;
        public float Ki = 0.1f;
        public float Kd = 1f;
        public float MaxIntegral = 10f;
    }
    
    public class KinematicsController
    {
        private Dictionary<string, JointController> joints;
        private RobotConfiguration config;
        
        public KinematicsController(Dictionary<string, JointController> joints, RobotConfiguration config)
        {
            this.joints = joints;
            this.config = config;
        }
        
        public Dictionary<string, float> CalculateInverseKinematics(Vector3 targetPosition)
        {
            var result = new Dictionary<string, float>();
            
            // 简化的IK计算示例
            float distance = Vector3.Distance(Vector3.zero, targetPosition);
            float angle = Mathf.Atan2(targetPosition.x, targetPosition.z) * Mathf.Rad2Deg;
            
            result["base_rotation"] = angle;
            result["shoulder_pitch"] = Mathf.Clamp(45f - distance * 10f, -90f, 90f);
            result["elbow_pitch"] = Mathf.Clamp(-45f + distance * 5f, -135f, 135f);
            
            return result;
        }
        
        public Vector3 GetEndEffectorPosition()
        {
            // 简化的正向运动学计算
            var baseRotation = joints.ContainsKey("base_rotation") ? 
                joints["base_rotation"].CurrentAngle : 0f;
            var shoulderAngle = joints.ContainsKey("shoulder_pitch") ? 
                joints["shoulder_pitch"].CurrentAngle : 0f;
            var elbowAngle = joints.ContainsKey("elbow_pitch") ? 
                joints["elbow_pitch"].CurrentAngle : 0f;
            
            // 假设链接长度
            float l1 = 0.5f; // 肩到肘
            float l2 = 0.4f; // 肘到末端
            
            float totalAngle = shoulderAngle + elbowAngle;
            float x = (l1 * Mathf.Cos(shoulderAngle * Mathf.Deg2Rad) + 
                      l2 * Mathf.Cos(totalAngle * Mathf.Deg2Rad)) * 
                      Mathf.Sin(baseRotation * Mathf.Deg2Rad);
            float z = (l1 * Mathf.Cos(shoulderAngle * Mathf.Deg2Rad) + 
                      l2 * Mathf.Cos(totalAngle * Mathf.Deg2Rad)) * 
                      Mathf.Cos(baseRotation * Mathf.Deg2Rad);
            float y = l1 * Mathf.Sin(shoulderAngle * Mathf.Deg2Rad) + 
                      l2 * Mathf.Sin(totalAngle * Mathf.Deg2Rad);
            
            return new Vector3(x, y, z);
        }
    }
    
    public class RobotControlRequest : ModRequest
    {
        public string Command { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
    
    public class RobotControlResponse : ModResponse
    {
        public RobotStatus Status { get; set; }
    }
    
    public class RobotStateChangedEvent : IModEvent
    {
        public string EventId => "robot_state_changed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string JointName { get; set; }
        public string Status { get; set; }
        public float NewAngle { get; set; }
    }
    
    public enum CommandType
    {
        MoveJoint,
        MoveToPosition,
        MoveHome,
        ExecuteSequence
    }
    
    public class RobotCommand
    {
        public CommandType Type { get; set; }
        public string JointName { get; set; }
        public float TargetAngle { get; set; }
        public Vector3 TargetPosition { get; set; }
        public float Speed { get; set; } = 30f;
    }
}
```

### 4. 配置驱动的通信路由

```csharp
// ModSystem.Core/Communication/CommunicationRouter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    public class CommunicationConfig
    {
        public List<RouteConfig> Routes { get; set; }
        public List<WorkflowConfig> Workflows { get; set; }
    }
    
    public class RouteConfig
    {
        public string Name { get; set; }
        public string SourceEvent { get; set; }
        public List<ConditionConfig> Conditions { get; set; }
        public List<ActionConfig> Actions { get; set; }
    }
    
    public class ConditionConfig
    {
        public string Property { get; set; }
        public string Operator { get; set; }
        public object Value { get; set; }
    }
    
    public class ActionConfig
    {
        public string TargetMod { get; set; }
        public string EventType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
        public int Delay { get; set; }
    }
    
    public class CommunicationRouter
    {
        private readonly IEventBus eventBus;
        private readonly CommunicationConfig config;
        private readonly Dictionary<string, List<RouteConfig>> routeMap;
        
        public CommunicationRouter(IEventBus eventBus, string configJson)
        {
            this.eventBus = eventBus;
            this.config = JsonConvert.DeserializeObject<CommunicationConfig>(configJson);
            this.routeMap = BuildRouteMap();
            
            SubscribeToEvents();
        }
        
        private Dictionary<string, List<RouteConfig>> BuildRouteMap()
        {
            var map = new Dictionary<string, List<RouteConfig>>();
            
            foreach (var route in config.Routes)
            {
                if (!map.ContainsKey(route.SourceEvent))
                {
                    map[route.SourceEvent] = new List<RouteConfig>();
                }
                map[route.SourceEvent].Add(route);
            }
            
            return map;
        }
        
        private void SubscribeToEvents()
        {
            foreach (var eventType in routeMap.Keys)
            {
                var method = typeof(CommunicationRouter)
                    .GetMethod(nameof(HandleEvent))
                    .MakeGenericMethod(Type.GetType(eventType));
                    
                var handler = Delegate.CreateDelegate(
                    typeof(Action<>).MakeGenericType(Type.GetType(eventType)),
                    this,
                    method
                );
                
                eventBus.GetType()
                    .GetMethod("Subscribe")
                    .MakeGenericMethod(Type.GetType(eventType))
                    .Invoke(eventBus, new[] { handler });
            }
        }
        
        public void HandleEvent<T>(T eventData) where T : IModEvent
        {
            var eventType = typeof(T).Name;
            
            if (routeMap.TryGetValue(eventType, out var routes))
            {
                foreach (var route in routes)
                {
                    if (EvaluateConditions(route.Conditions, eventData))
                    {
                        ExecuteActions(route.Actions, eventData);
                    }
                }
            }
        }
        
        private bool EvaluateConditions<T>(List<ConditionConfig> conditions, T eventData)
        {
            if (conditions == null || conditions.Count == 0)
                return true;
            
            foreach (var condition in conditions)
            {
                var value = GetPropertyValue(eventData, condition.Property);
                
                if (!EvaluateCondition(value, condition.Operator, condition.Value))
                    return false;
            }
            
            return true;
        }
        
        private bool EvaluateCondition(object value, string op, object expected)
        {
            switch (op)
            {
                case "==":
                    return Equals(value, expected);
                case "!=":
                    return !Equals(value, expected);
                case ">":
                    return Comparer<object>.Default.Compare(value, expected) > 0;
                case "<":
                    return Comparer<object>.Default.Compare(value, expected) < 0;
                case "contains":
                    return value?.ToString().Contains(expected.ToString()) ?? false;
                default:
                    return false;
            }
        }
        
        private async void ExecuteActions<T>(List<ActionConfig> actions, T sourceEvent)
        {
            foreach (var action in actions)
            {
                if (action.Delay > 0)
                {
                    await Task.Delay(action.Delay);
                }
                
                var parameters = PrepareParameters(action.Parameters, sourceEvent);
                var targetEvent = CreateEvent(action.EventType, parameters);
                eventBus.Publish(targetEvent);
            }
        }
        
        private object GetPropertyValue(object obj, string propertyPath)
        {
            var properties = propertyPath.Split('.');
            object current = obj;
            
            foreach (var prop in properties)
            {
                if (current == null) return null;
                
                var propertyInfo = current.GetType().GetProperty(prop);
                if (propertyInfo == null) return null;
                
                current = propertyInfo.GetValue(current);
            }
            
            return current;
        }
        
        private Dictionary<string, object> PrepareParameters<T>(
            Dictionary<string, object> templateParams, 
            T sourceEvent)
        {
            return new Dictionary<string, object>(templateParams);
        }
        
        private IModEvent CreateEvent(string eventTypeName, Dictionary<string, object> parameters)
        {
            var eventType = Type.GetType(eventTypeName);
            if (eventType == null)
            {
                throw new InvalidOperationException($"Event type {eventTypeName} not found");
            }
            
            var eventInstance = Activator.CreateInstance(eventType) as IModEvent;
            
            foreach (var param in parameters)
            {
                var property = eventType.GetProperty(param.Key);
                if (property != null && property.CanWrite)
                {
                    property.SetValue(eventInstance, param.Value);
                }
            }
            
            return eventInstance;
        }
    }
}
```

### 5. 对象工厂系统（替代Prefab）

```csharp
// ModSystem.Core/Runtime/ObjectFactory.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    [Serializable]
    public class ObjectDefinition
    {
        public string objectId { get; set; }
        public string name { get; set; }
        public List<ComponentDefinition> components { get; set; }
    }
    
    [Serializable]
    public class ComponentDefinition
    {
        public string type { get; set; }
        public Dictionary<string, object> properties { get; set; }
        
        public T GetProperty<T>(string key, T defaultValue = default)
        {
            if (properties != null && properties.TryGetValue(key, out var value))
            {
                try
                {
                    return (T)Convert.ChangeType(value, typeof(T));
                }
                catch
                {
                    return defaultValue;
                }
            }
            return defaultValue;
        }
    }
    
    public class ModObjectFactory : IObjectFactory
    {
        private readonly Dictionary<string, ObjectDefinition> definitionCache;
        private readonly string basePath;
        
        public ModObjectFactory(string basePath = "")
        {
            this.basePath = basePath;
            definitionCache = new Dictionary<string, ObjectDefinition>();
        }
        
        public async Task<GameObject> CreateObjectAsync(string definitionPath)
        {
            ObjectDefinition definition;
            
            if (definitionCache.ContainsKey(definitionPath))
            {
                definition = definitionCache[definitionPath];
            }
            else
            {
                var json = await LoadJsonAsync(definitionPath);
                definition = JsonConvert.DeserializeObject<ObjectDefinition>(json);
                definitionCache[definitionPath] = definition;
            }
            
            return await CreateObjectFromDefinitionAsync(definition);
        }
        
        public async Task<GameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition)
        {
            var gameObject = new GameObject(definition.name);
            
            foreach (var compDef in definition.components)
            {
                await AddComponentAsync(gameObject, compDef);
            }
            
            return gameObject;
        }
        
        private async Task AddComponentAsync(GameObject obj, ComponentDefinition compDef)
        {
            switch (compDef.type)
            {
                case "Transform":
                    ConfigureTransform(obj.transform, compDef);
                    break;
                    
                case "MeshRenderer":
                    await ConfigureMeshRenderer(obj, compDef);
                    break;
                    
                case "BoxCollider":
                    ConfigureBoxCollider(obj, compDef);
                    break;
                    
                case "SphereCollider":
                    ConfigureSphereCollider(obj, compDef);
                    break;
                    
                case "ModBehaviour":
                    ConfigureModBehaviour(obj, compDef);
                    break;
                    
                case "RigidBody":
                    ConfigureRigidBody(obj, compDef);
                    break;
                    
                case "Light":
                    ConfigureLight(obj, compDef);
                    break;
                    
                case "Camera":
                    ConfigureCamera(obj, compDef);
                    break;
                    
                case "AudioSource":
                    ConfigureAudioSource(obj, compDef);
                    break;
                    
                default:
                    Debug.LogWarning($"Unknown component type: {compDef.type}");
                    break;
            }
        }
        
        private void ConfigureTransform(Transform transform, ComponentDefinition compDef)
        {
            var position = compDef.GetProperty<float[]>("position", new float[] { 0, 0, 0 });
            var rotation = compDef.GetProperty<float[]>("rotation", new float[] { 0, 0, 0 });
            var scale = compDef.GetProperty<float[]>("scale", new float[] { 1, 1, 1 });
            
            transform.position = new Vector3(position[0], position[1], position[2]);
            transform.rotation = Quaternion.Euler(rotation[0], rotation[1], rotation[2]);
            transform.localScale = new Vector3(scale[0], scale[1], scale[2]);
        }
        
        private async Task ConfigureMeshRenderer(GameObject obj, ComponentDefinition compDef)
        {
            var modelPath = compDef.GetProperty<string>("model");
            if (!string.IsNullOrEmpty(modelPath))
            {
                await LoadGLTFModel(obj, modelPath);
            }
            
            var renderer = obj.GetComponent<MeshRenderer>();
            if (renderer != null)
            {
                var materialDef = compDef.GetProperty<Dictionary<string, object>>("material");
                if (materialDef != null)
                {
                    ConfigureMaterial(renderer, materialDef);
                }
            }
        }
        
        private void ConfigureBoxCollider(GameObject obj, ComponentDefinition compDef)
        {
            var collider = obj.AddComponent<BoxCollider>();
            
            var center = compDef.GetProperty<float[]>("center", new float[] { 0, 0, 0 });
            var size = compDef.GetProperty<float[]>("size", new float[] { 1, 1, 1 });
            var isTrigger = compDef.GetProperty<bool>("isTrigger", false);
            
            collider.center = new Vector3(center[0], center[1], center[2]);
            collider.size = new Vector3(size[0], size[1], size[2]);
            collider.isTrigger = isTrigger;
        }
        
        private void ConfigureSphereCollider(GameObject obj, ComponentDefinition compDef)
        {
            var collider = obj.AddComponent<SphereCollider>();
            
            var center = compDef.GetProperty<float[]>("center", new float[] { 0, 0, 0 });
            var radius = compDef.GetProperty<float>("radius", 0.5f);
            var isTrigger = compDef.GetProperty<bool>("isTrigger", false);
            
            collider.center = new Vector3(center[0], center[1], center[2]);
            collider.radius = radius;
            collider.isTrigger = isTrigger;
        }
        
        private void ConfigureRigidBody(GameObject obj, ComponentDefinition compDef)
        {
            var rb = obj.AddComponent<Rigidbody>();
            
            rb.mass = compDef.GetProperty<float>("mass", 1f);
            rb.drag = compDef.GetProperty<float>("drag", 0f);
            rb.angularDrag = compDef.GetProperty<float>("angularDrag", 0.05f);
            rb.useGravity = compDef.GetProperty<bool>("useGravity", true);
            rb.isKinematic = compDef.GetProperty<bool>("isKinematic", false);
            
            var constraints = compDef.GetProperty<string[]>("constraints");
            if (constraints != null)
            {
                RigidbodyConstraints rbConstraints = RigidbodyConstraints.None;
                foreach (var constraint in constraints)
                {
                    if (Enum.TryParse<RigidbodyConstraints>(constraint, out var c))
                    {
                        rbConstraints |= c;
                    }
                }
                rb.constraints = rbConstraints;
            }
        }
        
        private void ConfigureLight(GameObject obj, ComponentDefinition compDef)
        {
            var light = obj.AddComponent<Light>();
            
            var lightType = compDef.GetProperty<string>("lightType", "Directional");
            if (Enum.TryParse<LightType>(lightType, out var type))
            {
                light.type = type;
            }
            
            var color = compDef.GetProperty<float[]>("color", new float[] { 1, 1, 1, 1 });
            light.color = new Color(color[0], color[1], color[2], color[3]);
            
            light.intensity = compDef.GetProperty<float>("intensity", 1f);
            light.range = compDef.GetProperty<float>("range", 10f);
            light.spotAngle = compDef.GetProperty<float>("spotAngle", 30f);
            light.shadows = compDef.GetProperty<bool>("shadows", false) ? 
                LightShadows.Soft : LightShadows.None;
        }
        
        private void ConfigureCamera(GameObject obj, ComponentDefinition compDef)
        {
            var camera = obj.AddComponent<Camera>();
            
            camera.fieldOfView = compDef.GetProperty<float>("fieldOfView", 60f);
            camera.nearClipPlane = compDef.GetProperty<float>("nearClipPlane", 0.3f);
            camera.farClipPlane = compDef.GetProperty<float>("farClipPlane", 1000f);
            camera.depth = compDef.GetProperty<float>("depth", 0f);
            
            var clearFlags = compDef.GetProperty<string>("clearFlags", "Skybox");
            if (Enum.TryParse<CameraClearFlags>(clearFlags, out var flags))
            {
                camera.clearFlags = flags;
            }
            
            var backgroundColor = compDef.GetProperty<float[]>("backgroundColor", 
                new float[] { 0.19f, 0.3f, 0.47f, 1f });
            camera.backgroundColor = new Color(
                backgroundColor[0], 
                backgroundColor[1], 
                backgroundColor[2], 
                backgroundColor[3]
            );
        }
        
        private void ConfigureAudioSource(GameObject obj, ComponentDefinition compDef)
        {
            var audioSource = obj.AddComponent<AudioSource>();
            
            audioSource.volume = compDef.GetProperty<float>("volume", 1f);
            audioSource.pitch = compDef.GetProperty<float>("pitch", 1f);
            audioSource.loop = compDef.GetProperty<bool>("loop", false);
            audioSource.playOnAwake = compDef.GetProperty<bool>("playOnAwake", false);
            audioSource.spatialBlend = compDef.GetProperty<float>("spatialBlend", 1f);
            audioSource.minDistance = compDef.GetProperty<float>("minDistance", 1f);
            audioSource.maxDistance = compDef.GetProperty<float>("maxDistance", 500f);
            
            var audioClipPath = compDef.GetProperty<string>("clip");
            if (!string.IsNullOrEmpty(audioClipPath))
            {
                // 加载音频剪辑
                LoadAudioClip(audioSource, audioClipPath);
            }
        }
        
        private void ConfigureModBehaviour(GameObject obj, ComponentDefinition compDef)
        {
            var behaviourClass = compDef.GetProperty<string>("behaviourClass");
            if (string.IsNullOrEmpty(behaviourClass))
            {
                Debug.LogError("ModBehaviour requires behaviourClass property");
                return;
            }
            
            var behaviourType = Type.GetType(behaviourClass);
            if (behaviourType != null && typeof(IModBehaviour).IsAssignableFrom(behaviourType))
            {
                var wrapper = obj.AddComponent<ModBehaviourWrapper>();
                var behaviour = Activator.CreateInstance(behaviourType) as IModBehaviour;
                
                var config = compDef.GetProperty<Dictionary<string, object>>("config");
                if (config != null && behaviour != null)
                {
                    ApplyBehaviourConfig(behaviour, config);
                }
                
                wrapper.Initialize(behaviour, new ModContext(obj));
            }
            else
            {
                Debug.LogError($"Could not find or instantiate behaviour class: {behaviourClass}");
            }
        }
        
        private void ApplyBehaviourConfig(IModBehaviour behaviour, Dictionary<string, object> config)
        {
            var type = behaviour.GetType();
            foreach (var kvp in config)
            {
                var property = type.GetProperty(kvp.Key);
                if (property != null && property.CanWrite)
                {
                    try
                    {
                        property.SetValue(behaviour, kvp.Value);
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError($"Failed to set property {kvp.Key}: {ex.Message}");
                    }
                }
            }
        }
        
        private async Task LoadGLTFModel(GameObject obj, string modelPath)
        {
            Debug.Log($"Loading glTF model: {modelPath}");
            // 这里应该使用实际的glTF加载库，如GLTFUtility或UnityGLTF
            await Task.Delay(100); // 模拟异步加载
        }
        
        private void ConfigureMaterial(MeshRenderer renderer, Dictionary<string, object> materialDef)
        {
            var material = new Material(Shader.Find("Standard"));
            
            if (materialDef.TryGetValue("color", out var colorObj) && colorObj is float[] color)
            {
                material.color = new Color(color[0], color[1], color[2], color.Length > 3 ? color[3] : 1f);
            }
            
            if (materialDef.TryGetValue("metallic", out var metallic))
            {
                material.SetFloat("_Metallic", Convert.ToSingle(metallic));
            }
            
            if (materialDef.TryGetValue("smoothness", out var smoothness))
            {
                material.SetFloat("_Glossiness", Convert.ToSingle(smoothness));
            }
            
            if (materialDef.TryGetValue("texture", out var texturePath))
            {
                LoadTexture(material, texturePath.ToString());
            }
            
            renderer.material = material;
        }
        
        private async void LoadTexture(Material material, string texturePath)
        {
            // 实际实现应该加载纹理文件
            Debug.Log($"Loading texture: {texturePath}");
            await Task.Delay(100);
        }
        
        private async void LoadAudioClip(AudioSource audioSource, string clipPath)
        {
            // 实际实现应该加载音频文件
            Debug.Log($"Loading audio clip: {clipPath}");
            await Task.Delay(100);
        }
        
        private async Task<string> LoadJsonAsync(string path)
        {
            var fullPath = System.IO.Path.Combine(basePath, path);
            return await System.IO.File.ReadAllTextAsync(fullPath);
        }
    }
    
    // ModBehaviour的Unity组件包装器
    public class ModBehaviourWrapper : MonoBehaviour
    {
        private IModBehaviour behaviour;
        private IModContext context;
        
        public void Initialize(IModBehaviour behaviour, IModContext context)
        {
            this.behaviour = behaviour;
            this.context = context;
            behaviour.OnInitialize(context);
        }
        
        void Update()
        {
            behaviour?.OnUpdate(Time.deltaTime);
        }
        
        void OnDestroy()
        {
            behaviour?.OnDestroy();
        }
    }
    
    // 简化的ModContext实现
    public class ModContext : IModContext
    {
        public string ModId { get; }
        public GameObject GameObject { get; }
        public IEventBus EventBus { get; }
        public IModAPI API { get; }
        public IServiceRegistry Services { get; }
        
        public ModContext(GameObject gameObject)
        {
            GameObject = gameObject;
            // 其他属性应该从全局管理器获取
        }
        
        public T GetComponent<T>() where T : Component
        {
            return GameObject.GetComponent<T>();
        }
        
        public void Log(string message)
        {
            Debug.Log($"[{ModId}] {message}");
        }
        
        public void LogError(string message)
        {
            Debug.LogError($"[{ModId}] {message}");
        }
    }
}
```

## 使用示例

### 1. 基本事件通信

```csharp
// 按钮模组发送事件
public class SimpleButton : IModBehaviour
{
    public string BehaviourId => "simple_button";
    public string Version => "1.0.0";
    
    private IModContext context;
    
    public void OnInitialize(IModContext context)
    {
        this.context = context;
    }
    
    void OnClick()
    {
        context.EventBus.Publish(new ButtonPressedEvent
        {
            SenderId = "simple_button",
            ButtonId = "btn_1",
            Parameters = new Dictionary<string, object>
            {
                { "action", "rotate_robot" },
                { "angle", 45f }
            }
        });
    }
    
    public void OnUpdate(float deltaTime) { }
    public void OnDestroy() { }
}
```

### 2. 请求-响应通信

```csharp
// 按钮发送请求
public class SmartButton : IModBehaviour
{
    async void OnClick()
    {
        var request = new RobotControlRequest
        {
            SenderId = "smart_button",
            Command = "move_joint",
            Parameters = new Dictionary<string, object>
            {
                { "jointName", "base_rotation" },
                { "angle", 90f }
            }
        };
        
        try
        {
            var response = await context.API.RequestResponse
                .SendRequestAsync<RobotControlRequest, RobotControlResponse>(
                    request, 
                    TimeSpan.FromSeconds(5)
                );
            
            if (response.Success)
            {
                context.Log("Robot moved successfully");
            }
        }
        catch (TimeoutException)
        {
            context.LogError("Robot did not respond in time");
        }
    }
}
```

### 3. 服务调用

```csharp
// 使用服务的按钮
public class ServiceButton : IModBehaviour
{
    private IRobotService robotService;
    
    public void OnInitialize(IModContext context)
    {
        robotService = context.Services.GetService<IRobotService>();
        
        if (robotService == null)
        {
            context.EventBus.Subscribe<ServiceRegisteredEvent>(e =>
            {
                if (e.ServiceType == nameof(IRobotService))
                {
                    robotService = context.Services.GetService<IRobotService>();
                }
            });
        }
    }
    
    async void OnClick()
    {
        if (robotService != null)
        {
            bool success = await robotService.MoveJoint("base_rotation", 45f);
            if (success)
            {
                context.Log("Robot rotated successfully");
            }
        }
    }
}
```

### 4. 使用对象定义创建游戏对象

```csharp
public class ModWithObjects : IModBehaviour
{
    private IModContext context;
    private List<GameObject> createdObjects = new List<GameObject>();
    
    public async void OnInitialize(IModContext context)
    {
        this.context = context;
        
        // 从对象定义创建按钮
        var buttonObj = await context.API.ObjectFactory
            .CreateObjectAsync("Objects/interactive_button.json");
        
        buttonObj.transform.position = new Vector3(0, 1, 0);
        createdObjects.Add(buttonObj);
        
        // 动态创建对象
        var dynamicDef = new ObjectDefinition
        {
            objectId = "dynamic_cube",
            name = "动态立方体",
            components = new List<ComponentDefinition>
            {
                new ComponentDefinition
                {
                    type = "Transform",
                    properties = new Dictionary<string, object>
                    {
                        { "position", new[] { 5f, 0f, 0f } },
                        { "scale", new[] { 2f, 2f, 2f } }
                    }
                }
            }
        };
        
        var cube = await context.API.ObjectFactory
            .CreateObjectFromDefinitionAsync(dynamicDef);
        createdObjects.Add(cube);
    }
}
```

## 配置说明

### 1. 模组配置结构

```json
{
  "mod": {
    "id": "button_robot_system",
    "version": "1.0.0",
    "modules": [
      {
        "id": "button_module",
        "type": "ButtonMod.ButtonBehaviour",
        "config": {
          "buttonId": "main_button",
          "communicationMode": "Service",
          "targetService": "IRobotService"
        }
      },
      {
        "id": "robot_module",
        "type": "RobotMod.RobotArmBehaviour",
        "config": {
          "joints": [
            {
              "name": "base_rotation",
              "axis": [0, 1, 0],
              "minAngle": -180,
              "maxAngle": 180
            }
          ]
        }
      }
    ]
  }
}
```

### 2. 通信配置

```json
{
  "routes": [
    {
      "name": "button_to_robot_rotation",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "rotate_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.RotateJointEvent",
          "parameters": {
            "jointName": "base_rotation",
            "angle": 45,
            "speed": 30
          }
        }
      ]
    }
  ]
}
```

### 3. 对象定义示例

```json
{
  "objectId": "interactive_button_01",
  "name": "交互按钮",
  "components": [
    {
      "type": "Transform",
      "properties": {
        "position": [0, 1, 0],
        "rotation": [0, 0, 0],
        "scale": [1, 0.2, 1]
      }
    },
    {
      "type": "MeshRenderer",
      "properties": {
        "model": "Models/button.gltf",
        "material": {
          "shader": "Standard",
          "color": [1, 1, 1, 1],
          "metallic": 0.5,
          "smoothness": 0.8
        }
      }
    },
    {
      "type": "BoxCollider",
      "properties": {
        "center": [0, 0, 0],
        "size": [1, 0.2, 1],
        "isTrigger": false
      }
    },
    {
      "type": "ModBehaviour",
      "properties": {
        "behaviourClass": "ButtonMod.ButtonBehaviour",
        "config": {
          "buttonId": "btn_01",
          "buttonType": "toggle",
          "clickSound": "audio/click.wav"
        }
      }
    }
  ]
}
```

## 独立模组开发（无需Unity）

### 1. ModSDK - 独立开发包

#### ModSDK.Core.dll 实现
```csharp
// ModSDK.Core/Interfaces.cs
using System;
using System.Collections.Generic;

namespace ModSDK.Core
{
    public interface IModBehaviour
    {
        string BehaviourId { get; }
        string Version { get; }
        void OnInitialize(IModContext context);
        void OnUpdate(float deltaTime);
        void OnDestroy();
    }
    
    public struct Vector3
    {
        public float x, y, z;
        
        public Vector3(float x, float y, float z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        
        public static Vector3 Zero => new Vector3(0, 0, 0);
        public static Vector3 One => new Vector3(1, 1, 1);
        public static Vector3 Up => new Vector3(0, 1, 0);
        
        public static implicit operator UnityEngine.Vector3(Vector3 v)
        {
            return new UnityEngine.Vector3(v.x, v.y, v.z);
        }
    }
}
```

### 2. ModBuilder - 命令行构建工具

```csharp
// ModBuilder/Program.cs
using System;
using System.IO;
using System.IO.Compression;
using System.Text.Json;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace ModBuilder
{
    class Program
    {
        static string SDKPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "SDK");
        static string TemplatesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Templates");
        
        static void Main(string[] args)
        {
            Console.WriteLine("╔══════════════════════════════╗");
            Console.WriteLine("║     Mod Builder v1.0.0       ║");
            Console.WriteLine("║   Unity模组独立开发工具       ║");
            Console.WriteLine("╚══════════════════════════════╝\n");
            
            if (args.Length == 0)
            {
                ShowInteractiveMenu();
            }
            else
            {
                ProcessCommand(args);
            }
        }
        
        static void ShowInteractiveMenu()
        {
            while (true)
            {
                Console.WriteLine("\n请选择操作:");
                Console.WriteLine("1. 创建新模组项目");
                Console.WriteLine("2. 构建现有模组");
                Console.WriteLine("3. 测试模组");
                Console.WriteLine("4. 打包模组");
                Console.WriteLine("5. 查看帮助");
                Console.WriteLine("6. 退出");
                Console.Write("\n请输入选项 (1-6): ");
                
                var choice = Console.ReadLine();
                Console.WriteLine();
                
                switch (choice)
                {
                    case "1":
                        CreateNewMod();
                        break;
                    case "2":
                        BuildMod();
                        break;
                    case "3":
                        TestMod();
                        break;
                    case "4":
                        PackageMod();
                        break;
                    case "5":
                        ShowHelp();
                        break;
                    case "6":
                        return;
                    default:
                        Console.WriteLine("无效选项，请重试。");
                        break;
                }
            }
        }
        
        static void CreateNewMod()
        {
            Console.WriteLine("=== 创建新模组 ===\n");
            
            Console.Write("模组ID (例如: my_custom_mod): ");
            var modId = Console.ReadLine()?.ToLower().Replace(" ", "_");
            
            Console.Write("模组名称: ");
            var modName = Console.ReadLine();
            
            Console.Write("作者名称: ");
            var author = Console.ReadLine();
            
            Console.WriteLine("\n选择模组类型:");
            Console.WriteLine("1. 按钮模组");
            Console.WriteLine("2. 机器人模组");
            Console.WriteLine("3. 传感器模组");
            Console.WriteLine("4. 空白模组");
            Console.Write("\n请选择 (1-4): ");
            
            var modType = Console.ReadLine();
            var templateName = modType switch
            {
                "1" => "ButtonMod",
                "2" => "RobotMod",
                "3" => "SensorMod",
                _ => "EmptyMod"
            };
            
            var projectPath = Path.Combine(Directory.GetCurrentDirectory(), modId);
            
            try
            {
                CreateModProject(projectPath, modId, modName, author, templateName);
                Console.WriteLine($"\n✓ 模组项目创建成功!");
                Console.WriteLine($"  位置: {projectPath}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n✗ 创建失败: {ex.Message}");
            }
        }
        
        static void CreateModProject(string projectPath, string modId, string modName, 
            string author, string templateName)
        {
            // 创建目录结构
            Directory.CreateDirectory(projectPath);
            Directory.CreateDirectory(Path.Combine(projectPath, "Source"));
            Directory.CreateDirectory(Path.Combine(projectPath, "Config"));
            Directory.CreateDirectory(Path.Combine(projectPath, "Resources"));
            Directory.CreateDirectory(Path.Combine(projectPath, "Objects"));
            Directory.CreateDirectory(Path.Combine(projectPath, "Models"));
            Directory.CreateDirectory(Path.Combine(projectPath, "SDK"));
            
            // 复制SDK文件
            CopyDirectory(SDKPath, Path.Combine(projectPath, "SDK"));
            
            // 创建项目文件
            var projectContent = GenerateProjectFile(modId, author);
            File.WriteAllText(Path.Combine(projectPath, $"{ToPascalCase(modId)}.csproj"), projectContent);
            
            // 创建清单文件
            var manifest = GenerateManifest(modId, modName, author);
            File.WriteAllText(Path.Combine(projectPath, "manifest.json"), manifest);
            
            // 根据模板创建源代码
            CreateSourceFromTemplate(projectPath, modId, templateName);
            
            // 创建配置文件
            CreateConfigFromTemplate(projectPath, modId, templateName);
            
            // 创建对象定义
            CreateObjectDefinitions(projectPath, modId, templateName);
            
            // 创建README
            CreateReadme(projectPath, modId, modName);
        }
        
        static string GenerateProjectFile(string modId, string author)
        {
            return $@"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <AssemblyName>{ToPascalCase(modId)}</AssemblyName>
    <Version>1.0.0</Version>
    <Authors>{author}</Authors>
  </PropertyGroup>

  <ItemGroup>
    <Reference Include=""ModSDK.Core"">
      <HintPath>SDK\ModSDK.Core.dll</HintPath>
    </Reference>
    <Reference Include=""ModSDK.Runtime"">
      <HintPath>SDK\ModSDK.Runtime.dll</HintPath>
    </Reference>
    <Reference Include=""UnityEngine.CoreModule"">
      <HintPath>SDK\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include=""Newtonsoft.Json"">
      <HintPath>SDK\Newtonsoft.Json.dll</HintPath>
    </Reference>
  </ItemGroup>

  <ItemGroup>
    <None Update=""Config\*.json"">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update=""Objects\*.json"">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update=""Models\*.*"">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update=""Resources\**\*"">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>";
        }
        
        static string GenerateManifest(string modId, string modName, string author)
        {
            var manifest = new
            {
                id = modId,
                name = modName,
                version = "1.0.0",
                author = author,
                unity_version = "2021.3",
                sdk_version = "1.0.0",
                main_class = $"{ToPascalCase(modId)}.{ToPascalCase(modId)}Behaviour",
                dependencies = new[]
                {
                    new { id = "mod_system_core", version = ">=1.0.0" }
                },
                permissions = new[] { "event_publish", "event_subscribe" }
            };
            
            return JsonSerializer.Serialize(manifest, new JsonSerializerOptions 
            { 
                WriteIndented = true 
            });
        }
        
        static void CreateSourceFromTemplate(string projectPath, string modId, string templateName)
        {
            var className = ToPascalCase(modId);
            var sourcePath = Path.Combine(projectPath, "Source", $"{className}Behaviour.cs");
            
            string sourceCode = templateName switch
            {
                "ButtonMod" => GenerateButtonModCode(modId, className),
                "RobotMod" => GenerateRobotModCode(modId, className),
                "SensorMod" => GenerateSensorModCode(modId, className),
                _ => GenerateEmptyModCode(modId, className)
            };
            
            File.WriteAllText(sourcePath, sourceCode);
        }
        
        static string GenerateButtonModCode(string modId, string className)
        {
            return $@"using System;
using System.Collections.Generic;
using ModSDK.Core;
using Newtonsoft.Json;

namespace {className}
{{
    public class {className}Behaviour : IModBehaviour
    {{
        public string BehaviourId => ""{modId}_behaviour"";
        public string Version => ""1.0.0"";
        
        private IModContext context;
        private ButtonConfig config;
        
        public void OnInitialize(IModContext context)
        {{
            this.context = context;
            config = context.LoadConfig<ButtonConfig>(""config.json"");
            
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            context.Log($""按钮模组 {{config.ButtonName}} 初始化完成"");
        }}
        
        private void OnInteraction(InteractionEvent e)
        {{
            if (e.TargetId != context.GameObject.Id)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {{
                OnButtonClick();
            }}
        }}
        
        private void OnButtonClick()
        {{
            var buttonEvent = new ButtonPressedEvent
            {{
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                Parameters = config.ActionParameters
            }};
            
            context.EventBus.Publish(buttonEvent);
            context.Log($""按钮 {{config.ButtonName}} 被点击"");
        }}
        
        public void OnUpdate(float deltaTime) {{ }}
        public void OnDestroy() {{ }}
    }}
    
    public class ButtonConfig
    {{
        public string ButtonId {{ get; set; }} = ""button_01"";
        public string ButtonName {{ get; set; }} = ""按钮1"";
        public Dictionary<string, object> ActionParameters {{ get; set; }}
    }}
}}";
        }
        
        static void BuildMod()
        {
            Console.WriteLine("=== 构建模组 ===\n");
            
            Console.Write("输入模组项目路径 (或按Enter使用当前目录): ");
            var projectPath = Console.ReadLine();
            
            if (string.IsNullOrWhiteSpace(projectPath))
                projectPath = Directory.GetCurrentDirectory();
            
            var projectFiles = Directory.GetFiles(projectPath, "*.csproj");
            if (projectFiles.Length == 0)
            {
                Console.WriteLine("\n✗ 错误: 找不到项目文件");
                return;
            }
            
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "dotnet",
                    Arguments = $"build \"{projectFiles[0]}\" -c Release",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    WorkingDirectory = projectPath
                }
            };
            
            process.Start();
            process.WaitForExit();
            
            if (process.ExitCode == 0)
            {
                Console.WriteLine("\n✓ 构建成功!");
            }
            else
            {
                Console.WriteLine("\n✗ 构建失败");
            }
        }
        
        static void PackageMod()
        {
            Console.WriteLine("=== 打包模组 ===\n");
            
            Console.Write("输入模组项目路径: ");
            var projectPath = Console.ReadLine();
            
            if (string.IsNullOrWhiteSpace(projectPath))
                projectPath = Directory.GetCurrentDirectory();
            
            var outputDir = Path.Combine(projectPath, "bin", "Release", "netstandard2.1");
            if (!Directory.Exists(outputDir))
            {
                Console.WriteLine("\n✗ 错误: 请先构建模组");
                return;
            }
            
            try
            {
                var manifestPath = Path.Combine(projectPath, "manifest.json");
                var manifestJson = File.ReadAllText(manifestPath);
                using var doc = JsonDocument.Parse(manifestJson);
                
                var modId = doc.RootElement.GetProperty("id").GetString();
                var version = doc.RootElement.GetProperty("version").GetString();
                
                var packageDir = Path.Combine(projectPath, "Package");
                Directory.CreateDirectory(packageDir);
                
                var tempDir = Path.Combine(packageDir, "temp");
                Directory.CreateDirectory(tempDir);
                
                // 复制文件
                CopyModFiles(outputDir, tempDir, manifestPath);
                
                // 创建ZIP包
                var packageName = $"{modId}_v{version}.modpack";
                var packagePath = Path.Combine(packageDir, packageName);
                
                ZipFile.CreateFromDirectory(tempDir, packagePath);
                Directory.Delete(tempDir, true);
                
                Console.WriteLine($"\n✓ 打包成功!");
                Console.WriteLine($"  文件: {packagePath}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n✗ 打包失败: {ex.Message}");
            }
        }
        
        static void CopyModFiles(string sourceDir, string targetDir, string manifestPath)
        {
            // 复制DLL
            var dllDir = Path.Combine(targetDir, "Assemblies");
            Directory.CreateDirectory(dllDir);
            
            foreach (var dll in Directory.GetFiles(sourceDir, "*.dll"))
            {
                var fileName = Path.GetFileName(dll);
                if (!fileName.StartsWith("ModSDK") && !fileName.StartsWith("Unity"))
                {
                    File.Copy(dll, Path.Combine(dllDir, fileName));
                }
            }
            
            // 复制资源目录
            CopyIfExists(sourceDir, targetDir, "Config");
            CopyIfExists(sourceDir, targetDir, "Objects");
            CopyIfExists(sourceDir, targetDir, "Models");
            CopyIfExists(sourceDir, targetDir, "Resources");
            
            // 复制清单
            File.Copy(manifestPath, Path.Combine(targetDir, "manifest.json"));
        }
        
        static void CopyIfExists(string sourceBase, string targetBase, string dirName)
        {
            var sourceDir = Path.Combine(sourceBase, dirName);
            if (Directory.Exists(sourceDir))
            {
                CopyDirectory(sourceDir, Path.Combine(targetBase, dirName));
            }
        }
        
        static void TestMod()
        {
            Console.WriteLine("=== 测试模组 ===\n");
            Console.WriteLine("测试功能需要连接到运行中的Unity游戏实例。");
            Console.WriteLine("此功能正在开发中...");
        }
        
        static void ShowHelp()
        {
            Console.WriteLine("=== 使用帮助 ===\n");
            Console.WriteLine("命令行用法:");
            Console.WriteLine("  ModBuilder new <mod_id>     - 创建新模组");
            Console.WriteLine("  ModBuilder build [path]     - 构建模组");
            Console.WriteLine("  ModBuilder package [path]   - 打包模组");
            Console.WriteLine("  ModBuilder help            - 显示帮助");
        }
        
        static void ProcessCommand(string[] args)
        {
            var command = args[0].ToLower();
            
            switch (command)
            {
                case "new":
                    if (args.Length < 2)
                    {
                        Console.WriteLine("用法: ModBuilder new <mod_id>");
                        return;
                    }
                    CreateNewModFromCommand(args[1]);
                    break;
                    
                case "build":
                    BuildMod();
                    break;
                    
                case "package":
                    PackageMod();
                    break;
                    
                case "help":
                    ShowHelp();
                    break;
                    
                default:
                    Console.WriteLine($"未知命令: {command}");
                    ShowHelp();
                    break;
            }
        }
        
        static void CreateNewModFromCommand(string modId)
        {
            var projectPath = Path.Combine(Directory.GetCurrentDirectory(), modId);
            CreateModProject(projectPath, modId, modId, "Developer", "EmptyMod");
            Console.WriteLine($"模组项目已创建: {projectPath}");
        }
        
        static void CopyDirectory(string sourceDir, string targetDir)
        {
            Directory.CreateDirectory(targetDir);
            
            foreach (var file in Directory.GetFiles(sourceDir))
            {
                File.Copy(file, Path.Combine(targetDir, Path.GetFileName(file)), true);
            }
            
            foreach (var dir in Directory.GetDirectories(sourceDir))
            {
                CopyDirectory(dir, Path.Combine(targetDir, Path.GetFileName(dir)));
            }
        }
        
        static string ToPascalCase(string text)
        {
            return string.Join("", text.Split('_')
                .Select(word => char.ToUpper(word[0]) + word.Substring(1)));
        }
        
        static void CreateConfigFromTemplate(string projectPath, string modId, string templateName)
        {
            var configPath = Path.Combine(projectPath, "Config", "config.json");
            
            object config = templateName switch
            {
                "ButtonMod" => new
                {
                    buttonId = $"{modId}_btn_01",
                    buttonName = "示例按钮",
                    actionParameters = new
                    {
                        action = "custom_action",
                        value = 100
                    }
                },
                _ => new
                {
                    modId = modId,
                    enabled = true
                }
            };
            
            var json = JsonSerializer.Serialize(config, new JsonSerializerOptions 
            { 
                WriteIndented = true 
            });
            File.WriteAllText(configPath, json);
        }
        
        static void CreateObjectDefinitions(string projectPath, string modId, string templateName)
        {
            if (templateName == "ButtonMod")
            {
                var buttonDef = new
                {
                    objectId = $"{modId}_button",
                    name = "交互按钮",
                    components = new[]
                    {
                        new
                        {
                            type = "Transform",
                            properties = new
                            {
                                position = new[] { 0f, 1f, 0f },
                                scale = new[] { 1f, 0.2f, 1f }
                            }
                        }
                    }
                };
                
                var json = JsonSerializer.Serialize(buttonDef, new JsonSerializerOptions 
                { 
                    WriteIndented = true 
                });
                
                File.WriteAllText(
                    Path.Combine(projectPath, "Objects", "button.json"), 
                    json
                );
            }
        }
        
        static void CreateReadme(string projectPath, string modId, string modName)
        {
            var readme = $@"# {modName}

## 开发说明

### 构建步骤
1. 运行: `ModBuilder build`
2. 运行: `ModBuilder package`

### 安装
将生成的 .modpack 文件复制到游戏的模组目录
";
            
            File.WriteAllText(Path.Combine(projectPath, "README.md"), readme);
        }
        
        // 其他模板生成方法
        static string GenerateRobotModCode(string modId, string className)
        {
            return GenerateEmptyModCode(modId, className);
        }
        
        static string GenerateSensorModCode(string modId, string className)
        {
            return GenerateEmptyModCode(modId, className);
        }
        
        static string GenerateEmptyModCode(string modId, string className)
        {
            return $@"using System;
using ModSDK.Core;

namespace {className}
{{
    public class {className}Behaviour : IModBehaviour
    {{
        public string BehaviourId => ""{modId}_behaviour"";
        public string Version => ""1.0.0"";
        
        private IModContext context;
        
        public void OnInitialize(IModContext context)
        {{
            this.context = context;
            context.Log($""模组 {{BehaviourId}} 初始化"");
        }}
        
        public void OnUpdate(float deltaTime)
        {{
            // 更新逻辑
        }}
        
        public void OnDestroy()
        {{
            context.Log($""模组 {{BehaviourId}} 销毁"");
        }}
    }}
}}";
        }
    }
}
```

### 3. 可视化编辑器

提供图形化编辑器，让非程序员也能创建模组：

```csharp
// ModEditor核心逻辑示例
public class VisualModEditor
{
    public abstract class ModNode
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public List<NodePort> InputPorts { get; set; }
        public List<NodePort> OutputPorts { get; set; }
        public Point Position { get; set; }
    }
    
    public class EventNode : ModNode
    {
        public string EventType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
    
    public class VisualToCodeGenerator
    {
        public string GenerateCode(List<ModNode> nodes, List<NodeConnection> connections)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("using System;");
            sb.AppendLine("using ModSDK.Core;");
            sb.AppendLine();
            sb.AppendLine("namespace GeneratedMod");
            sb.AppendLine("{");
            sb.AppendLine("    public class GeneratedBehaviour : IModBehaviour");
            sb.AppendLine("    {");
            
            foreach (var eventNode in nodes.OfType<EventNode>())
            {
                GenerateEventHandler(sb, eventNode, connections);
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            return sb.ToString();
        }
    }
}
```

### 4. Web在线编辑器

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>模组在线编辑器</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #blocklyDiv {
            height: 500px;
            width: 100%;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #codeOutput {
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Unity模组在线编辑器</h1>
        
        <div class="toolbar">
            <button onclick="generateCode()">生成代码</button>
            <button onclick="downloadMod()">下载模组</button>
        </div>
        
        <div id="blocklyDiv"></div>
        
        <h3>生成的代码：</h3>
        <pre id="codeOutput">// 拖动积木来生成代码</pre>
    </div>

    <script>
        // 初始化Blockly
        var workspace = Blockly.inject('blocklyDiv', {
            toolbox: /* ... 工具箱配置 ... */
        });

        function generateCode() {
            // 生成C#代码
            var code = generateCSharpCode(workspace.getAllBlocks());
            document.getElementById('codeOutput').textContent = code;
        }

        function downloadMod() {
            // 下载模组包
            var code = document.getElementById('codeOutput').textContent;
            // 创建并下载文件
        }
    </script>
</body>
</html>
```

### 5. 安装和使用说明

#### 创建第一个模组

1. **运行ModBuilder**
   ```bash
   ModBuilder
   ```

2. **按照交互式菜单创建模组**
   - 选择 "1" 创建新模组
   - 输入模组信息
   - 选择模组类型

3. **编辑模组代码**
   ```bash
   code my_custom_mod/
   ```

4. **编辑对象定义**
   - 打开 `Objects/` 目录
   - 编辑 JSON 文件定义游戏对象

5. **构建模组**
   ```bash
   ModBuilder
   # 选择 "2" 构建模组
   ```

6. **打包模组**
   ```bash
   ModBuilder
   # 选择 "4" 打包模组
   ```

### 6. 开发流程

#### 创建新模组

```bash
# 方式1：交互式创建
ModBuilder

# 方式2：命令行参数
ModBuilder new my_custom_mod --type button --author "Your Name"
```

这会创建以下结构：
```
my_custom_mod/
├── Source/
│   └── MyCustomModBehaviour.cs
├── Objects/
│   └── interactive_button.json
├── Models/
├── Config/
│   └── config.json
├── Resources/
├── SDK/
├── MyCustomMod.csproj
├── manifest.json
└── README.md
```

## 最佳实践

### 1. 选择合适的通信模式

| 场景 | 推荐模式 | 原因 |
|------|----------|------|
| 状态通知 | 事件模式 | 简单、解耦、一对多 |
| 命令执行 | 请求-响应 | 需要确认、错误处理 |
| API调用 | 服务模式 | 类型安全、紧密协作 |
| 复杂流程 | 配置驱动 | 灵活、可维护 |

### 2. 开发建议

1. **使用版本控制**：所有模组都应该有明确的版本号
2. **编写单元测试**：为模组编写自动化测试
3. **文档齐全**：为每个模组提供详细的API文档
4. **遵循命名规范**：使用统一的命名约定
5. **性能监控**：在开发时监控模组的性能影响
6. **使用对象定义**：通过JSON文件定义游戏对象，而不是依赖Unity编辑器
7. **模型格式标准化**：统一使用glTF格式的3D模型
8. **配置驱动开发**：尽可能通过配置文件控制行为，减少硬编码

## 安装和部署

### 1. 主系统集成（Unity项目）

在Unity项目中集成模组系统：

```csharp
// ModSystemController.cs
using UnityEngine;
using ModSystem.Core;
using System.IO;

public class ModSystemController : MonoBehaviour
{
    private ModManager modManager;
    private ModEventBus eventBus;
    private ModServiceRegistry serviceRegistry;
    private CommunicationRouter router;
    
    public IEventBus EventBus => eventBus;
    public IServiceRegistry ServiceRegistry => serviceRegistry;
    
    void Awake()
    {
        // 初始化核心组件
        eventBus = new ModEventBus(new DebugEventLogger());
        serviceRegistry = new ModServiceRegistry(eventBus);
        
        // 创建模组管理器
        modManager = gameObject.AddComponent<ModManager>();
        modManager.Initialize(eventBus, serviceRegistry);
        
        // 加载通信配置
        LoadCommunicationConfig();
    }
    
    void Start()
    {
        // 加载模组
        LoadMods();
    }
    
    private void LoadCommunicationConfig()
    {
        string configPath = Path.Combine(Application.streamingAssetsPath, 
            "ModConfigs/communication_config.json");
        
        if (File.Exists(configPath))
        {
            string configJson = File.ReadAllText(configPath);
            router = new CommunicationRouter(eventBus, configJson);
        }
    }
    
    private void LoadMods()
    {
        // 加载内置模组
        modManager.LoadMod("Assets/Mods/ButtonMod");
        modManager.LoadMod("Assets/Mods/RobotMod");
        
        // 加载外部模组包
        string modPackagesPath = Path.Combine(Application.streamingAssetsPath, 
            "ModPackages");
        
        if (Directory.Exists(modPackagesPath))
        {
            foreach (var modFile in Directory.GetFiles(modPackagesPath, "*.modpack"))
            {
                modManager.LoadModPackage(modFile);
            }
        }
    }
}

public class DebugEventLogger : IEventLogger
{
    public void LogEvent(IModEvent e)
    {
        Debug.Log($"[Event] {e.EventId} from {e.SenderId}");
    }
    
    public void LogSubscription(string eventType, string subscriber)
    {
        Debug.Log($"[Subscribe] {subscriber} -> {eventType}");
    }
    
    public void LogError(string message)
    {
        Debug.LogError($"[EventBus] {message}");
    }
}
```

### 2. 模组安装（用户端）

```bash
# 方式1：安装.modpack文件
1. 下载 xxx.modpack 文件
2. 将文件复制到：游戏目录/StreamingAssets/ModPackages/
3. 重启游戏或在游戏内刷新模组列表

# 方式2：手动安装（开发者模式）
1. 将模组文件夹复制到：游戏目录/StreamingAssets/Mods/
2. 确保包含manifest.json和所有必要文件
```

### 3. 快速参考

| 文件类型 | 位置 | 说明 |
|---------|------|------|
| **核心接口** | `Assets/ModSystem/Core/Interfaces/` | 所有模组共享的接口定义 |
| **事件系统** | `Assets/ModSystem/Core/EventSystem/` | 事件总线实现 |
| **通信系统** | `Assets/ModSystem/Core/Communication/` | 请求响应、路由等 |
| **服务系统** | `Assets/ModSystem/Core/Services/` | 服务注册表 |
| **对象工厂** | `Assets/ModSystem/Core/Runtime/ObjectFactory.cs` | 运行时对象创建 |
| **模组代码** | `[ModName]/Source/` | 各模组的C#源代码 |
| **对象定义** | `[ModName]/Objects/` | JSON格式的对象定义 |
| **3D模型** | `[ModName]/Models/` | glTF格式的3D模型 |
| **模组配置** | `[ModName]/Config/` | 模组配置文件 |
| **通信配置** | `Assets/StreamingAssets/ModConfigs/` | 全局通信配置 |
| **模组包** | `Assets/StreamingAssets/ModPackages/` | .modpack文件 |

## 支持系统实现

### 1. ModLoader 实现

```csharp
// ModSystem.Core/Runtime/ModLoader.cs
using System;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace ModSystem.Core
{
    public class ModLoader
    {
        private readonly string modPath;
        private readonly SecurityManager securityManager;
        private readonly Dictionary<string, LoadedMod> loadedMods;
        
        public ModLoader(string modPath, SecurityManager securityManager = null)
        {
            this.modPath = modPath;
            this.securityManager = securityManager;
            this.loadedMods = new Dictionary<string, LoadedMod>();
        }
        
        public async Task<LoadedMod> LoadModAsync(string modDirectory)
        {
            try
            {
                // 1. 加载清单文件
                var manifestPath = Path.Combine(modDirectory, "manifest.json");
                if (!File.Exists(manifestPath))
                {
                    throw new FileNotFoundException("Manifest file not found");
                }
                
                var manifestJson = await File.ReadAllTextAsync(manifestPath);
                var manifest = JsonUtility.FromJson<ModManifest>(manifestJson);
                
                // 2. 验证安全性
                if (securityManager != null && !securityManager.ValidateMod(modDirectory))
                {
                    throw new SecurityException("Mod failed security validation");
                }
                
                // 3. 加载程序集
                Assembly assembly = null;
                var dllPath = Path.Combine(modDirectory, "Assemblies", $"{manifest.id}.dll");
                if (File.Exists(dllPath))
                {
                    assembly = Assembly.LoadFrom(dllPath);
                }
                
                // 4. 加载资源
                var resources = await LoadResourcesAsync(modDirectory, manifest);
                
                // 5. 创建模组实例
                var loadedMod = new LoadedMod
                {
                    Manifest = manifest,
                    Assembly = assembly,
                    Resources = resources,
                    RootPath = modDirectory
                };
                
                // 6. 实例化行为类
                if (manifest.scripts != null)
                {
                    foreach (var script in manifest.scripts)
                    {
                        var type = assembly.GetType(script.type);
                        if (type != null && typeof(IModBehaviour).IsAssignableFrom(type))
                        {
                            var behaviour = Activator.CreateInstance(type) as IModBehaviour;
                            loadedMod.Behaviours.Add(behaviour);
                        }
                    }
                }
                
                loadedMods[manifest.id] = loadedMod;
                return loadedMod;
            }
            catch (Exception ex)
            {
                Debug.LogError($"Failed to load mod: {ex.Message}");
                throw;
            }
        }
        
        public async Task<LoadedMod> LoadModPackageAsync(string packagePath)
        {
            try
            {
                // 1. 解压到临时目录
                var tempDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
                System.IO.Compression.ZipFile.ExtractToDirectory(packagePath, tempDir);
                
                // 2. 加载模组
                var loadedMod = await LoadModAsync(tempDir);
                
                // 3. 更新根路径为解压后的路径
                loadedMod.IsTemporary = true;
                loadedMod.RootPath = tempDir;
                
                return loadedMod;
            }
            catch (Exception ex)
            {
                Debug.LogError($"Failed to load mod package: {ex.Message}");
                throw;
            }
        }
        
        private async Task<ModResources> LoadResourcesAsync(string modDirectory, ModManifest manifest)
        {
            var resources = new ModResources();
            
            // 加载模型文件路径
            if (manifest.resources?.models != null)
            {
                foreach (var modelPath in manifest.resources.models)
                {
                    resources.ModelPaths[Path.GetFileName(modelPath)] = 
                        Path.Combine(modDirectory, modelPath);
                }
            }
            
            // 加载对象定义
            if (manifest.resources?.objects != null)
            {
                foreach (var objectPath in manifest.resources.objects)
                {
                    var fullPath = Path.Combine(modDirectory, objectPath);
                    if (File.Exists(fullPath))
                    {
                        var objectJson = await File.ReadAllTextAsync(fullPath);
                        var objectDef = JsonSerializer.Deserialize<ObjectDefinition>(objectJson);
                        resources.ObjectDefinitions[Path.GetFileName(objectPath)] = objectDef;
                    }
                }
            }
            
            // 加载配置文件
            if (manifest.resources?.configs != null)
            {
                foreach (var configPath in manifest.resources.configs)
                {
                    var fullPath = Path.Combine(modDirectory, configPath);
                    if (File.Exists(fullPath))
                    {
                        var configData = await File.ReadAllTextAsync(fullPath);
                        resources.Configs[Path.GetFileName(configPath)] = configData;
                    }
                }
            }
            
            // 加载纹理路径
            if (manifest.resources?.textures != null)
            {
                foreach (var texturePath in manifest.resources.textures)
                {
                    resources.TexturePaths[Path.GetFileName(texturePath)] = 
                        Path.Combine(modDirectory, texturePath);
                }
            }
            
            return resources;
        }
        
        public void UnloadMod(string modId)
        {
            if (loadedMods.TryGetValue(modId, out var mod))
            {
                // 销毁所有行为
                foreach (var behaviour in mod.Behaviours)
                {
                    behaviour.OnDestroy();
                }
                
                // 清理临时文件
                if (mod.IsTemporary && Directory.Exists(mod.RootPath))
                {
                    Directory.Delete(mod.RootPath, true);
                }
                
                loadedMods.Remove(modId);
                Debug.Log($"Mod {modId} unloaded");
            }
        }
        
        public LoadedMod GetLoadedMod(string modId)
        {
            return loadedMods.TryGetValue(modId, out var mod) ? mod : null;
        }
        
        public IEnumerable<LoadedMod> GetAllLoadedMods()
        {
            return loadedMods.Values;
        }
    }
    
    public class LoadedMod
    {
        public ModManifest Manifest { get; set; }
        public Assembly Assembly { get; set; }
        public ModResources Resources { get; set; }
        public string RootPath { get; set; }
        public bool IsTemporary { get; set; }
        public List<IModBehaviour> Behaviours { get; set; } = new List<IModBehaviour>();
        public Dictionary<string, GameObject> CreatedObjects { get; set; } = new Dictionary<string, GameObject>();
    }
    
    public class ModResources
    {
        public Dictionary<string, string> ModelPaths { get; set; } = new Dictionary<string, string>();
        public Dictionary<string, ObjectDefinition> ObjectDefinitions { get; set; } = new Dictionary<string, ObjectDefinition>();
        public Dictionary<string, string> Configs { get; set; } = new Dictionary<string, string>();
        public Dictionary<string, string> TexturePaths { get; set; } = new Dictionary<string, string>();
        public Dictionary<string, AudioClip> AudioClips { get; set; } = new Dictionary<string, AudioClip>();
    }
    
    [Serializable]
    public class ModManifest
    {
        public string id;
        public string name;
        public string version;
        public string author;
        public string description;
        public string unityVersion;
        public string mainClass;
        public ModDependency[] dependencies;
        public string[] assemblies;
        public ModScript[] scripts;
        public ModService[] services;
        public ModResourcePaths resources;
        public string[] permissions;
    }
    
    [Serializable]
    public class ModDependency
    {
        public string id;
        public string version;
        public bool optional;
    }
    
    [Serializable]
    public class ModScript
    {
        public string type;
        public bool singleton;
    }
    
    [Serializable]
    public class ModService
    {
        public string interfaceType;
        public string implementationType;
    }
    
    [Serializable]
    public class ModResourcePaths
    {
        public string[] models;
        public string[] objects;
        public string[] configs;
        public string[] textures;
        public string[] audio;
    }
}
```

### 2. SecurityManager 实现

```csharp
// ModSystem.Core/Security/SecurityManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

namespace ModSystem.Core
{
    public class SecurityManager
    {
        private readonly SecurityConfig config;
        private readonly HashSet<string> whitelistedPaths;
        private readonly HashSet<string> blacklistedAPIs;
        
        public SecurityManager(SecurityConfig config)
        {
            this.config = config;
            this.whitelistedPaths = new HashSet<string>();
            this.blacklistedAPIs = InitializeBlacklistedAPIs();
        }
        
        public bool ValidateMod(string modPath)
        {
            try
            {
                // 1. 检查路径安全性
                if (!IsPathSafe(modPath))
                {
                    Debug.LogError("Mod path is not safe");
                    return false;
                }
                
                // 2. 验证数字签名（如果启用）
                if (config.RequireSignedMods)
                {
                    if (!VerifySignature(modPath))
                    {
                        Debug.LogError("Mod signature verification failed");
                        return false;
                    }
                }
                
                // 3. 扫描恶意代码
                if (!ScanForMaliciousCode(modPath))
                {
                    Debug.LogError("Mod contains suspicious code");
                    return false;
                }
                
                // 4. 验证权限
                if (!ValidatePermissions(modPath))
                {
                    Debug.LogError("Mod requests unauthorized permissions");
                    return false;
                }
                
                return true;
            }
            catch (Exception ex)
            {
                Debug.LogError($"Security validation error: {ex.Message}");
                return false;
            }
        }
        
        private bool IsPathSafe(string path)
        {
            var fullPath = Path.GetFullPath(path);
            var modDirectory = Path.GetFullPath(config.ModDirectory);
            
            // 确保路径在模组目录内
            if (!fullPath.StartsWith(modDirectory))
            {
                return false;
            }
            
            // 检查路径遍历攻击
            if (path.Contains("..") || path.Contains("~"))
            {
                return false;
            }
            
            return true;
        }
        
        private bool VerifySignature(string modPath)
        {
            var signaturePath = Path.Combine(modPath, "signature.sig");
            if (!File.Exists(signaturePath))
            {
                return false;
            }
            
            try
            {
                using (var rsa = new RSACryptoServiceProvider())
                {
                    // 加载公钥
                    var publicKey = File.ReadAllText(config.PublicKeyPath);
                    rsa.FromXmlString(publicKey);
                    
                    // 计算文件哈希
                    var manifestPath = Path.Combine(modPath, "manifest.json");
                    var manifestData = File.ReadAllBytes(manifestPath);
                    var hash = SHA256.Create().ComputeHash(manifestData);
                    
                    // 验证签名
                    var signature = File.ReadAllBytes(signaturePath);
                    return rsa.VerifyHash(hash, CryptoConfig.MapNameToOID("SHA256"), signature);
                }
            }
            catch
            {
                return false;
            }
        }
        
        private bool ScanForMaliciousCode(string modPath)
        {
            var dllFiles = Directory.GetFiles(modPath, "*.dll", SearchOption.AllDirectories);
            
            foreach (var dll in dllFiles)
            {
                if (!ScanAssembly(dll))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        private bool ScanAssembly(string assemblyPath)
        {
            try
            {
                var assembly = Assembly.LoadFrom(assemblyPath);
                
                foreach (var type in assembly.GetTypes())
                {
                    foreach (var method in type.GetMethods())
                    {
                        // 检查是否调用了危险API
                        var methodBody = method.GetMethodBody();
                        if (methodBody != null)
                        {
                            // 这里应该实现更复杂的字节码分析
                            // 简化示例：检查方法名
                            if (blacklistedAPIs.Contains(method.Name))
                            {
                                Debug.LogError($"Dangerous API call detected: {method.Name}");
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            catch
            {
                return false;
            }
        }
        
        private bool ValidatePermissions(string modPath)
        {
            var manifestPath = Path.Combine(modPath, "manifest.json");
            if (!File.Exists(manifestPath))
            {
                return false;
            }
            
            try
            {
                var manifestJson = File.ReadAllText(manifestPath);
                var manifest = JsonUtility.FromJson<ModManifest>(manifestJson);
                
                if (manifest.permissions == null)
                {
                    return true;
                }
                
                // 检查每个请求的权限
                foreach (var permission in manifest.permissions)
                {
                    if (!config.AllowedPermissions.Contains(permission))
                    {
                        Debug.LogError($"Unauthorized permission requested: {permission}");
                        return false;
                    }
                }
                
                return true;
            }
            catch
            {
                return false;
            }
        }
        
        private HashSet<string> InitializeBlacklistedAPIs()
        {
            return new HashSet<string>
            {
                "System.IO.File.Delete",
                "System.IO.Directory.Delete",
                "System.Diagnostics.Process.Start",
                "System.Net.WebClient",
                "System.Reflection.Assembly.Load",
                "Microsoft.Win32.Registry"
            };
        }
        
        public SecurityContext CreateContext(string modId, List<string> requestedPermissions)
        {
            var grantedPermissions = new HashSet<string>();
            
            // 只授予配置中允许的权限
            if (config.ModPermissions.TryGetValue(modId, out var allowedPermissions))
            {
                foreach (var permission in requestedPermissions)
                {
                    if (allowedPermissions.Contains(permission))
                    {
                        grantedPermissions.Add(permission);
                    }
                }
            }
            
            return new SecurityContext
            {
                ModId = modId,
                Permissions = grantedPermissions,
                ResourceLimits = config.ModResourceLimits.GetValueOrDefault(modId, 
                    config.ModResourceLimits["default"])
            };
        }
    }
    
    public class SecurityContext
    {
        public string ModId { get; set; }
        public HashSet<string> Permissions { get; set; }
        public ResourceLimits ResourceLimits { get; set; }
        
        public bool HasPermission(string permission)
        {
            return Permissions.Contains(permission);
        }
    }
    
    public class SecurityConfig
    {
        public bool RequireSignedMods { get; set; } = true;
        public string PublicKeyPath { get; set; }
        public string ModDirectory { get; set; } = "Assets/Mods";
        public HashSet<string> AllowedPermissions { get; set; } = new HashSet<string>
        {
            "event_publish",
            "event_subscribe",
            "service_register",
            "object_create",
            "config_read"
        };
        public Dictionary<string, List<string>> ModPermissions { get; set; }
        public Dictionary<string, ResourceLimits> ModResourceLimits { get; set; }
    }
    
    public class ResourceLimits
    {
        public int MaxMemoryMB { get; set; } = 100;
        public int MaxCpuTimeMs { get; set; } = 10;
        public int MaxObjects { get; set; } = 50;
        public int MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
    }
}
```

### 3. 事件监控和调试工具

```csharp
// ModSystem.Core/Debug/EventMonitor.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace ModSystem.Core.Debug
{
    public class EventMonitor : MonoBehaviour, IEventLogger
    {
        [SerializeField] private bool showUI = true;
        [SerializeField] private int maxEventHistory = 100;
        [SerializeField] private Vector2 windowPosition = new Vector2(10, 10);
        [SerializeField] private Vector2 windowSize = new Vector2(500, 400);
        
        private List<EventLogEntry> eventHistory = new List<EventLogEntry>();
        private Vector2 scrollPosition;
        private bool isWindowMinimized = false;
        private Dictionary<string, int> eventCounts = new Dictionary<string, int>();
        private string filterText = "";
        private bool showOnlyErrors = false;
        private HashSet<string> mutedEventTypes = new HashSet<string>();
        
        public class EventLogEntry
        {
            public DateTime Timestamp { get; set; }
            public string EventType { get; set; }
            public string SenderId { get; set; }
            public string Details { get; set; }
            public LogLevel Level { get; set; }
            public Color Color { get; set; }
        }
        
        public enum LogLevel
        {
            Info,
            Warning,
            Error
        }
        
        void Start()
        {
            var eventBus = FindObjectOfType<ModSystemController>()?.EventBus as ModEventBus;
            if (eventBus != null)
            {
                eventBus.OnEventPublished += OnEventPublished;
            }
        }
        
        private void OnEventPublished(IModEvent e)
        {
            if (!mutedEventTypes.Contains(e.GetType().Name))
            {
                LogEvent(e);
            }
        }
        
        public void LogEvent(IModEvent e)
        {
            var entry = new EventLogEntry
            {
                Timestamp = e.Timestamp,
                EventType = e.GetType().Name,
                SenderId = e.SenderId ?? "Unknown",
                Details = SerializeEventDetails(e),
                Level = LogLevel.Info,
                Color = GetEventColor(e)
            };
            
            AddLogEntry(entry);
            
            // 更新事件计数
            if (!eventCounts.ContainsKey(entry.EventType))
                eventCounts[entry.EventType] = 0;
            eventCounts[entry.EventType]++;
        }
        
        public void LogSubscription(string eventType, string subscriber)
        {
            var entry = new EventLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = "Subscription",
                SenderId = subscriber ?? "Unknown",
                Details = $"Subscribed to {eventType}",
                Level = LogLevel.Info,
                Color = Color.cyan
            };
            
            AddLogEntry(entry);
        }
        
        public void LogError(string message)
        {
            var entry = new EventLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = "Error",
                SenderId = "System",
                Details = message,
                Level = LogLevel.Error,
                Color = Color.red
            };
            
            AddLogEntry(entry);
        }
        
        private void AddLogEntry(EventLogEntry entry)
        {
            eventHistory.Add(entry);
            
            // 保持历史记录在限制范围内
            while (eventHistory.Count > maxEventHistory)
            {
                eventHistory.RemoveAt(0);
            }
        }
        
        private string SerializeEventDetails(IModEvent e)
        {
            var properties = e.GetType().GetProperties()
                .Where(p => p.Name != "EventId" && p.Name != "SenderId" && p.Name != "Timestamp")
                .Select(p => 
                {
                    try
                    {
                        var value = p.GetValue(e);
                        return $"{p.Name}: {value ?? "null"}";
                    }
                    catch
                    {
                        return $"{p.Name}: <error>";
                    }
                })
                .ToList();
            
            return string.Join(", ", properties);
        }
        
        private Color GetEventColor(IModEvent e)
        {
            // 根据事件类型返回不同颜色
            if (e is ButtonPressedEvent) return new Color(0.5f, 1f, 0.5f);
            if (e is RobotStateChangedEvent) return new Color(0.5f, 0.5f, 1f);
            if (e is ServiceRegisteredEvent) return Color.yellow;
            if (e is EmergencyStopEvent) return Color.red;
            return Color.white;
        }
        
        void OnGUI()
        {
            if (!showUI) return;
            
            var windowRect = new Rect(windowPosition, windowSize);
            windowRect = GUI.Window(0, windowRect, DrawWindow, "Event Monitor");
            windowPosition = windowRect.position;
        }
        
        void DrawWindow(int windowId)
        {
            GUILayout.BeginVertical();
            
            // 标题栏
            DrawTitleBar();
            
            if (!isWindowMinimized)
            {
                // 工具栏
                DrawToolbar();
                
                // 事件列表
                DrawEventList();
                
                // 统计信息
                DrawStatistics();
            }
            
            GUILayout.EndVertical();
            
            GUI.DragWindow();
        }
        
        void DrawTitleBar()
        {
            GUILayout.BeginHorizontal();
            
            GUILayout.Label($"Events: {eventHistory.Count} | Total: {eventCounts.Values.Sum()}");
            
            GUILayout.FlexibleSpace();
            
            if (GUILayout.Button(isWindowMinimized ? "▼" : "▲", GUILayout.Width(30)))
            {
                isWindowMinimized = !isWindowMinimized;
            }
            
            GUILayout.EndHorizontal();
        }
        
        void DrawToolbar()
        {
            GUILayout.BeginHorizontal();
            
            // 过滤器
            GUILayout.Label("Filter:", GUILayout.Width(50));
            filterText = GUILayout.TextField(filterText, GUILayout.Width(150));
            
            // 只显示错误
            showOnlyErrors = GUILayout.Toggle(showOnlyErrors, "Errors Only");
            
            GUILayout.FlexibleSpace();
            
            // 清除按钮
            if (GUILayout.Button("Clear", GUILayout.Width(60)))
            {
                eventHistory.Clear();
                eventCounts.Clear();
            }
            
            // 导出按钮
            if (GUILayout.Button("Export", GUILayout.Width(60)))
            {
                ExportLogs();
            }
            
            GUILayout.EndHorizontal();
        }
        
        void DrawEventList()
        {
            scrollPosition = GUILayout.BeginScrollView(scrollPosition);
            
            var filteredEvents = FilterEvents();
            
            foreach (var entry in filteredEvents.TakeLast(50).Reverse())
            {
                DrawEventEntry(entry);
            }
            
            GUILayout.EndScrollView();
        }
        
        void DrawEventEntry(EventLogEntry entry)
        {
            var originalColor = GUI.color;
            
            // 设置颜色
            GUI.color = entry.Level == LogLevel.Error ? Color.red :
                       entry.Level == LogLevel.Warning ? Color.yellow :
                       entry.Color;
            
            GUILayout.BeginHorizontal("box");
            
            // 时间戳
            GUILayout.Label(entry.Timestamp.ToString("HH:mm:ss.fff"), GUILayout.Width(80));
            
            // 事件类型
            if (GUILayout.Button(entry.EventType, "Label", GUILayout.Width(120)))
            {
                // 切换静音状态
                if (mutedEventTypes.Contains(entry.EventType))
                    mutedEventTypes.Remove(entry.EventType);
                else
                    mutedEventTypes.Add(entry.EventType);
            }
            
            // 发送者
            GUILayout.Label(entry.SenderId, GUILayout.Width(100));
            
            // 详情
            GUILayout.Label(entry.Details, GUILayout.ExpandWidth(true));
            
            // 复制按钮
            if (GUILayout.Button("📋", GUILayout.Width(25)))
            {
                GUIUtility.systemCopyBuffer = $"{entry.Timestamp}: [{entry.EventType}] {entry.SenderId} - {entry.Details}";
            }
            
            GUILayout.EndHorizontal();
            
            GUI.color = originalColor;
        }
        
        void DrawStatistics()
        {
            if (GUILayout.Button("Show Statistics"))
            {
                ShowStatisticsWindow();
            }
        }
        
        IEnumerable<EventLogEntry> FilterEvents()
        {
            var events = eventHistory.AsEnumerable();
            
            if (showOnlyErrors)
            {
                events = events.Where(e => e.Level == LogLevel.Error);
            }
            
            if (!string.IsNullOrEmpty(filterText))
            {
                events = events.Where(e => 
                    e.EventType.Contains(filterText, StringComparison.OrdinalIgnoreCase) ||
                    e.SenderId.Contains(filterText, StringComparison.OrdinalIgnoreCase) ||
                    e.Details.Contains(filterText, StringComparison.OrdinalIgnoreCase)
                );
            }
            
            return events;
        }
        
        void ShowStatisticsWindow()
        {
            var stats = "=== Event Statistics ===\n\n";
            
            stats += "Top Events:\n";
            foreach (var kvp in eventCounts.OrderByDescending(x => x.Value).Take(10))
            {
                stats += $"  {kvp.Key}: {kvp.Value} times\n";
            }
            
            stats += $"\nMuted Events: {string.Join(", ", mutedEventTypes)}\n";
            
            Debug.Log(stats);
        }
        
        void ExportLogs()
        {
            var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            var filename = $"EventLog_{timestamp}.txt";
            var path = Path.Combine(Application.persistentDataPath, filename);
            
            var logs = string.Join("\n", eventHistory.Select(e => 
                $"{e.Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{e.Level}] [{e.EventType}] {e.SenderId} - {e.Details}"
            ));
            
            File.WriteAllText(path, logs);
            Debug.Log($"Logs exported to: {path}");
        }
    }
}
```

### 4. ModManager 主管理器

```csharp
// ModSystem.Core/Runtime/ModManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;

namespace ModSystem.Core
{
    public class ModManager : MonoBehaviour
    {
        private ModLoader modLoader;
        private IEventBus eventBus;
        private IServiceRegistry serviceRegistry;
        private ModObjectFactory objectFactory;
        private Dictionary<string, ModInstance> modInstances;
        
        public string LastError { get; private set; }
        public List<string> ValidationErrors { get; private set; } = new List<string>();
        
        public void Initialize(IEventBus eventBus, IServiceRegistry serviceRegistry)
        {
            this.eventBus = eventBus;
            this.serviceRegistry = serviceRegistry;
            
            var securityConfig = LoadSecurityConfig();
            var securityManager = new SecurityManager(securityConfig);
            
            modLoader = new ModLoader(GetModsPath(), securityManager);
            objectFactory = new ModObjectFactory(GetModsPath());
            modInstances = new Dictionary<string, ModInstance>();
        }
        
        public async Task<bool> LoadMod(string modPath)
        {
            try
            {
                ValidationErrors.Clear();
                
                // 加载模组
                var loadedMod = await modLoader.LoadModAsync(modPath);
                
                // 创建模组实例
                var instance = await CreateModInstance(loadedMod);
                modInstances[loadedMod.Manifest.id] = instance;
                
                // 发布模组加载事件
                eventBus.Publish(new ModLoadedEvent
                {
                    ModId = loadedMod.Manifest.id,
                    ModName = loadedMod.Manifest.name,
                    Version = loadedMod.Manifest.version
                });
                
                Debug.Log($"Mod loaded: {loadedMod.Manifest.name} v{loadedMod.Manifest.version}");
                return true;
            }
            catch (Exception ex)
            {
                LastError = ex.Message;
                Debug.LogError($"Failed to load mod: {ex}");
                return false;
            }
        }
        
        public async Task<bool> LoadModPackage(string packagePath)
        {
            try
            {
                var loadedMod = await modLoader.LoadModPackageAsync(packagePath);
                var instance = await CreateModInstance(loadedMod);
                modInstances[loadedMod.Manifest.id] = instance;
                
                Debug.Log($"Mod package loaded: {loadedMod.Manifest.name}");
                return true;
            }
            catch (Exception ex)
            {
                LastError = ex.Message;
                Debug.LogError($"Failed to load mod package: {ex}");
                return false;
            }
        }
        
        private async Task<ModInstance> CreateModInstance(LoadedMod loadedMod)
        {
            var instance = new ModInstance
            {
                LoadedMod = loadedMod,
                GameObjects = new List<GameObject>()
            };
            
            // 创建模组容器
            var modContainer = new GameObject($"Mod_{loadedMod.Manifest.id}");
            modContainer.transform.SetParent(transform);
            instance.Container = modContainer;
            
            // 初始化行为
            foreach (var behaviour in loadedMod.Behaviours)
            {
                var behaviourObj = new GameObject($"Behaviour_{behaviour.BehaviourId}");
                behaviourObj.transform.SetParent(modContainer.transform);
                
                var context = CreateModContext(loadedMod, behaviourObj);
                behaviour.OnInitialize(context);
                
                // 添加更新组件
                var updater = behaviourObj.AddComponent<ModBehaviourUpdater>();
                updater.Initialize(behaviour);
                
                instance.GameObjects.Add(behaviourObj);
            }
            
            // 加载对象定义
            foreach (var objDef in loadedMod.Resources.ObjectDefinitions.Values)
            {
                try
                {
                    var obj = await objectFactory.CreateObjectFromDefinitionAsync(objDef);
                    obj.transform.SetParent(modContainer.transform);
                    instance.GameObjects.Add(obj);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Failed to create object {objDef.objectId}: {ex.Message}");
                }
            }
            
            return instance;
        }
        
        private IModContext CreateModContext(LoadedMod loadedMod, GameObject gameObject)
        {
            return new ModContextImpl
            {
                ModId = loadedMod.Manifest.id,
                GameObject = gameObject,
                EventBus = eventBus,
                API = CreateModAPI(loadedMod),
                Services = serviceRegistry
            };
        }
        
        private IModAPI CreateModAPI(LoadedMod loadedMod)
        {
            return new ModAPIImpl
            {
                RequestResponse = new RequestResponseManager(eventBus),
                Audio = new AudioAPIImpl(),
                Utilities = new UtilityAPIImpl(),
                ObjectFactory = objectFactory
            };
        }
        
        public void UnloadMod(string modId)
        {
            if (modInstances.TryGetValue(modId, out var instance))
            {
                // 销毁游戏对象
                foreach (var obj in instance.GameObjects)
                {
                    if (obj != null)
                        Destroy(obj);
                }
                
                if (instance.Container != null)
                    Destroy(instance.Container);
                
                // 卸载模组
                modLoader.UnloadMod(modId);
                modInstances.Remove(modId);
                
                // 发布模组卸载事件
                eventBus.Publish(new ModUnloadedEvent { ModId = modId });
                
                Debug.Log($"Mod unloaded: {modId}");
            }
        }
        
        public void ReloadMods()
        {
            var modIds = modInstances.Keys.ToList();
            foreach (var modId in modIds)
            {
                UnloadMod(modId);
            }
            
            // 重新加载所有模组
            LoadAllMods();
        }
        
        private async void LoadAllMods()
        {
            // 加载内置模组
            var modsPath = GetModsPath();
            if (Directory.Exists(modsPath))
            {
                foreach (var modDir in Directory.GetDirectories(modsPath))
                {
                    await LoadMod(modDir);
                }
            }
            
            // 加载模组包
            var packagesPath = GetModPackagesPath();
            if (Directory.Exists(packagesPath))
            {
                foreach (var packageFile in Directory.GetFiles(packagesPath, "*.modpack"))
                {
                    await LoadModPackage(packageFile);
                }
            }
        }
        
        private string GetModsPath()
        {
            return Path.Combine(Application.streamingAssetsPath, "Mods");
        }
        
        private string GetModPackagesPath()
        {
            return Path.Combine(Application.streamingAssetsPath, "ModPackages");
        }
        
        private SecurityConfig LoadSecurityConfig()
        {
            // 加载安全配置
            return new SecurityConfig
            {
                RequireSignedMods = false, // 开发模式下禁用
                ModDirectory = GetModsPath(),
                ModPermissions = new Dictionary<string, List<string>>
                {
                    { "button_mod", new List<string> { "event_publish", "event_subscribe" } },
                    { "robot_mod", new List<string> { "event_publish", "event_subscribe", "service_register" } }
                },
                ModResourceLimits = new Dictionary<string, ResourceLimits>
                {
                    { "default", new ResourceLimits { MaxMemoryMB = 100, MaxObjects = 50 } }
                }
            };
        }
        
        void OnDestroy()
        {
            // 卸载所有模组
            var modIds = modInstances.Keys.ToList();
            foreach (var modId in modIds)
            {
                UnloadMod(modId);
            }
        }
    }
    
    public class ModInstance
    {
        public LoadedMod LoadedMod { get; set; }
        public GameObject Container { get; set; }
        public List<GameObject> GameObjects { get; set; }
    }
    
    public class ModBehaviourUpdater : MonoBehaviour
    {
        private IModBehaviour behaviour;
        
        public void Initialize(IModBehaviour behaviour)
        {
            this.behaviour = behaviour;
        }
        
        void Update()
        {
            behaviour?.OnUpdate(Time.deltaTime);
        }
        
        void OnDestroy()
        {
            behaviour?.OnDestroy();
        }
    }
    
    public class ModContextImpl : IModContext
    {
        public string ModId { get; set; }
        public GameObject GameObject { get; set; }
        public IEventBus EventBus { get; set; }
        public IModAPI API { get; set; }
        public IServiceRegistry Services { get; set; }
        
        public T GetComponent<T>() where T : Component
        {
            return GameObject.GetComponent<T>();
        }
        
        public void Log(string message)
        {
            Debug.Log($"[{ModId}] {message}");
        }
        
        public void LogError(string message)
        {
            Debug.LogError($"[{ModId}] {message}");
        }
    }
    
    public class ModAPIImpl : IModAPI
    {
        public IRequestResponseManager RequestResponse { get; set; }
        public IAudioAPI Audio { get; set; }
        public IUtilityAPI Utilities { get; set; }
        public IObjectFactory ObjectFactory { get; set; }
    }
    
    public class AudioAPIImpl : IAudioAPI
    {
        public void PlaySound(string soundId)
        {
            Debug.Log($"Playing sound: {soundId}");
            // 实际音频播放实现
        }
        
        public void StopSound(string soundId)
        {
            Debug.Log($"Stopping sound: {soundId}");
        }
    }
    
    public class UtilityAPIImpl : IUtilityAPI
    {
        public void DelayCall(float delay, Action callback)
        {
            // 使用协程实现延迟调用
        }
        
        public Coroutine StartCoroutine(IEnumerator coroutine)
        {
            // 实现协程启动
            return null;
        }
        
        public void StopCoroutine(Coroutine coroutine)
        {
            // 实现协程停止
        }
        
        public string LoadConfigFile(string filename)
        {
            // 实现配置文件加载
            return "";
        }
    }
    
    public class ModLoadedEvent : IModEvent
    {
        public string EventId => "mod_loaded";
        public string SenderId { get; set; } = "ModManager";
        public DateTime Timestamp { get; set; }
        public string ModId { get; set; }
        public string ModName { get; set; }
        public string Version { get; set; }
    }
    
    public class ModUnloadedEvent : IModEvent
    {
        public string EventId => "mod_unloaded";
        public string SenderId { get; set; } = "ModManager";
        public DateTime Timestamp { get; set; }
        public string ModId { get; set; }
    }
}
```

## 调试和故障排除

### 常见问题

#### 1. 模组加载失败

```csharp
// 检查日志
if (!modManager.LoadMod(modPath))
{
    Debug.LogError($"Failed to load mod: {modManager.LastError}");
    
    // 查看详细错误信息
    foreach (var error in modManager.ValidationErrors)
    {
        Debug.LogError(error);
    }
}
```

**解决方案**：
- 检查manifest.json格式是否正确
- 确认DLL文件存在且路径正确
- 验证依赖项是否满足
- 检查安全权限设置

#### 2. 事件未收到

```csharp
// 添加事件监控
eventBus.OnEventPublished += (e) => 
{
    Debug.Log($"Event published: {e.GetType().Name} from {e.SenderId}");
};
```

**解决方案**：
- 确认订阅代码在发布之前执行
- 检查事件类型是否匹配
- 验证过滤条件是否正确
- 使用EventMonitor查看所有事件

#### 3. 服务调用超时

```csharp
// 增加超时时间
var response = await requestManager.SendRequestAsync<Request, Response>(
    request, 
    TimeSpan.FromSeconds(30) // 增加到30秒
);
```

**解决方案**：
- 检查目标服务是否已注册
- 验证网络连接（如果涉及）
- 增加超时时间
- 实现重试机制

#### 4. 内存泄漏

```csharp
// 正确清理资源
public void OnDestroy()
{
    // 取消订阅所有事件
    eventBus.Unsubscribe<MyEvent>(myHandler);
    
    // 清理创建的对象
    foreach (var obj in createdObjects)
    {
        if (obj != null)
            GameObject.Destroy(obj);
    }
    
    // 释放其他资源
    DisposableResource?.Dispose();
}
```

### 性能优化建议

#### 1. 事件批处理

```csharp
public class BatchEventProcessor
{
    private readonly Queue<IModEvent> eventQueue = new Queue<IModEvent>();
    private readonly int batchSize = 10;
    private float lastProcessTime;
    private const float ProcessInterval = 0.1f; // 100ms
    
    public void QueueEvent(IModEvent e)
    {
        lock (eventQueue)
        {
            eventQueue.Enqueue(e);
        }
    }
    
    public void ProcessEvents()
    {
        if (Time.time - lastProcessTime < ProcessInterval)
            return;
        
        var batch = new List<IModEvent>();
        
        lock (eventQueue)
        {
            while (eventQueue.Count > 0 && batch.Count < batchSize)
            {
                batch.Add(eventQueue.Dequeue());
            }
        }
        
        if (batch.Count > 0)
        {
            ProcessBatch(batch);
            lastProcessTime = Time.time;
        }
    }
    
    private void ProcessBatch(List<IModEvent> batch)
    {
        // 批量处理事件
        foreach (var e in batch)
        {
            HandleEvent(e);
        }
    }
}
```

#### 2. 对象池

```csharp
public class ModObjectPool<T> where T : Component
{
    private readonly Queue<T> pool = new Queue<T>();
    private readonly Func<T> createFunc;
    private readonly Action<T> resetFunc;
    private readonly int maxSize;
    
    public ModObjectPool(Func<T> createFunc, Action<T> resetFunc, int maxSize = 50)
    {
        this.createFunc = createFunc;
        this.resetFunc = resetFunc;
        this.maxSize = maxSize;
    }
    
    public T Get()
    {
        if (pool.Count > 0)
        {
            var obj = pool.Dequeue();
            obj.gameObject.SetActive(true);
            return obj;
        }
        
        return createFunc();
    }
    
    public void Return(T obj)
    {
        if (pool.Count < maxSize)
        {
            resetFunc(obj);
            obj.gameObject.SetActive(false);
            pool.Enqueue(obj);
        }
        else
        {
            GameObject.Destroy(obj.gameObject);
        }
    }
}
```

#### 3. 异步加载优化

```csharp
public class AsyncModLoader
{
    private readonly SemaphoreSlim loadingSemaphore;
    
    public AsyncModLoader(int maxConcurrentLoads = 3)
    {
        loadingSemaphore = new SemaphoreSlim(maxConcurrentLoads);
    }
    
    public async Task<List<LoadedMod>> LoadModsAsync(string[] modPaths)
    {
        var tasks = modPaths.Select(path => LoadModWithThrottleAsync(path));
        var results = await Task.WhenAll(tasks);
        return results.Where(r => r != null).ToList();
    }
    
    private async Task<LoadedMod> LoadModWithThrottleAsync(string modPath)
    {
        await loadingSemaphore.WaitAsync();
        try
        {
            return await LoadModAsync(modPath);
        }
        finally
        {
            loadingSemaphore.Release();
        }
    }
}
```

### 调试工具使用

#### 1. 实时事件查看器

- 按 F12 打开/关闭事件监控器
- 使用过滤器查找特定事件
- 点击事件类型可以静音/取消静音
- 导出日志用于分析

#### 2. 性能分析器

```csharp
public class ModPerformanceProfiler
{
    private Dictionary<string, ProfileData> profileData = new Dictionary<string, ProfileData>();
    
    public void BeginSample(string name)
    {
        if (!profileData.ContainsKey(name))
        {
            profileData[name] = new ProfileData { Name = name };
        }
        
        profileData[name].StartTime = Time.realtimeSinceStartup;
    }
    
    public void EndSample(string name)
    {
        if (profileData.TryGetValue(name, out var data))
        {
            var elapsed = Time.realtimeSinceStartup - data.StartTime;
            data.TotalTime += elapsed;
            data.CallCount++;
            data.AverageTime = data.TotalTime / data.CallCount;
        }
    }
    
    public void LogReport()
    {
        Debug.Log("=== Performance Report ===");
        foreach (var data in profileData.Values.OrderByDescending(d => d.TotalTime))
        {
            Debug.Log($"{data.Name}: Total={data.TotalTime:F3}s, Avg={data.AverageTime:F3}s, Count={data.CallCount}");
        }
    }
}
```

## 常见问题解答

**Q: 需要安装.NET SDK吗？**
A: 是的，需要安装.NET SDK 6.0或更高版本来编译模组。

**Q: 可以使用其他编程语言吗？**
A: 目前只支持C#，但理论上任何能编译到.NET的语言都可以使用。

**Q: 什么是对象定义文件？**
A: 对象定义（.json文件）替代了Unity的Prefab系统，用于描述游戏对象的结构、组件和属性。

**Q: 如何创建3D模型？**
A: 可以使用任何3D建模软件（如Blender、3ds Max等）创建模型，然后导出为glTF格式。

**Q: 模组之间会冲突吗？**
A: 模组系统有命名空间隔离和依赖管理，正常情况下不会冲突。

**Q: 如何调试模组？**
A: 可以使用Visual Studio的附加调试功能，或使用内置的日志系统和EventMonitor。

**Q: 模组的性能影响如何？**
A: 每个模组都有资源限制，系统会监控和限制模组的资源使用。

**Q: 对象定义支持哪些组件？**
A: 支持Transform、MeshRenderer、各种Collider、RigidBody、Light、Camera、AudioSource等常用组件。

## 总结

这个完整的模组通信系统提供了：

1. **多种通信模式**：满足不同场景需求
2. **类型安全**：通过接口和泛型保证类型安全
3. **灵活配置**：支持配置驱动的通信路由
4. **独立开发**：无需Unity编辑器即可开发模组
5. **对象定义系统**：使用JSON替代Unity的Prefab
6. **完整工具链**：从开发到打包的全流程支持
7. **安全机制**：防止恶意代码执行
8. **调试工具**：实时监控和性能分析
9. **资源管理**：自动加载和清理资源
10. **错误处理**：完善的异常处理机制

通过这个系统，开发者可以：
- 在不安装Unity的情况下开发模组
- 使用多种通信方式实现模组间交互
- 通过配置文件灵活定义系统行为
- 使用JSON定义复杂的游戏对象
- 确保系统的安全性和稳定性
- 方便地调试和监控系统运行
- 优化性能并防止资源泄漏

系统的设计充分考虑了扩展性、安全性和易用性，既适合专业开发者，也为非程序员提供了可视化工具，真正实现了模组化开发的民主化。