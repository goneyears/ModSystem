# Unity模组系统代码文档改进清单

## 概述

本文档总结了代码审查中发现的架构设计问题和改进建议，用于指导项目知识库的更新。

## 1. 架构层次问题

### 1.1 Core层Unity依赖问题

**问题描述**：
- `ModLoader.cs` 和 `ModManager.cs` 在Core层中使用了 `UnityEngine`
- 违反了Core层应该是平台无关的设计原则
- 导致ModSDK无法真正独立于Unity

**改进方案**：

#### Core层使用抽象接口
```csharp
// ModSystem.Core/Interfaces/ILogger.cs
namespace ModSystem.Core
{
    public interface ILogger
    {
        void Log(string message);
        void LogWarning(string message);
        void LogError(string message);
    }
}

// ModSystem.Core/Interfaces/IPathProvider.cs
namespace ModSystem.Core
{
    public interface IPathProvider
    {
        string GetModsPath();
        string GetConfigPath();
        string GetTempPath();
    }
}
```

#### ModLoader改进
```csharp
// ModSystem.Core/Runtime/ModLoader.cs
// 移除: using UnityEngine;
namespace ModSystem.Core
{
    public class ModLoader
    {
        private readonly ILogger logger;
        private readonly IPathProvider pathProvider;
        
        public ModLoader(ILogger logger, IPathProvider pathProvider, SecurityManager securityManager = null)
        {
            this.logger = logger;
            this.pathProvider = pathProvider;
            // ...
        }
    }
}
```

#### Unity层提供实现
```csharp
// ModSystem.Unity/UnityLogger.cs
using UnityEngine;
using ModSystem.Core;

namespace ModSystem.Unity
{
    public class UnityLogger : ILogger
    {
        public void Log(string message) => Debug.Log(message);
        public void LogWarning(string message) => Debug.LogWarning(message);
        public void LogError(string message) => Debug.LogError(message);
    }
}
```

### 1.2 ModSystemController位置问题

**问题描述**：
- `ModSystemController.cs` 在项目结构中没有明确标注位置
- 作为Unity特定的集成代码，不应该在Core中

**改进方案**：
```
UnityProject/
├── Assets/
│   ├── ModSystem/
│   │   ├── Core/               # 平台无关代码
│   │   │   └── Assemblies/     # Core DLL放置位置
│   │   │
│   │   └── Unity/              # Unity特定代码
│   │       ├── ModSystemController.cs    ← 正确位置
│   │       ├── ModManager.cs             # MonoBehaviour包装器
│   │       ├── UnityLogger.cs            # Unity实现
│   │       └── Editor/
│   │           └── ModSystemEditor.cs
```

## 2. 模组初始化重复问题

### 2.1 behaviour.OnInitialize重复调用

**问题描述**：
- ObjectFactory中的 `ConfigureModBehaviour` 会调用 `OnInitialize`
- ModManager中的 `CreateModInstance` 也会调用 `OnInitialize`
- 导致同一个行为可能被初始化两次

**改进方案**：

#### 方案A：ObjectFactory不负责初始化
```csharp
// ModSystem.Core/Runtime/ObjectFactory.cs
private void ConfigureModBehaviour(GameObject obj, ComponentDefinition compDef)
{
    var behaviourClass = compDef.GetProperty<string>("behaviourClass");
    
    // 只创建包装器，不初始化行为
    var wrapper = obj.AddComponent<ModBehaviourWrapper>();
    wrapper.BehaviourClass = behaviourClass;
    wrapper.Config = compDef.GetProperty<Dictionary<string, object>>("config");
    wrapper.AutoInitialize = false;  // 标记不自动初始化
}
```

#### 方案B：区分不同类型的行为
```csharp
// 主模组行为（由ModManager管理）
public interface IModBehaviour
{
    void OnInitialize(IModContext context);
}

// 对象附加行为（由ObjectFactory管理）
public interface IObjectBehaviour
{
    void OnAttach(GameObject gameObject);
    void OnConfigure(Dictionary<string, object> config);
}
```

## 3. ModBuilder模板系统改进

### 3.1 硬编码问题

**问题描述**：
- ModBuilder中硬编码了ButtonMod、RobotMod等特定模组类型
- 添加新模组类型需要修改ModBuilder代码
- 违反开闭原则

**改进方案**：

#### 基于模板的系统
```
ModSDK/
├── Templates/
│   ├── ButtonMod/
│   │   ├── template.json              # 模板元数据
│   │   ├── Source/
│   │   │   └── {{ModName}}Behaviour.cs.template
│   │   └── manifest.json.template
│   │
│   └── UserTemplates/                 # 用户自定义模板
```

#### 模板元数据
```json
{
  "id": "button_mod_template",
  "name": "按钮模组模板",
  "variables": [
    {
      "name": "ModId",
      "type": "string",
      "required": true
    }
  ],
  "files": [
    {
      "template": "Source/{{ModName}}Behaviour.cs.template",
      "output": "Source/{{PascalCase ModName}}Behaviour.cs"
    }
  ]
}
```

#### 动态模板加载
```csharp
public class ModBuilder
{
    public List<ModTemplate> GetAvailableTemplates()
    {
        var templates = new List<ModTemplate>();
        
        foreach (var templateDir in Directory.GetDirectories(templatesPath))
        {
            var templateFile = Path.Combine(templateDir, "template.json");
            if (File.Exists(templateFile))
            {
                var template = JsonSerializer.Deserialize<ModTemplate>(
                    File.ReadAllText(templateFile)
                );
                templates.Add(template);
            }
        }
        
        return templates;
    }
}
```

## 4. 文档结构改进

### 4.1 章节顺序问题

**问题描述**：
- ModLoader和ModManager作为核心组件却放在"支持系统实现"章节
- 读者需要先理解这些组件才能理解系统运作
- "支持系统"命名误导

**改进方案**：

```
建议的文档结构：
1. 系统概述
2. 项目结构
3. 核心组件
   3.1 基础接口定义
   3.2 运行时核心组件
       - ModSystemController（Unity集成控制器）
       - ModManager（模组管理器）
       - ModLoader（模组加载器）
       - ObjectFactory（对象工厂）
   3.3 通信系统
       - EventBus（事件总线）
       - RequestResponse（请求响应）
       - ServiceRegistry（服务注册）
   3.4 安全系统
       - SecurityManager
4. 通信模式详解
5. 模组开发
6. 配置系统
7. 部署和安装
8. 调试和优化
```

## 5. 开发环境说明补充

### 5.1 文件归属不清晰

**问题描述**：
- 文档中没有明确说明哪些文件在Unity中开发，哪些在VS中独立开发
- 容易造成开发者困惑

**改进方案**：

添加开发环境分类说明：

#### Unity编辑器中开发（🔵）
- 继承MonoBehaviour的类
- 使用Unity特定API的代码
- Unity Editor扩展
- 场景文件

#### Visual Studio独立开发（🟢）
- Core系统（编译成DLL）
- 模组代码（使用ModSDK）
- 不依赖Unity的纯C#代码

#### 文本编辑器（🟡）
- JSON配置文件
- 对象定义文件
- 模组清单文件

## 6. 全局管理器说明

### 6.1 概念不清晰

**问题描述**：
- ModContext构造函数中注释"其他属性应该从全局管理器获取"不明确
- 没有解释什么是全局管理器

**改进方案**：

添加明确说明：
- **全局管理器**指ModSystemController和ModManager的组合
- 负责管理共享资源：EventBus、ServiceRegistry、SecurityManager等
- 所有模组通过Context访问这些共享资源

## 7. 代码示例改进

### 7.1 ModManager分离

**改进前**：
```csharp
// ModSystem.Core/Runtime/ModManager.cs
public class ModManager : MonoBehaviour  // ❌ Core中不应该有MonoBehaviour
```

**改进后**：
```csharp
// ModSystem.Core/Runtime/ModManagerCore.cs
public class ModManagerCore  // ✅ 纯C#类
{
    // 核心逻辑
}

// ModSystem.Unity/ModManager.cs
public class ModManager : MonoBehaviour  // ✅ Unity包装器
{
    private ModManagerCore core;
    // Unity特定功能
}
```

## 8. 项目结构完善

### 8.1 完整的项目结构

```
工作区/
├── ModSystemCore/              # VS独立项目
│   ├── ModSystem.Core.sln
│   ├── Interfaces/
│   ├── Runtime/
│   └── bin/Release/
│       └── ModSystem.Core.dll  → 复制到Unity
│
├── ModSDK/                     # 独立开发SDK
│   ├── SDK/
│   ├── Tools/
│   └── Templates/
│
├── MyMods/                     # 模组开发项目
│   ├── ButtonMod/
│   └── RobotMod/
│
└── UnityGameProject/           # Unity项目
    └── Assets/
        └── ModSystem/
            ├── Core/Assemblies/ # Core DLL位置
            └── Unity/           # Unity特定代码
```

## 9. 安全性和权限

### 9.1 SecurityManager位置

- 应该在Core中（平台无关的安全逻辑）
- Unity特定的安全实现放在Unity层

## 10. 总结

主要改进点：
1. **严格分离Core和Unity代码**
2. **使用依赖注入解决平台依赖**
3. **避免重复初始化**
4. **使用模板系统替代硬编码**
5. **重组文档结构**
6. **明确文件开发环境**
7. **完善项目结构说明**

这些改进将使系统：
- 真正实现平台无关的Core
- 支持独立模组开发
- 架构更清晰
- 文档更易理解
- 扩展性更强