# Unity模组通信系统 - 完整实现与文档

## 目录
1. [系统概述](#系统概述)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [通信模式](#通信模式)
5. [完整代码实现](#完整代码实现)
6. [使用示例](#使用示例)
7. [配置说明](#配置说明)
8. [独立模组开发（无需Unity）](#独立模组开发)
9. [最佳实践](#最佳实践)
10. [安装和部署](#安装和部署)

## 系统概述

本通信系统提供了多种模组间通信方式，以满足不同场景的需求：

- **事件系统**：适用于简单的单向通知
- **请求-响应模式**：适用于需要返回结果的操作
- **服务注册模式**：适用于模组间的紧密协作
- **配置驱动**：通过配置文件定义通信关系

## 项目结构

本系统分为两个主要部分：
1. **Unity主项目** - 包含模组系统核心和运行时
2. **独立开发SDK** - 用于无Unity编辑器的模组开发

### 完整的项目目录结构

```
UnityProject/                              # Unity主项目
├── Assets/
│   ├── ModSystem/                          # 模组系统核心
│   │   ├── Core/                          # 核心框架（所有模组共享）
│   │   │   ├── Interfaces/                # 接口定义
│   │   │   │   ├── IModEvent.cs
│   │   │   │   ├── IModBehaviour.cs
│   │   │   │   ├── IModContext.cs
│   │   │   │   ├── IEventBus.cs
│   │   │   │   ├── IModService.cs
│   │   │   │   └── IServiceRegistry.cs
│   │   │   │
│   │   │   ├── EventSystem/               # 事件系统实现
│   │   │   │   ├── ModEventBus.cs
│   │   │   │   ├── EventLogger.cs
│   │   │   │   └── EventMonitor.cs
│   │   │   │
│   │   │   ├── Communication/             # 通信系统
│   │   │   │   ├── RequestResponse.cs
│   │   │   │   ├── RequestResponseManager.cs
│   │   │   │   ├── CommunicationRouter.cs
│   │   │   │   └── CommunicationConfig.cs
│   │   │   │
│   │   │   ├── Services/                  # 服务系统
│   │   │   │   ├── ModServiceRegistry.cs
│   │   │   │   └── ServiceEvents.cs
│   │   │   │
│   │   │   ├── Runtime/                   # 运行时组件
│   │   │   │   ├── ModManager.cs
│   │   │   │   ├── ModLoader.cs
│   │   │   │   ├── ModContext.cs
│   │   │   │   ├── ModAPI.cs
│   │   │   │   └── ObjectFactory.cs      # 对象工厂（替代prefab）
│   │   │   │
│   │   │   └── ModSystem.Core.asmdef      # 程序集定义文件
│   │   │
│   │   └── Examples/                      # 示例项目
│   │       ├── ButtonMod/
│   │       ├── RobotMod/
│   │       └── SensorMod/
│   │
│   ├── StreamingAssets/                   # 运行时加载的资源
│   │   ├── ModConfigs/                    # 模组配置文件
│   │   │   └── communication_config.json  # 通信配置
│   │   │
│   │   ├── Mods/                          # 开发中的模组（可选）
│   │   │   ├── ButtonMod/
│   │   │   └── RobotMod/
│   │   │
│   │   └── ModPackages/                   # 打包的模组文件
│   │       ├── button_mod_v1.0.modpack
│   │       └── robot_mod_v2.0.modpack
│   │
│   └── Scenes/
│       ├── ModSystemDemo.unity            # 演示场景
│       └── ModTestEnvironment.unity       # 测试环境
│
├── Packages/                              # Unity包管理器
│   └── manifest.json                      # 包依赖配置
│
└── ProjectSettings/                       # Unity项目设置

ModSDK/                                    # 独立开发SDK（不在Unity项目中）
├── SDK/
│   ├── ModSDK.Core.dll                   # 核心接口库
│   ├── ModSDK.Runtime.dll                # 运行时支持库
│   ├── UnityEngine.CoreModule.dll        # Unity运行时（精简版）
│   └── Newtonsoft.Json.dll               # JSON支持
│
├── Tools/
│   ├── ModBuilder.exe                    # 命令行构建工具
│   ├── ModEditor.exe                     # 可视化编辑器
│   └── ModPackager.exe                   # 打包工具
│
├── Templates/                             # 项目模板
│   ├── ButtonMod/
│   ├── RobotMod/
│   └── EmptyMod/
│
└── Documentation/                         # SDK文档

用户模组项目/                              # 用户创建的模组（独立目录）
├── Source/                                # C#源代码
├── Objects/                               # 对象定义（JSON）
├── Models/                                # 3D模型（glTF）
├── Config/                                # 配置文件
├── Resources/                             # 其他资源
├── SDK/                                   # SDK副本
├── [ModName].csproj                      # 项目文件
└── manifest.json                          # 模组清单
```

### 文件组织说明

#### 1. 核心系统文件（ModSystem/Core/）

这是所有模组共享的核心框架，应该编译成独立的DLL供模组引用。

#### 2. 模组文件（Mods/）

每个模组都是独立的文件夹，包含自己的代码、资源和配置：

**按钮模组（ButtonMod/）**
```
ButtonMod/
├── Scripts/
│   ├── ButtonBehaviour.cs        # 主行为脚本
│   ├── ButtonConfiguration.cs    # 配置数据结构
│   └── ButtonEvents.cs          # 按钮相关事件定义
├── Objects/                     # 对象定义（替代prefab）
│   ├── interactive_button.json
│   └── toggle_button.json
├── Models/                      # 3D模型文件
│   └── button.gltf
├── Config/                      # 配置文件
│   └── config.json
├── Resources/                   # 其他资源
│   ├── Textures/
│   └── Audio/
├── ButtonMod.asmdef            # 程序集定义
└── manifest.json               # 模组清单
```

## 核心组件

### 1. 基础接口定义

```csharp
// ModSystem.Core/Interfaces/IModEvent.cs
namespace ModSystem.Core
{
    /// <summary>
    /// 模组事件基础接口
    /// </summary>
    public interface IModEvent
    {
        string EventId { get; }
        string SenderId { get; set; }
        DateTime Timestamp { get; set; }
    }
    
    /// <summary>
    /// 事件总线接口
    /// </summary>
    public interface IEventBus
    {
        void Subscribe<T>(Action<T> handler) where T : IModEvent;
        void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent;
        void Publish<T>(T eventData) where T : IModEvent;
        void Unsubscribe<T>(Action<T> handler) where T : IModEvent;
    }
    
    /// <summary>
    /// 模组行为接口
    /// </summary>
    public interface IModBehaviour
    {
        string BehaviourId { get; }
        string Version { get; }
        void OnInitialize(IModContext context);
        void OnUpdate(float deltaTime);
        void OnDestroy();
    }
    
    /// <summary>
    /// 模组上下文接口
    /// </summary>
    public interface IModContext
    {
        string ModId { get; }
        GameObject GameObject { get; }
        IEventBus EventBus { get; }
        IModAPI API { get; }
        IServiceRegistry Services { get; }
        T GetComponent<T>() where T : Component;
        void Log(string message);
        void LogError(string message);
    }
}
```

### 2. 事件总线实现

```csharp
// ModSystem.Core/EventSystem/ModEventBus.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace ModSystem.Core
{
    public interface IEventLogger
    {
        void LogEvent(IModEvent e);
        void LogSubscription(string eventType, string subscriber);
        void LogError(string message);
    }
    
    public class ModEventBus : IEventBus
    {
        private readonly Dictionary<Type, List<EventHandler>> handlers;
        private readonly object lockObject = new object();
        private readonly IEventLogger logger;
        
        public event Action<IModEvent> OnEventPublished;
        
        private class EventHandler
        {
            public Delegate Handler { get; set; }
            public Predicate<IModEvent> Filter { get; set; }
            public string SubscriberId { get; set; }
        }
        
        public ModEventBus(IEventLogger logger = null)
        {
            handlers = new Dictionary<Type, List<EventHandler>>();
            this.logger = logger;
        }
        
        public void Subscribe<T>(Action<T> handler) where T : IModEvent
        {
            Subscribe(handler, null);
        }
        
        public void Subscribe<T>(Action<T> handler, Predicate<T> filter) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                {
                    handlers[eventType] = new List<EventHandler>();
                }
                
                handlers[eventType].Add(new EventHandler
                {
                    Handler = handler,
                    Filter = filter != null ? e => filter((T)e) : null,
                    SubscriberId = handler.Target?.GetType().Name ?? "Anonymous"
                });
                
                logger?.LogSubscription(eventType.Name, handler.Target?.GetType().Name);
            }
        }
        
        public void Publish<T>(T eventData) where T : IModEvent
        {
            if (eventData == null) return;
            
            eventData.Timestamp = DateTime.Now;
            logger?.LogEvent(eventData);
            OnEventPublished?.Invoke(eventData);
            
            List<EventHandler> eventHandlers;
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                eventHandlers = handlers[eventType].ToList();
            }
            
            foreach (var handler in eventHandlers)
            {
                try
                {
                    if (handler.Filter != null && !handler.Filter(eventData))
                        continue;
                    
                    ((Action<T>)handler.Handler)?.Invoke(eventData);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Error in event handler: {ex.Message}");
                    logger?.LogError($"Handler error for {typeof(T).Name}: {ex.Message}");
                }
            }
        }
        
        public void Unsubscribe<T>(Action<T> handler) where T : IModEvent
        {
            lock (lockObject)
            {
                var eventType = typeof(T);
                if (!handlers.ContainsKey(eventType))
                    return;
                
                handlers[eventType].RemoveAll(h => h.Handler.Equals(handler));
                
                if (handlers[eventType].Count == 0)
                    handlers.Remove(eventType);
            }
        }
    }
}
```

### 3. 请求-响应模式实现

```csharp
// ModSystem.Core/Communication/RequestResponse.cs
namespace ModSystem.Core
{
    public abstract class ModRequest : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; } = Guid.NewGuid().ToString();
    }
    
    public abstract class ModResponse : IModEvent
    {
        public string EventId => GetType().Name;
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string RequestId { get; set; }
        public bool Success { get; set; }
        public string Message { get; set; }
        public object Result { get; set; }
    }
    
    public class RequestResponseManager
    {
        private readonly IEventBus eventBus;
        private readonly Dictionary<string, PendingRequest> pendingRequests;
        
        private class PendingRequest
        {
            public TaskCompletionSource<ModResponse> CompletionSource { get; set; }
            public Type ResponseType { get; set; }
            public DateTime CreatedAt { get; set; }
        }
        
        public RequestResponseManager(IEventBus eventBus)
        {
            this.eventBus = eventBus;
            this.pendingRequests = new Dictionary<string, PendingRequest>();
            CleanupTimeoutRequests();
        }
        
        public async Task<TResponse> SendRequestAsync<TRequest, TResponse>(
            TRequest request, 
            TimeSpan? timeout = null) 
            where TRequest : ModRequest 
            where TResponse : ModResponse
        {
            var actualTimeout = timeout ?? TimeSpan.FromSeconds(30);
            var tcs = new TaskCompletionSource<ModResponse>();
            
            pendingRequests[request.RequestId] = new PendingRequest
            {
                CompletionSource = tcs,
                ResponseType = typeof(TResponse),
                CreatedAt = DateTime.Now
            };
            
            Action<TResponse> responseHandler = null;
            responseHandler = (response) =>
            {
                if (response.RequestId == request.RequestId)
                {
                    if (pendingRequests.TryGetValue(request.RequestId, out var pending))
                    {
                        pending.CompletionSource.TrySetResult(response);
                        pendingRequests.Remove(request.RequestId);
                    }
                    eventBus.Unsubscribe(responseHandler);
                }
            };
            
            eventBus.Subscribe(responseHandler);
            eventBus.Publish(request);
            
            using (var cts = new CancellationTokenSource(actualTimeout))
            {
                try
                {
                    var completedTask = await Task.WhenAny(
                        tcs.Task,
                        Task.Delay(actualTimeout, cts.Token)
                    );
                    
                    if (completedTask == tcs.Task)
                    {
                        return (TResponse)await tcs.Task;
                    }
                    else
                    {
                        eventBus.Unsubscribe(responseHandler);
                        pendingRequests.Remove(request.RequestId);
                        throw new TimeoutException($"Request {request.RequestId} timed out");
                    }
                }
                catch (TaskCanceledException)
                {
                    throw new TimeoutException($"Request {request.RequestId} was cancelled");
                }
            }
        }
        
        private async void CleanupTimeoutRequests()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(1));
                
                var now = DateTime.Now;
                var timeoutRequests = pendingRequests
                    .Where(kvp => (now - kvp.Value.CreatedAt) > TimeSpan.FromMinutes(5))
                    .Select(kvp => kvp.Key)
                    .ToList();
                
                foreach (var requestId in timeoutRequests)
                {
                    if (pendingRequests.TryGetValue(requestId, out var pending))
                    {
                        pending.CompletionSource.TrySetException(
                            new TimeoutException("Request timed out during cleanup")
                        );
                        pendingRequests.Remove(requestId);
                    }
                }
            }
        }
    }
}
```

### 4. 服务注册系统

```csharp
// ModSystem.Core/Services/ServiceRegistry.cs
namespace ModSystem.Core
{
    public interface IModService
    {
        string ServiceId { get; }
        string ProviderId { get; }
        string Version { get; }
    }
    
    public interface IServiceRegistry
    {
        void RegisterService<T>(T service) where T : class, IModService;
        T GetService<T>() where T : class, IModService;
        IEnumerable<T> GetServices<T>() where T : class, IModService;
        bool UnregisterService<T>(string serviceId) where T : class, IModService;
    }
    
    public class ModServiceRegistry : IServiceRegistry
    {
        private readonly Dictionary<Type, Dictionary<string, IModService>> services;
        private readonly IEventBus eventBus;
        
        public ModServiceRegistry(IEventBus eventBus)
        {
            this.services = new Dictionary<Type, Dictionary<string, IModService>>();
            this.eventBus = eventBus;
        }
        
        public void RegisterService<T>(T service) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (!services.ContainsKey(serviceType))
            {
                services[serviceType] = new Dictionary<string, IModService>();
            }
            
            services[serviceType][service.ServiceId] = service;
            
            eventBus?.Publish(new ServiceRegisteredEvent
            {
                ServiceType = serviceType.Name,
                ServiceId = service.ServiceId,
                ProviderId = service.ProviderId,
                Version = service.Version
            });
            
            Debug.Log($"Service registered: {serviceType.Name} - {service.ServiceId}");
        }
        
        public T GetService<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (services.ContainsKey(serviceType) && services[serviceType].Count > 0)
            {
                return services[serviceType].Values.First() as T;
            }
            
            return null;
        }
        
        public IEnumerable<T> GetServices<T>() where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (services.ContainsKey(serviceType))
            {
                return services[serviceType].Values.Cast<T>();
            }
            
            return Enumerable.Empty<T>();
        }
        
        public bool UnregisterService<T>(string serviceId) where T : class, IModService
        {
            var serviceType = typeof(T);
            
            if (services.ContainsKey(serviceType) && 
                services[serviceType].ContainsKey(serviceId))
            {
                var service = services[serviceType][serviceId];
                services[serviceType].Remove(serviceId);
                
                eventBus?.Publish(new ServiceUnregisteredEvent
                {
                    ServiceType = serviceType.Name,
                    ServiceId = serviceId,
                    ProviderId = service.ProviderId
                });
                
                return true;
            }
            
            return false;
        }
    }
    
    public class ServiceRegisteredEvent : IModEvent
    {
        public string EventId => "service_registered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
        public string Version { get; set; }
    }
    
    public class ServiceUnregisteredEvent : IModEvent
    {
        public string EventId => "service_unregistered";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string ServiceType { get; set; }
        public string ServiceId { get; set; }
        public string ProviderId { get; set; }
    }
}
```

## 通信模式

### 1. 事件模式（Event Pattern）

适用场景：
- 单向通知
- 广播消息
- 状态变化通知

```csharp
// 发布者
eventBus.Publish(new ButtonPressedEvent { ButtonId = "btn_1" });

// 订阅者
eventBus.Subscribe<ButtonPressedEvent>(e => {
    Debug.Log($"Button {e.ButtonId} was pressed");
});
```

### 2. 请求-响应模式（Request-Response Pattern）

适用场景：
- 需要返回结果的操作
- 需要确认的命令
- 查询操作

```csharp
// 发送请求并等待响应
var response = await requestManager.SendRequestAsync<MoveRobotRequest, MoveRobotResponse>(
    new MoveRobotRequest { TargetPosition = new Vector3(1, 2, 3) },
    TimeSpan.FromSeconds(5)
);

if (response.Success) {
    Debug.Log("Robot moved successfully");
}
```

### 3. 服务模式（Service Pattern）

适用场景：
- 模组间紧密协作
- 需要调用具体功能
- API式的交互

```csharp
// 注册服务
services.RegisterService<IRobotService>(new RobotService());

// 使用服务
var robotService = services.GetService<IRobotService>();
if (robotService != null) {
    await robotService.MoveToPosition(new Vector3(1, 2, 3));
}
```

### 4. 配置驱动模式（Configuration-Driven Pattern）

适用场景：
- 灵活的系统行为配置
- 无需修改代码的功能调整
- 复杂的事件路由

配置文件示例：
```json
{
  "routes": [
    {
      "name": "button_to_robot",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "control_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.MoveJointEvent",
          "parameters": {
            "jointName": "base_rotation",
            "angle": 45
          }
        }
      ]
    }
  ]
}
```

## 完整代码实现

### 1. 基础事件和数据结构

```csharp
// ModSystem.Core/Common/CommonEvents.cs
using UnityEngine;
using System;

namespace ModSystem.Core
{
    public class InteractionEvent : IModEvent
    {
        public string EventId => "interaction";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        
        public GameObject TargetObject { get; set; }
        public InteractionType InteractionType { get; set; }
        public Vector3 InteractionPoint { get; set; }
    }
    
    public enum InteractionType
    {
        Click,
        Press,
        Release,
        Hover,
        Exit
    }
    
    public class EmergencyStopEvent : IModEvent
    {
        public string EventId => "emergency_stop";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        public string Reason { get; set; }
    }
    
    public interface IModAPI
    {
        IRequestResponseManager RequestResponse { get; }
        IAudioAPI Audio { get; }
        IUtilityAPI Utilities { get; }
        IObjectFactory ObjectFactory { get; }
    }
    
    public interface IObjectFactory
    {
        Task<GameObject> CreateObjectAsync(string definitionPath);
        Task<GameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition);
    }
}
```

### 2. 按钮模组实现

```csharp
// ButtonMod/ButtonBehaviour.cs
using UnityEngine;
using ModSystem.Core;
using System;
using System.Collections.Generic;

namespace ButtonMod
{
    public class ButtonPressedEvent : IModEvent
    {
        public string EventId => "button_pressed";
        public string SenderId { get; set; }
        public DateTime Timestamp { get; set; }
        
        public string ButtonId { get; set; }
        public string ButtonType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
    }
    
    public class ButtonBehaviour : IModBehaviour
    {
        public string BehaviourId => "interactive_button";
        public string Version => "1.0.0";
        
        private IModContext context;
        private ButtonConfiguration config;
        private ButtonState state;
        private float lastPressTime;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            config = LoadConfiguration();
            state = new ButtonState();
            
            SetupInteraction();
            context.EventBus.Subscribe<InteractionEvent>(OnInteraction);
            
            if (config.UseServiceMode)
            {
                context.EventBus.Subscribe<ServiceRegisteredEvent>(OnServiceRegistered);
            }
            
            context.Log($"Button {config.ButtonId} initialized");
        }
        
        private void SetupInteraction()
        {
            var collider = context.GameObject.GetComponent<Collider>();
            if (collider == null)
            {
                collider = context.GameObject.AddComponent<BoxCollider>();
            }
            
            context.GameObject.layer = LayerMask.NameToLayer("Interactable");
            
            var renderer = context.GetComponent<Renderer>();
            if (renderer != null)
            {
                renderer.material.color = config.NormalColor;
            }
        }
        
        private void OnInteraction(InteractionEvent e)
        {
            if (e.TargetObject != context.GameObject)
                return;
            
            if (e.InteractionType == InteractionType.Click)
            {
                OnButtonPress();
            }
            else if (e.InteractionType == InteractionType.Release)
            {
                OnButtonRelease();
            }
        }
        
        private void OnButtonPress()
        {
            if (Time.time - lastPressTime < config.CooldownTime)
                return;
            
            lastPressTime = Time.time;
            state.IsPressed = true;
            
            AnimatePress();
            
            switch (config.CommunicationMode)
            {
                case CommunicationMode.Event:
                    PublishButtonEvent();
                    break;
                    
                case CommunicationMode.RequestResponse:
                    SendButtonRequest();
                    break;
                    
                case CommunicationMode.Service:
                    CallButtonService();
                    break;
                    
                case CommunicationMode.Configured:
                    ExecuteConfiguredActions();
                    break;
            }
            
            if (!string.IsNullOrEmpty(config.ClickSound))
            {
                context.API.Audio.PlaySound(config.ClickSound);
            }
        }
        
        private void PublishButtonEvent()
        {
            var buttonEvent = new ButtonPressedEvent
            {
                SenderId = BehaviourId,
                ButtonId = config.ButtonId,
                ButtonType = config.ButtonType.ToString(),
                Parameters = config.EventParameters
            };
            
            context.EventBus.Publish(buttonEvent);
            context.Log($"Published button event: {config.ButtonId}");
        }
        
        public void OnUpdate(float deltaTime)
        {
            if (state.IsPressed && config.ButtonType == ButtonType.Momentary)
            {
                state.PressedTime += deltaTime;
                if (state.PressedTime >= config.MomentaryDuration)
                {
                    OnButtonRelease();
                }
            }
        }
        
        public void OnDestroy()
        {
            context.Log($"Button {config.ButtonId} destroyed");
        }
        
        // 辅助方法实现...
        private ButtonConfiguration LoadConfiguration()
        {
            return new ButtonConfiguration();
        }
        
        private void AnimatePress()
        {
            var transform = context.GameObject.transform;
            var renderer = context.GetComponent<Renderer>();
            
            transform.localPosition += Vector3.down * config.PressDepth;
            
            if (renderer != null)
            {
                renderer.material.color = config.PressedColor;
            }
        }
        
        private void OnButtonRelease()
        {
            state.IsPressed = false;
            AnimateRelease();
        }
        
        private void AnimateRelease()
        {
            var transform = context.GameObject.transform;
            var renderer = context.GetComponent<Renderer>();
            
            transform.localPosition -= Vector3.down * config.PressDepth;
            
            if (renderer != null)
            {
                renderer.material.color = config.NormalColor;
            }
        }
    }
    
    [System.Serializable]
    public class ButtonConfiguration
    {
        public string ButtonId = "button_01";
        public ButtonType ButtonType = ButtonType.Momentary;
        public CommunicationMode CommunicationMode = CommunicationMode.Event;
        
        public Color NormalColor = Color.white;
        public Color PressedColor = Color.green;
        public float PressDepth = 0.02f;
        
        public float CooldownTime = 0.5f;
        public float MomentaryDuration = 0.2f;
        
        public Dictionary<string, object> EventParameters = new Dictionary<string, object>();
        public string RequestAction = "button_action";
        public bool UseServiceMode = false;
        public string TargetServiceType = "IRobotService";
        
        public string ClickSound = "button_click";
    }
    
    public enum ButtonType
    {
        Momentary,
        Toggle,
        Hold
    }
    
    public enum CommunicationMode
    {
        Event,
        RequestResponse,
        Service,
        Configured
    }
    
    public class ButtonState
    {
        public bool IsPressed { get; set; }
        public float PressedTime { get; set; }
        public int ClickCount { get; set; }
    }
}
```

### 3. 机器人模组实现

```csharp
// RobotMod/RobotArmBehaviour.cs
using UnityEngine;
using ModSystem.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace RobotMod
{
    public interface IRobotService : IModService
    {
        Task<bool> MoveJoint(string jointName, float angle, float speed = 30f);
        Task<bool> MoveToPosition(Vector3 position);
        Task<Vector3> GetEndEffectorPosition();
        Task<RobotStatus> GetStatus();
        void EmergencyStop();
    }
    
    public class RobotStatus
    {
        public Dictionary<string, float> JointAngles { get; set; }
        public Vector3 EndEffectorPosition { get; set; }
        public bool IsMoving { get; set; }
        public string CurrentState { get; set; }
    }
    
    public class RobotArmBehaviour : IModBehaviour, IRobotService
    {
        public string BehaviourId => "robot_arm_controller";
        public string Version => "2.0.0";
        
        public string ServiceId => "robot_arm_service";
        public string ProviderId => "RobotMod";
        string IModService.Version => Version;
        
        private IModContext context;
        private RobotConfiguration config;
        private Dictionary<string, JointController> joints;
        private KinematicsController kinematics;
        private bool emergencyStop = false;
        
        public void OnInitialize(IModContext context)
        {
            this.context = context;
            
            config = LoadConfiguration();
            InitializeJoints();
            kinematics = new KinematicsController(joints, config);
            
            context.Services.RegisterService<IRobotService>(this);
            SubscribeToEvents();
            
            context.Log($"Robot arm {ServiceId} initialized with {joints.Count} joints");
        }
        
        private void InitializeJoints()
        {
            joints = new Dictionary<string, JointController>();
            
            foreach (var jointConfig in config.Joints)
            {
                var jointTransform = context.GameObject.transform.Find(jointConfig.Name);
                if (jointTransform != null)
                {
                    var controller = new JointController(jointTransform, jointConfig);
                    joints[jointConfig.Name] = controller;
                }
                else
                {
                    context.LogError($"Joint {jointConfig.Name} not found in model");
                }
            }
        }
        
        private void SubscribeToEvents()
        {
            context.EventBus.Subscribe<ButtonPressedEvent>(OnButtonPressed);
            context.EventBus.Subscribe<RobotControlRequest>(OnControlRequest);
            context.EventBus.Subscribe<EmergencyStopEvent>(e => EmergencyStop());
        }
        
        public async Task<bool> MoveJoint(string jointName, float angle, float speed = 30f)
        {
            if (emergencyStop) return false;
            
            if (joints.TryGetValue(jointName, out var joint))
            {
                PublishStateChange(jointName, "moving", angle);
                await joint.MoveToAngle(angle, speed);
                PublishStateChange(jointName, "idle", angle);
                return true;
            }
            
            return false;
        }
        
        public async Task<bool> MoveToPosition(Vector3 position)
        {
            if (emergencyStop) return false;
            
            var jointAngles = kinematics.CalculateInverseKinematics(position);
            
            if (jointAngles != null)
            {
                var tasks = new List<Task<bool>>();
                foreach (var kvp in jointAngles)
                {
                    tasks.Add(MoveJoint(kvp.Key, kvp.Value));
                }
                
                var results = await Task.WhenAll(tasks);
                return results.All(r => r);
            }
            
            return false;
        }
        
        public async Task<Vector3> GetEndEffectorPosition()
        {
            return await Task.Run(() => kinematics.GetEndEffectorPosition());
        }
        
        public async Task<RobotStatus> GetStatus()
        {
            return await Task.Run(() =>
            {
                var status = new RobotStatus
                {
                    JointAngles = new Dictionary<string, float>(),
                    EndEffectorPosition = kinematics.GetEndEffectorPosition(),
                    IsMoving = joints.Values.Any(j => j.IsMoving),
                    CurrentState = emergencyStop ? "emergency_stop" : "operational"
                };
                
                foreach (var kvp in joints)
                {
                    status.JointAngles[kvp.Key] = kvp.Value.CurrentAngle;
                }
                
                return status;
            });
        }
        
        public void EmergencyStop()
        {
            emergencyStop = true;
            
            foreach (var joint in joints.Values)
            {
                joint.Stop();
            }
            
            context.EventBus.Publish(new RobotStateChangedEvent
            {
                SenderId = ServiceId,
                Status = "emergency_stop"
            });
            
            context.Log("Emergency stop activated");
        }
        
        public void OnUpdate(float deltaTime)
        {
            if (emergencyStop) return;
            
            foreach (var joint in joints.Values)
            {
                joint.Update(deltaTime);
            }
            
            if (config.EnableCollisionDetection)
            {
                CheckCollisions();
            }
        }
        
        public void OnDestroy()
        {
            context.Services.UnregisterService<IRobotService>(ServiceId);
            
            foreach (var joint in joints.Values)
            {
                joint.Dispose();
            }
            
            context.Log($"Robot arm {ServiceId} destroyed");
        }
        
        // 辅助方法实现...
        private RobotConfiguration LoadConfiguration()
        {
            return new RobotConfiguration
            {
                Joints = new List<JointConfiguration>
                {
                    new JointConfiguration { Name = "base_rotation", RotationAxis = Vector3.up },
                    new JointConfiguration { Name = "shoulder_pitch", RotationAxis = Vector3.right },
                    new JointConfiguration { Name = "elbow_pitch", RotationAxis = Vector3.right }
                }
            };
        }
    }
    
    public class JointController
    {
        private readonly Transform transform;
        private readonly JointConfiguration config;
        private float currentAngle;
        private float targetAngle;
        private float velocity;
        
        public bool IsMoving => Math.Abs(targetAngle - currentAngle) > 0.1f;
        public float CurrentAngle => currentAngle;
        
        public JointController(Transform transform, JointConfiguration config)
        {
            this.transform = transform;
            this.config = config;
            this.currentAngle = config.InitialAngle;
            this.targetAngle = config.InitialAngle;
        }
        
        public async Task MoveToAngle(float angle, float speed)
        {
            targetAngle = Mathf.Clamp(angle, config.MinAngle, config.MaxAngle);
            
            while (IsMoving)
            {
                await Task.Delay(10);
            }
        }
        
        public void Update(float deltaTime)
        {
            if (!IsMoving) return;
            
            float error = targetAngle - currentAngle;
            velocity = Mathf.Clamp(
                error * config.Kp,
                -config.MaxVelocity,
                config.MaxVelocity
            );
            
            currentAngle += velocity * deltaTime;
            
            transform.localRotation = Quaternion.AngleAxis(
                currentAngle,
                config.RotationAxis
            );
        }
        
        public void Stop()
        {
            targetAngle = currentAngle;
            velocity = 0;
        }
        
        public void Dispose()
        {
            // 清理资源
        }
    }
    
    [Serializable]
    public class RobotConfiguration
    {
        public string RobotId = "robot_01";
        public List<JointConfiguration> Joints = new List<JointConfiguration>();
        public bool EnableCollisionDetection = true;
        public bool EnableIK = true;
        public float DefaultSpeed = 30f;
    }
    
    [Serializable]
    public class JointConfiguration
    {
        public string Name;
        public Vector3 RotationAxis = Vector3.up;
        public float MinAngle = -180f;
        public float MaxAngle = 180f;
        public float InitialAngle = 0f;
        public float MaxVelocity = 60f;
        public float Kp = 5f;
        public float Ki = 0.1f;
        public float Kd = 1f;
    }
}
```

### 4. 配置驱动的通信路由

```csharp
// ModSystem.Core/Communication/CommunicationRouter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    public class CommunicationConfig
    {
        public List<RouteConfig> Routes { get; set; }
        public List<WorkflowConfig> Workflows { get; set; }
    }
    
    public class RouteConfig
    {
        public string Name { get; set; }
        public string SourceEvent { get; set; }
        public List<ConditionConfig> Conditions { get; set; }
        public List<ActionConfig> Actions { get; set; }
    }
    
    public class ConditionConfig
    {
        public string Property { get; set; }
        public string Operator { get; set; }
        public object Value { get; set; }
    }
    
    public class ActionConfig
    {
        public string TargetMod { get; set; }
        public string EventType { get; set; }
        public Dictionary<string, object> Parameters { get; set; }
        public int Delay { get; set; }
    }
    
    public class CommunicationRouter
    {
        private readonly IEventBus eventBus;
        private readonly CommunicationConfig config;
        private readonly Dictionary<string, List<RouteConfig>> routeMap;
        
        public CommunicationRouter(IEventBus eventBus, string configJson)
        {
            this.eventBus = eventBus;
            this.config = JsonConvert.DeserializeObject<CommunicationConfig>(configJson);
            this.routeMap = BuildRouteMap();
            
            SubscribeToEvents();
        }
        
        private Dictionary<string, List<RouteConfig>> BuildRouteMap()
        {
            var map = new Dictionary<string, List<RouteConfig>>();
            
            foreach (var route in config.Routes)
            {
                if (!map.ContainsKey(route.SourceEvent))
                {
                    map[route.SourceEvent] = new List<RouteConfig>();
                }
                map[route.SourceEvent].Add(route);
            }
            
            return map;
        }
        
        private void SubscribeToEvents()
        {
            foreach (var eventType in routeMap.Keys)
            {
                var method = typeof(CommunicationRouter)
                    .GetMethod(nameof(HandleEvent))
                    .MakeGenericMethod(Type.GetType(eventType));
                    
                var handler = Delegate.CreateDelegate(
                    typeof(Action<>).MakeGenericType(Type.GetType(eventType)),
                    this,
                    method
                );
                
                eventBus.GetType()
                    .GetMethod("Subscribe")
                    .MakeGenericMethod(Type.GetType(eventType))
                    .Invoke(eventBus, new[] { handler });
            }
        }
        
        public void HandleEvent<T>(T eventData) where T : IModEvent
        {
            var eventType = typeof(T).Name;
            
            if (routeMap.TryGetValue(eventType, out var routes))
            {
                foreach (var route in routes)
                {
                    if (EvaluateConditions(route.Conditions, eventData))
                    {
                        ExecuteActions(route.Actions, eventData);
                    }
                }
            }
        }
        
        private bool EvaluateConditions<T>(List<ConditionConfig> conditions, T eventData)
        {
            if (conditions == null || conditions.Count == 0)
                return true;
            
            foreach (var condition in conditions)
            {
                var value = GetPropertyValue(eventData, condition.Property);
                
                if (!EvaluateCondition(value, condition.Operator, condition.Value))
                    return false;
            }
            
            return true;
        }
        
        private bool EvaluateCondition(object value, string op, object expected)
        {
            switch (op)
            {
                case "==":
                    return Equals(value, expected);
                case "!=":
                    return !Equals(value, expected);
                case ">":
                    return Comparer<object>.Default.Compare(value, expected) > 0;
                case "<":
                    return Comparer<object>.Default.Compare(value, expected) < 0;
                case "contains":
                    return value?.ToString().Contains(expected.ToString()) ?? false;
                default:
                    return false;
            }
        }
        
        private async void ExecuteActions<T>(List<ActionConfig> actions, T sourceEvent)
        {
            foreach (var action in actions)
            {
                if (action.Delay > 0)
                {
                    await Task.Delay(action.Delay);
                }
                
                var parameters = PrepareParameters(action.Parameters, sourceEvent);
                var targetEvent = CreateEvent(action.EventType, parameters);
                eventBus.Publish(targetEvent);
            }
        }
        
        private object GetPropertyValue(object obj, string propertyPath)
        {
            var properties = propertyPath.Split('.');
            object current = obj;
            
            foreach (var prop in properties)
            {
                if (current == null) return null;
                
                var propertyInfo = current.GetType().GetProperty(prop);
                if (propertyInfo == null) return null;
                
                current = propertyInfo.GetValue(current);
            }
            
            return current;
        }
        
        private Dictionary<string, object> PrepareParameters<T>(
            Dictionary<string, object> templateParams, 
            T sourceEvent)
        {
            return new Dictionary<string, object>(templateParams);
        }
        
        private IModEvent CreateEvent(string eventTypeName, Dictionary<string, object> parameters)
        {
            var eventType = Type.GetType(eventTypeName);
            if (eventType == null)
            {
                throw new InvalidOperationException($"Event type {eventTypeName} not found");
            }
            
            var eventInstance = Activator.CreateInstance(eventType) as IModEvent;
            
            foreach (var param in parameters)
            {
                var property = eventType.GetProperty(param.Key);
                if (property != null && property.CanWrite)
                {
                    property.SetValue(eventInstance, param.Value);
                }
            }
            
            return eventInstance;
        }
    }
}
```

### 5. 对象工厂系统（替代Prefab）

```csharp
// ModSystem.Core/Runtime/ObjectFactory.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using Newtonsoft.Json;

namespace ModSystem.Core
{
    [Serializable]
    public class ObjectDefinition
    {
        public string objectId { get; set; }
        public string name { get; set; }
        public List<ComponentDefinition> components { get; set; }
    }
    
    [Serializable]
    public class ComponentDefinition
    {
        public string type { get; set; }
        public Dictionary<string, object> properties { get; set; }
        
        public T GetProperty<T>(string key, T defaultValue = default)
        {
            if (properties != null && properties.TryGetValue(key, out var value))
            {
                try
                {
                    return (T)Convert.ChangeType(value, typeof(T));
                }
                catch
                {
                    return defaultValue;
                }
            }
            return defaultValue;
        }
    }
    
    public class ModObjectFactory
    {
        private readonly Dictionary<string, ObjectDefinition> definitionCache;
        
        public ModObjectFactory()
        {
            definitionCache = new Dictionary<string, ObjectDefinition>();
        }
        
        public async Task<GameObject> CreateObjectAsync(string definitionPath)
        {
            ObjectDefinition definition;
            
            if (definitionCache.ContainsKey(definitionPath))
            {
                definition = definitionCache[definitionPath];
            }
            else
            {
                var json = await LoadJsonAsync(definitionPath);
                definition = JsonConvert.DeserializeObject<ObjectDefinition>(json);
                definitionCache[definitionPath] = definition;
            }
            
            var gameObject = new GameObject(definition.name);
            
            foreach (var compDef in definition.components)
            {
                await AddComponentAsync(gameObject, compDef);
            }
            
            return gameObject;
        }
        
        public async Task<GameObject> CreateObjectFromDefinitionAsync(ObjectDefinition definition)
        {
            var gameObject = new GameObject(definition.name);
            
            foreach (var compDef in definition.components)
            {
                await AddComponentAsync(gameObject, compDef);
            }
            
            return gameObject;
        }
        
        private async Task AddComponentAsync(GameObject obj, ComponentDefinition compDef)
        {
            switch (compDef.type)
            {
                case "Transform":
                    ConfigureTransform(obj.transform, compDef);
                    break;
                    
                case "MeshRenderer":
                    await ConfigureMeshRenderer(obj, compDef);
                    break;
                    
                case "BoxCollider":
                    ConfigureBoxCollider(obj, compDef);
                    break;
                    
                case "SphereCollider":
                    ConfigureSphereCollider(obj, compDef);
                    break;
                    
                case "ModBehaviour":
                    ConfigureModBehaviour(obj, compDef);
                    break;
                    
                case "RigidBody":
                    ConfigureRigidBody(obj, compDef);
                    break;
                    
                default:
                    Debug.LogWarning($"Unknown component type: {compDef.type}");
                    break;
            }
        }
        
        private void ConfigureTransform(Transform transform, ComponentDefinition compDef)
        {
            var position = compDef.GetProperty<float[]>("position", new float[] { 0, 0, 0 });
            var rotation = compDef.GetProperty<float[]>("rotation", new float[] { 0, 0, 0 });
            var scale = compDef.GetProperty<float[]>("scale", new float[] { 1, 1, 1 });
            
            transform.position = new Vector3(position[0], position[1], position[2]);
            transform.rotation = Quaternion.Euler(rotation[0], rotation[1], rotation[2]);
            transform.localScale = new Vector3(scale[0], scale[1], scale[2]);
        }
        
        // 其他配置方法实现...
        
        private async Task<string> LoadJsonAsync(string path)
        {
            return await Task.Run(() => System.IO.File.ReadAllText(path));
        }
    }
}
```

## 使用示例

### 1. 基本事件通信

```csharp
// 按钮模组发送事件
public class SimpleButton : IModBehaviour
{
    public string BehaviourId => "simple_button";
    public string Version => "1.0.0";
    
    private IModContext context;
    
    public void OnInitialize(IModContext context)
    {
        this.context = context;
    }
    
    void OnClick()
    {
        context.EventBus.Publish(new ButtonPressedEvent
        {
            SenderId = "simple_button",
            ButtonId = "btn_1",
            Parameters = new Dictionary<string, object>
            {
                { "action", "rotate_robot" },
                { "angle", 45f }
            }
        });
    }
    
    public void OnUpdate(float deltaTime) { }
    public void OnDestroy() { }
}
```

### 2. 请求-响应通信

```csharp
// 按钮发送请求
public class SmartButton : IModBehaviour
{
    async void OnClick()
    {
        var request = new RobotControlRequest
        {
            SenderId = "smart_button",
            Command = "move_joint",
            Parameters = new Dictionary<string, object>
            {
                { "jointName", "base_rotation" },
                { "angle", 90f }
            }
        };
        
        try
        {
            var response = await context.API.RequestResponse
                .SendRequestAsync<RobotControlRequest, RobotControlResponse>(
                    request, 
                    TimeSpan.FromSeconds(5)
                );
            
            if (response.Success)
            {
                context.Log("Robot moved successfully");
            }
        }
        catch (TimeoutException)
        {
            context.LogError("Robot did not respond in time");
        }
    }
}
```

### 3. 服务调用

```csharp
// 使用服务的按钮
public class ServiceButton : IModBehaviour
{
    private IRobotService robotService;
    
    public void OnInitialize(IModContext context)
    {
        robotService = context.Services.GetService<IRobotService>();
        
        if (robotService == null)
        {
            context.EventBus.Subscribe<ServiceRegisteredEvent>(e =>
            {
                if (e.ServiceType == nameof(IRobotService))
                {
                    robotService = context.Services.GetService<IRobotService>();
                }
            });
        }
    }
    
    async void OnClick()
    {
        if (robotService != null)
        {
            bool success = await robotService.MoveJoint("base_rotation", 45f);
            if (success)
            {
                context.Log("Robot rotated successfully");
            }
        }
    }
}
```

### 4. 使用对象定义创建游戏对象

```csharp
public class ModWithObjects : IModBehaviour
{
    private IModContext context;
    private List<GameObject> createdObjects = new List<GameObject>();
    
    public async void OnInitialize(IModContext context)
    {
        this.context = context;
        
        // 从对象定义创建按钮
        var buttonObj = await context.API.ObjectFactory
            .CreateObjectAsync("Objects/interactive_button.json");
        
        buttonObj.transform.position = new Vector3(0, 1, 0);
        createdObjects.Add(buttonObj);
        
        // 动态创建对象
        var dynamicDef = new ObjectDefinition
        {
            objectId = "dynamic_cube",
            name = "动态立方体",
            components = new List<ComponentDefinition>
            {
                new ComponentDefinition
                {
                    type = "Transform",
                    properties = new Dictionary<string, object>
                    {
                        { "position", new[] { 5f, 0f, 0f } },
                        { "scale", new[] { 2f, 2f, 2f } }
                    }
                }
            }
        };
        
        var cube = await context.API.ObjectFactory
            .CreateObjectFromDefinitionAsync(dynamicDef);
        createdObjects.Add(cube);
    }
}
```

## 配置说明

### 1. 模组配置结构

```json
{
  "mod": {
    "id": "button_robot_system",
    "version": "1.0.0",
    "modules": [
      {
        "id": "button_module",
        "type": "ButtonMod.ButtonBehaviour",
        "config": {
          "buttonId": "main_button",
          "communicationMode": "Service",
          "targetService": "IRobotService"
        }
      },
      {
        "id": "robot_module",
        "type": "RobotMod.RobotArmBehaviour",
        "config": {
          "joints": [
            {
              "name": "base_rotation",
              "axis": [0, 1, 0],
              "minAngle": -180,
              "maxAngle": 180
            }
          ]
        }
      }
    ]
  }
}
```

### 2. 通信配置

```json
{
  "routes": [
    {
      "name": "button_to_robot_rotation",
      "sourceEvent": "ButtonMod.ButtonPressedEvent",
      "conditions": [
        {
          "property": "ButtonId",
          "operator": "==",
          "value": "rotate_button"
        }
      ],
      "actions": [
        {
          "targetMod": "robot_mod",
          "eventType": "RobotMod.RotateJointEvent",
          "parameters": {
            "jointName": "base_rotation",
            "angle": 45,
            "speed": 30
          }
        }
      ]
    }
  ]
}
```

### 3. 对象定义示例

```json
{
  "objectId": "interactive_button_01",
  "name": "交互按钮",
  "components": [
    {
      "type": "Transform",
      "properties": {
        "position": [0, 1, 0],
        "rotation": [0, 0, 0],
        "scale": [1, 0.2, 1]
      }
    },
    {
      "type": "MeshRenderer",
      "properties": {
        "model": "Models/button.gltf",
        "material": {
          "shader": "Standard",
          "color": [1, 1, 1, 1],
          "metallic": 0.5,
          "smoothness": 0.8
        }
      }
    },
    {
      "type": "BoxCollider",
      "properties": {
        "center": [0, 0, 0],
        "size": [1, 0.2, 1],
        "isTrigger": false
      }
    },
    {
      "type": "ModBehaviour",
      "properties": {
        "behaviourClass": "ButtonMod.ButtonBehaviour",
        "config": {
          "buttonId": "btn_01",
          "buttonType": "toggle",
          "clickSound": "audio/click.wav"
        }
      }
    }
  ]
}
```

## 独立模组开发（无需Unity）

### 1. ModSDK - 独立开发包

#### ModSDK.Core.dll 实现
```csharp
// ModSDK.Core/Interfaces.cs
using System;
using System.Collections.Generic;

namespace ModSDK.Core
{
    public interface IModBehaviour
    {
        string BehaviourId { get; }
        string Version { get; }
        void OnInitialize(IModContext context);
        void OnUpdate(float deltaTime);
        void OnDestroy();
    }
    
    public struct Vector3
    {
        public float x, y, z;
        
        public Vector3(float x, float y, float z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        
        public static Vector3 Zero => new Vector3(0, 0, 0);
        public static Vector3 One => new Vector3(1, 1, 1);
        public static Vector3 Up => new Vector3(0, 1, 0);
        
        public static implicit operator UnityEngine.Vector3(Vector3 v)
        {
            return new UnityEngine.Vector3(v.x, v.y, v.z);
        }
    }
}
```

### 2. ModBuilder - 命令行构建工具

```csharp
// ModBuilder/Program.cs
using System;
using System.IO;
using System.Diagnostics;

namespace ModBuilder
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("╔══════════════════════════════╗");
            Console.WriteLine("║     Mod Builder v1.0.0       ║");
            Console.WriteLine("║   Unity模组独立开发工具       ║");
            Console.WriteLine("╚══════════════════════════════╝\n");
            
            if (args.Length == 0)
            {
                ShowInteractiveMenu();
            }
            else
            {
                ProcessCommand(args);
            }
        }
        
        static void ShowInteractiveMenu()
        {
            while (true)
            {
                Console.WriteLine("\n请选择操作:");
                Console.WriteLine("1. 创建新模组项目");
                Console.WriteLine("2. 构建现有模组");
                Console.WriteLine("3. 测试模组");
                Console.WriteLine("4. 打包模组");
                Console.WriteLine("5. 查看帮助");
                Console.WriteLine("6. 退出");
                Console.Write("\n请输入选项 (1-6): ");
                
                var choice = Console.ReadLine();
                
                switch (choice)
                {
                    case "1":
                        CreateNewMod();
                        break;
                    case "2":
                        BuildMod();
                        break;
                    case "3":
                        TestMod();
                        break;
                    case "4":
                        PackageMod();
                        break;
                    case "5":
                        ShowHelp();
                        break;
                    case "6":
                        return;
                }
            }
        }
        
        static void CreateNewMod()
        {
            Console.WriteLine("=== 创建新模组 ===\n");
            
            Console.Write("模组ID (例如: my_custom_mod): ");
            var modId = Console.ReadLine()?.ToLower().Replace(" ", "_");
            
            Console.Write("模组名称: ");
            var modName = Console.ReadLine();
            
            Console.Write("作者名称: ");
            var author = Console.ReadLine();
            
            Console.WriteLine("\n选择模组类型:");
            Console.WriteLine("1. 按钮模组");
            Console.WriteLine("2. 机器人模组");
            Console.WriteLine("3. 传感器模组");
            Console.WriteLine("4. 空白模组");
            Console.Write("\n请选择 (1-4): ");
            
            var modType = Console.ReadLine();
            
            // 创建项目结构
            CreateModProject(modId, modName, author, modType);
        }
        
        // 其他方法实现...
    }
}
```

### 3. 安装和使用说明

#### 创建第一个模组

1. **运行ModBuilder**
   ```bash
   ModBuilder
   ```

2. **按照交互式菜单创建模组**
   - 选择 "1" 创建新模组
   - 输入模组信息
   - 选择模组类型

3. **编辑模组代码**
   ```bash
   code my_custom_mod/
   ```

4. **编辑对象定义**
   - 打开 `Objects/` 目录
   - 编辑 JSON 文件定义游戏对象

5. **构建模组**
   ```bash
   ModBuilder
   # 选择 "2" 构建模组
   ```

6. **打包模组**
   ```bash
   ModBuilder
   # 选择 "4" 打包模组
   ```

### 4. 开发流程

#### 创建新模组

```bash
# 方式1：交互式创建
ModBuilder

# 方式2：命令行参数
ModBuilder new my_custom_mod --type button --author "Your Name"
```

这会创建以下结构：
```
my_custom_mod/
├── Source/
│   └── MyCustomModBehaviour.cs
├── Objects/
│   └── interactive_button.json
├── Models/
├── Config/
│   └── config.json
├── Resources/
├── SDK/
├── MyCustomMod.csproj
├── manifest.json
└── README.md
```

## 最佳实践

### 1. 选择合适的通信模式

| 场景 | 推荐模式 | 原因 |
|------|----------|------|
| 状态通知 | 事件模式 | 简单、解耦、一对多 |
| 命令执行 | 请求-响应 | 需要确认、错误处理 |
| API调用 | 服务模式 | 类型安全、紧密协作 |
| 复杂流程 | 配置驱动 | 灵活、可维护 |

### 2. 开发建议

1. **使用版本控制**：所有模组都应该有明确的版本号
2. **编写单元测试**：为模组编写自动化测试
3. **文档齐全**：为每个模组提供详细的API文档
4. **遵循命名规范**：使用统一的命名约定
5. **性能监控**：在开发时监控模组的性能影响
6. **使用对象定义**：通过JSON文件定义游戏对象，而不是依赖Unity编辑器
7. **模型格式标准化**：统一使用glTF格式的3D模型
8. **配置驱动开发**：尽可能通过配置文件控制行为，减少硬编码

## 安装和部署

### 1. 主系统集成（Unity项目）

在Unity项目中集成模组系统：

1. 将 `ModSystem/Core/` 文件夹复制到Unity项目的 `Assets/` 目录
2. 创建 `StreamingAssets/Mods/` 文件夹用于存放模组
3. 创建 `StreamingAssets/ModPackages/` 文件夹用于存放.modpack文件
4. 在场景中创建 `ModManager` GameObject并添加相应组件

### 2. 模组安装（用户端）

```bash
# 方式1：安装.modpack文件
1. 下载 xxx.modpack 文件
2. 将文件复制到：游戏目录/StreamingAssets/ModPackages/
3. 重启游戏或在游戏内刷新模组列表

# 方式2：手动安装（开发者模式）
1. 将模组文件夹复制到：游戏目录/StreamingAssets/Mods/
2. 确保包含manifest.json和所有必要文件
```

### 3. 快速参考

| 文件类型 | 位置 | 说明 |
|---------|------|------|
| **核心接口** | `Assets/ModSystem/Core/Interfaces/` | 所有模组共享的接口定义 |
| **事件系统** | `Assets/ModSystem/Core/EventSystem/` | 事件总线实现 |
| **通信系统** | `Assets/ModSystem/Core/Communication/` | 请求响应、路由等 |
| **服务系统** | `Assets/ModSystem/Core/Services/` | 服务注册表 |
| **对象工厂** | `Assets/ModSystem/Core/Runtime/ObjectFactory.cs` | 运行时对象创建 |
| **模组代码** | `[ModName]/Source/` | 各模组的C#源代码 |
| **对象定义** | `[ModName]/Objects/` | JSON格式的对象定义 |
| **3D模型** | `[ModName]/Models/` | glTF格式的3D模型 |
| **模组配置** | `[ModName]/Config/` | 模组配置文件 |
| **通信配置** | `Assets/StreamingAssets/ModConfigs/` | 全局通信配置 |
| **模组包** | `Assets/StreamingAssets/ModPackages/` | .modpack文件 |

## 总结

这个完整的模组通信系统提供了：

1. **多种通信模式**：满足不同场景需求
2. **类型安全**：通过接口和泛型保证类型安全
3. **灵活配置**：支持配置驱动的通信路由
4. **独立开发**：无需Unity编辑器即可开发模组
5. **对象定义系统**：使用JSON替代Unity的Prefab
6. **完整工具链**：从开发到打包的全流程支持

通过这个系统，开发者可以：
- 在不安装Unity的情况下开发模组
- 使用多种通信方式实现模组间交互
- 通过配置文件灵活定义系统行为
- 使用JSON定义复杂的游戏对象
- 确保系统的安全性和稳定性